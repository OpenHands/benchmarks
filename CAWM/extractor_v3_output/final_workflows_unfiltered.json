{
  "type1_workflows": [
    {
      "name": "Hardening Django ORM SQL Compilation for Ordering, Combinators, Expressions, and Lookups",
      "description": "Diagnose and fix issues in Django ORM SQL generation and resolution, including ORDER BY on complex paths, combinator queries with empty parents, operator commutativity between Q and conditional expressions, and iterable lookup reconstruction.",
      "steps": [
        "Step 1: Reproduce representative cases across domains: create minimal models to exercise Meta.ordering and inheritance/foreign key paths; build union()/intersection()/difference() queries and apply .none(); combine Q(...) with Exists(...); and use iterable lookups like __range with named tuples",
        "Step 2: Inspect core compilation and resolution paths: review django/db/models/sql/compiler.py (get_order_by, find_ordering_name, get_combinator_sql), django/db/models/sql/query.py (names_to_path, setup_joins, resolve_lookup_value), and operator protocols in query_utils.py and expressions.py",
        "Step 3: Implement targeted fixes: add guards to prevent relation recursion and preserve explicit ASC/DESC when ordering by pk or resolved fields; compare attname against the final path component to avoid unnecessary joins; short-circuit combined execution when the parent query is empty; make & and | commutative by returning NotImplemented in Q for non-Q conditionals and by implementing __rand__/__ror__ in Combinable; adjust iterable lookup reconstruction to properly unpack named tuples while preserving behavior for lists and tuples",
        "Step 4: Add focused regression tests: ordering and multi-table inheritance cases; empty combined querysets with .none(); expressions and operator commutativity; iterable lookup resolution (including namedtuple ranges); verify form behavior (e.g., ModelMultipleChoiceField) when relevant",
        "Step 5: Run broader suites (ordering, queries, expressions, lookups) to verify correctness and avoid regressions"
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-12470",
        "django__django-13033",
        "django__django-13158",
        "django__django-14017",
        "django__django-13590"
      ]
    },
    {
      "name": "Correcting Model Metadata, Inheritance, Proxy Traversal, and Relationship Validation",
      "description": "Address issues involving abstract/concrete inheritance, proxy model behavior, and relationship metadata by fixing method binding, metadata traversal, identity hashing, and validator guidance.",
      "steps": [
        "Step 1: Build minimal reproductions demonstrating inheritance and proxy behaviors (e.g., overriding choices methods, select_related() + only() on a proxy-related FK) and relation identity hashing failures (e.g., ManyToManyRel.identity with through_fields=list)",
        "Step 2: Locate binding and traversal points: inspect Field.contribute_to_class for get_FOO_display binding and django/db/models/sql/query.py for deferred loading across proxies; review relation identity construction and checks",
        "Step 3: Implement fixes: bind display methods to the current class unless explicitly overridden by the user; traverse proxy models using concrete_model._meta to ensure correct metadata resolution; wrap unhashable identity components with make_hashable() to avoid TypeError; update validator hints and error messages to provide modern, accurate guidance (e.g., for recursive relationships)",
        "Step 4: Add targeted tests across model_fields, model_inheritance, defer_regress, proxy_models, m2m_through, and invalid_models to assert correct behavior and identity shapes",
        "Step 5: Run related ORM suites to ensure the changes do not introduce regressions across inheritance, proxies, and relationship validation"
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-12284",
        "django__django-15814",
        "django__django-14672",
        "django__django-12497"
      ]
    },
    {
      "name": "Eliminating Duplicate Choices in Forms and Admin Selects",
      "description": "Prevent duplicate options in form field choices or admin select widgets when limit_choices_to applies joins or complex filters.",
      "steps": [
        "Step 1: Reproduce with a minimal ModelForm or ModelAdmin using limit_choices_to with joins or Q filters to confirm duplicates",
        "Step 2: Identify where choice querysets are constructed and restricted (forms/models.py and db/models/fields get_choices paths)",
        "Step 3: Enforce distinct() after applying complex_filter(limit_choices_to) in the central utility functions used by form fields and get_choices",
        "Step 4: Add regression tests that create multiple related rows causing duplicate result rows on join and assert unique IDs in choices and form field querysets",
        "Step 5: Run targeted and broader form/admin test suites to ensure no regressions"
      ],
      "source_clusters": [
        "Forms and Formsets Behavior and Rendering"
      ],
      "source_trajectories": [
        "django__django-13315"
      ]
    },
    {
      "name": "Standardizing Form/FormSet Error Messages and Rendering, and Managing Hidden-Only Form Deprecation Warnings",
      "description": "Ensure validation error messages consistently include offending values and improve error rendering and deprecation warning behavior, distinguishing non-field/non-form errors and suppressing irrelevant warnings for hidden-only forms.",
      "steps": [
        "Step 1: Audit error messages and rendering by reproducing invalid inputs and examining ErrorList class assignments for forms and formsets; reproduce deprecation warnings by rendering hidden-only forms (e.g., ManagementForm) and confirm the renderer/template path causing the warning",
        "Step 2: Inspect default_error_messages and ValidationError raising paths, and review how forms assign nonfield classes and how formsets construct non-form errors; identify where default template deprecation warnings are emitted",
        "Step 3: Update default_error_messages to include placeholders like %(value)s and pass params={'value': <input>} when raising ValidationError; ensure FormSet-level non-form errors use a consistent error_class (e.g., nonform) and preserve that class when recreating ErrorList; add a special-case check to skip deprecation warnings for forms with no visible_fields",
        "Step 4: Update documentation describing error classes and provide rendered HTML examples for nonfield and nonform errors; add tests asserting offending values appear in error messages, that nonfield/nonform CSS classes are present and stable, and that warnings are suppressed for hidden-only forms but still raised for regular forms",
        "Step 5: Run form, formsets, admin inlines, and deprecation-related test suites to verify behavior and prevent regressions"
      ],
      "source_clusters": [
        "Forms and Formsets Behavior and Rendering"
      ],
      "source_trajectories": [
        "django__django-13933",
        "django__django-14608",
        "django__django-15902"
      ]
    },
    {
      "name": "Safely Constructing FormSet.empty_form with form_kwargs",
      "description": "Prevent crashes when constructing a formset\u2019s empty_form by avoiding duplicated keyword arguments such as empty_permitted.",
      "steps": [
        "Step 1: Reproduce the crash by accessing empty_form when empty_permitted is present in form_kwargs, testing both True and False",
        "Step 2: Locate the empty_form construction path and inspect how kwargs are combined",
        "Step 3: Remove or override conflicting entries (e.g., pop empty_permitted from form_kwargs) during empty_form construction",
        "Step 4: Add tests verifying empty_form creation succeeds across values of empty_permitted and that regular forms still respect form_kwargs",
        "Step 5: Run formsets and model formsets suites to confirm robustness and no regressions in template rendering"
      ],
      "source_clusters": [
        "Forms and Formsets Behavior and Rendering"
      ],
      "source_trajectories": [
        "django__django-16041"
      ]
    },
    {
      "name": "Refactoring Django Admin to Expose Extension Points",
      "description": "Enable downstream customization by extracting and documenting public hooks in Django admin, avoiding the need to override entire views.",
      "steps": [
        "Step 1: Identify rigid or private logic that downstream code frequently customizes (e.g., private helpers or hardcoded response formats)",
        "Step 2: Locate the implementation and callers in django/contrib/admin to understand data flow and usage",
        "Step 3: Refactor the logic into a public method or hook (e.g., rename a private method, add a serialize_result() method) with sensible defaults",
        "Step 4: Update internal callers to use the new extension point while keeping signatures backward compatible",
        "Step 5: Document the new extension point (docstrings) and include examples of common overrides",
        "Step 6: Add or update tests to verify default behavior and demonstrate that custom overrides work",
        "Step 7: Run focused admin test suites (e.g., admin_views, admin_widgets) to confirm no regressions"
      ],
      "source_clusters": [
        "Admin and Autocomplete Features"
      ],
      "source_trajectories": [
        "django__django-13447",
        "django__django-14752"
      ]
    },
    {
      "name": "Aligning Admin Defaults with Model Meta Semantics",
      "description": "Ensure Django admin components derive default values consistently with model Meta behavior, such as verbose_name_plural derivation from verbose_name when unset.",
      "steps": [
        "Step 1: Identify inconsistencies between admin defaults and model Meta behavior",
        "Step 2: Inspect admin components to see how defaults are currently computed and when overrides apply",
        "Step 3: Implement conditional defaulting logic that derives values from existing attributes when explicit values are not provided",
        "Step 4: Preserve explicit overrides and avoid changing behavior when no custom values are specified",
        "Step 5: Consider localization by using lazy formatting where appropriate",
        "Step 6: Add tests covering scenarios with and without explicit verbose_name_plural and with custom verbose_name",
        "Step 7: Run admin_inlines and related suites to ensure compatibility"
      ],
      "source_clusters": [
        "Admin and Autocomplete Features"
      ],
      "source_trajectories": [
        "django__django-13710"
      ]
    },
    {
      "name": "Hardening Admin URLs for ForeignKey to_field and Alternative Identifiers",
      "description": "Fix admin navigation that breaks when ForeignKey uses to_field or alternate identifiers by generating URLs based on true primary keys or reversed named routes.",
      "steps": [
        "Step 1: Reproduce the broken navigation path and capture the failing generated URL",
        "Step 2: Locate the form/template code constructing the link",
        "Step 3: Replace brittle relative paths with URLs that use the object\u2019s primary key or reverse-resolved routes",
        "Step 4: Verify link generation for both standard PK and to_field-based navigation",
        "Step 5: Ensure changes are minimal and do not alter unrelated help text or UI",
        "Step 6: Add tests or scripts confirming correct resolution in both contexts",
        "Step 7: Run auth_tests and admin_views subsets to confirm no regressions"
      ],
      "source_clusters": [
        "Admin and Autocomplete Features"
      ],
      "source_trajectories": [
        "django__django-16139"
      ]
    },
    {
      "name": "Ensuring RFC-Compliant HTTP Date Parsing and Resilient Header Handling in Views",
      "description": "Fix protocol compliance in HTTP date parsing, especially RFC 7231/RFC 850 two-digit year handling, and restore resilient behavior in view helpers that should ignore empty or invalid headers.",
      "steps": [
        "Step 1: Review the specifications and bug reports to understand expected behavior; identify target utilities (parse_http_date, parse_http_date_safe) and affected formats (RFC1123, RFC850, asctime), and confirm affected view helpers (e.g., was_modified_since in django/views/static.py)",
        "Step 2: Create minimal test harnesses to reproduce current behavior across formats and boundary conditions (including the 50-year cutoff for RFC850) and to trigger header handling errors in views; confirm exception sources",
        "Step 3: Implement fixes: dynamic two-digit year mapping based on the current year for RFC850 with correct boundary logic, preserving behavior for RFC1123 and asctime; adjust guards/exception handling in views/static to treat empty/invalid headers as ignored rather than raising",
        "Step 4: Add comprehensive boundary and cross-format tests, including exact 50-year boundary and four-digit year cases; validate parse_http_date_safe and ensure public helpers retain their contracts; add targeted view/staticfiles tests",
        "Step 5: Run Django\u2019s relevant test suites (utils_tests.test_http, view_tests, staticfiles_tests) to verify correctness and guard against regressions"
      ],
      "source_clusters": [
        "HTTP and URL Handling"
      ],
      "source_trajectories": [
        "django__django-11848",
        "django__django-15498"
      ]
    },
    {
      "name": "Debugging URL Resolver Argument Handling with Optional Groups",
      "description": "Resolve issues where optional URL parameters result in incorrect positional arguments or TypeErrors when invoking views.",
      "steps": [
        "Step 1: Build a minimal example using a URLConf with re_path and optional named groups to trigger the failing behavior",
        "Step 2: Inspect django/urls/resolvers.py to see how match results are converted into args and kwargs, noting how named groups override positional groups",
        "Step 3: Identify None values from optional groups being passed as positional args and implement a minimal fix (e.g., drop None from positional args or keep args empty when kwargs exist) without altering documented resolver behavior",
        "Step 4: Re-run the reproducer and URL-related test suites (e.g., urlpatterns_reverse) to ensure correctness and no regressions",
        "Step 5: Validate adjacent components (RoutePattern/path) are unaffected and document the change"
      ],
      "source_clusters": [
        "HTTP and URL Handling"
      ],
      "source_trajectories": [
        "django__django-12184"
      ]
    },
    {
      "name": "Improving Migration Serialization and Import Generation",
      "description": "Fix serialization of nested classes/enums and ensure migrations include required imports (e.g., models) so generated files import and execute correctly.",
      "steps": [
        "Step 1: Reproduce issues by generating migrations that serialize nested classes/enums and cases where migrations reference django.db.models symbols (e.g., models.Model) without imports.",
        "Step 2: Inspect the migration serializer implementations (TypeSerializer and DeconstructableSerializer) and the migration writer to understand how paths and imports are produced.",
        "Step 3: Use __qualname__ instead of __name__ to preserve nested class names; plan a fallback for local classes where __qualname__ includes '<locals>'.",
        "Step 4: Adjust path handling by progressively importing path components to detect the true module boundary and construct correct qualified names.",
        "Step 5: Ensure the serializer requests required imports for special cases (e.g., references to django.db.models) so migration writer emits 'from django.db import migrations, models' as needed.",
        "Step 6: Update the migration writer to generate and merge correct import statements without duplication and to target actual modules rather than class paths.",
        "Step 7: Validate by running focused migration writer tests and custom scripts that serialize nested classes/enums and base classes, confirming correct paths and imports.",
        "Step 8: Run broader migration-related test modules to ensure no regressions and document the change and rationale."
      ],
      "source_clusters": [
        "Migrations and Schema Operations"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-14580"
      ]
    },
    {
      "name": "Resolving Schema Editor Constraint Conflicts for Composed Indexes",
      "description": "Fix migration crashes when deleting index_together where unique_together exists on the same fields by disambiguating constraint selection.",
      "steps": [
        "Step 1: Reproduce the crash by defining a model with both unique_together and index_together on identical fields and attempting to remove index_together via the schema editor.",
        "Step 2: Inspect backend/base/schema.py to understand how _constraint_names filters constraints and how _delete_composed_index selects a single matching constraint.",
        "Step 3: Identify that unique constraints often report index=True and plan to disambiguate deletion of pure indexes by explicitly excluding unique constraints.",
        "Step 4: Modify the call site (e.g., alter_index_together) to pass filters that include {'index': True, 'unique': False} when deleting composed indexes.",
        "Step 5: Re-run the reproduction and related schema tests to ensure the ValueError is resolved and the correct constraint is dropped.",
        "Step 6: Verify that removing index_together does not remove Meta.indexes and validate across multiple scenarios (indexes only, unique only, mixed).",
        "Step 7: Document the minimal change and its rationale to ensure maintainers understand the disambiguation."
      ],
      "source_clusters": [
        "Migrations and Schema Operations"
      ],
      "source_trajectories": [
        "django__django-12708"
      ]
    },
    {
      "name": "Hardening Django\u2019s Autoreloader Against Filesystem Anomalies",
      "description": "Prevent crashes in the development autoreloader by auditing path resolution and adding defensive handling.",
      "steps": [
        "Step 1: Review the error stack trace to identify the failing function and line number in the autoreloader.",
        "Step 2: Locate django/utils/autoreload.py and examine functions that resolve file paths and modules.",
        "Step 3: Search for calls to pathlib.Path.resolve and other path normalization points to find crash sites.",
        "Step 4: Design a minimal defensive fix that catches unexpected exceptions (e.g., ValueError for embedded null bytes) without disabling file watching.",
        "Step 5: Apply consistent exception handling across all relevant call sites (e.g., iter_modules_and_files and sys_path_directories).",
        "Step 6: Add a regression test that mocks the failing call (e.g., Path.resolve) to raise the observed exception and assert the autoreloader continues functioning.",
        "Step 7: Run the autoreloader tests and any related developer tooling tests to confirm no regressions."
      ],
      "source_clusters": [
        "Developer Tooling (CLI, Devserver, Introspection)"
      ],
      "source_trajectories": [
        "django__django-11583"
      ]
    },
    {
      "name": "Fixing Argument Handling and Path Normalization in Management Commands",
      "description": "Correct ordering and normalization issues in management commands to align with external tools and Python semantics.",
      "steps": [
        "Step 1: Reproduce the problematic CLI behavior with minimal scripts or direct command invocation to observe the exact failure.",
        "Step 2: Consult external tool documentation (e.g., psql\u2019s expected argument syntax) or standard library behavior (e.g., os.path.basename) to understand the root cause.",
        "Step 3: Locate the command implementation in django/core/management or backend client modules and inspect how arguments or paths are constructed.",
        "Step 4: Identify the minimal change needed (e.g., placing user parameters before dbname; stripping trailing path separators before basename).",
        "Step 5: Implement the fix with a small, localized change to reduce risk.",
        "Step 6: Add a regression test in the appropriate suite (e.g., tests/admin_scripts/ for startapp, tests/dbshell/ for dbshell) covering the exact failure scenario.",
        "Step 7: Run targeted tests and then broader suites to ensure the change doesn\u2019t cause regressions elsewhere."
      ],
      "source_clusters": [
        "Developer Tooling (CLI, Devserver, Introspection)"
      ],
      "source_trajectories": [
        "django__django-14382",
        "django__django-15851"
      ]
    },
    {
      "name": "Improving inspectdb Relation Generation to Avoid Reverse Accessor Clashes",
      "description": "Ensure models generated by inspectdb produce unique reverse accessors by adding related_name for duplicate relations.",
      "steps": [
        "Step 1: Build a minimal database schema with multiple ForeignKey fields pointing to the same related model.",
        "Step 2: Run inspectdb and review the generated model code to verify how related fields are emitted.",
        "Step 3: Locate inspectdb\u2019s relation generation logic and determine where extra field parameters are built.",
        "Step 4: Track repeated references to the same related model within a single model and generate a deterministic related_name for subsequent occurrences.",
        "Step 5: Regenerate models and run Django\u2019s model checks to ensure fields.E304 reverse accessor clashes are resolved.",
        "Step 6: Add a regression test in tests/inspectdb to cover multiple FKs to the same model and assert the presence of unique related_name values.",
        "Step 7: Run inspectdb tests, and optionally cross-backend tests, to confirm correct behavior."
      ],
      "source_clusters": [
        "Developer Tooling (CLI, Devserver, Introspection)"
      ],
      "source_trajectories": [
        "django__django-15819"
      ]
    },
    {
      "name": "Designing and Running Targeted Regression Tests in Django\u2019s Repo",
      "description": "Create robust, minimal regression tests and execute Django\u2019s in-repo test suites effectively, including transaction-related changes.",
      "steps": [
        "Step 1: Install the Django repository in editable mode to ensure imports and entry points work as expected.",
        "Step 2: Use Django\u2019s tests/runtests.py over external runners for consistent behavior; set DJANGO_SETTINGS_MODULE where required.",
        "Step 3: Identify minimal failing conditions and reproduce them; choose the appropriate existing test suite and pattern (e.g., admin_scripts, inspectdb, dbshell).",
        "Step 4: Author minimal, isolated regression tests using unique names and isolated directories to avoid PYTHONPATH conflicts; write assertions for expected outputs and absence of crashes.",
        "Step 5: Run targeted modules, classes, or methods with increased verbosity; iterate quickly using single-test invocations and disable parallelism for determinism when debugging.",
        "Step 6: For transaction-related changes, execute focused suites (e.g., transaction tests, migration and fixtures tests) to verify behavior and detect unintended side effects.",
        "Step 7: Scale up to broader suites and enable parallelization judiciously after establishing a passing baseline.",
        "Step 8: Document test rationale and link to the bug report or change for future maintainers."
      ],
      "source_clusters": [
        "Developer Tooling (CLI, Devserver, Introspection)",
        "Testing Framework and Transactions"
      ],
      "source_trajectories": [
        "django__django-11583",
        "django__django-14382",
        "django__django-15851",
        "django__django-15819",
        "django__django-12453"
      ]
    },
    {
      "name": "Diagnosing and Fixing Test Runner Serialized Rollback Issues",
      "description": "Trace Django test runner hooks (e.g., serialized_rollback) and fix integrity errors during test database restore by aligning deserialization with transactional best practices.",
      "steps": [
        "Step 1: Reproduce the issue using a TransactionTestCase with serialized_rollback=True to observe when integrity errors occur during state restore.",
        "Step 2: Search the test suite for references to serialized_rollback to see how it\u2019s configured and exercised.",
        "Step 3: Search Django\u2019s core codebase to find call sites, then inspect django/test/testcases.py to understand how TransactionTestCase triggers database serialization and restore.",
        "Step 4: Follow the call chain into backend creation and connection utilities to locate deserialize_db_from_string implementations.",
        "Step 5: Compare restore logic with the loaddata management command and design a fix to wrap deserialization inside a transaction (e.g., transaction.atomic) to defer constraint checks until commit.",
        "Step 6: Implement the fix and add a regression test demonstrating the previously failing scenario, ensuring tokens/state are restored without IntegrityError.",
        "Step 7: Run targeted transaction-related suites and broader tests to verify behavior and guard against regressions."
      ],
      "source_clusters": [
        "Testing Framework and Transactions"
      ],
      "source_trajectories": [
        "django__django-12453"
      ]
    },
    {
      "name": "Hardening Sensitive Data Sanitization in Error Reporting",
      "description": "Fix gaps in settings sanitization to ensure sensitive values are masked across nested structures in error reports.",
      "steps": [
        "Step 1: Locate the sanitization filter class and review its cleansing logic to understand supported types and recursion behavior.",
        "Step 2: Create a minimal reproduction using nested dictionaries, lists, and tuples containing sensitive keys to confirm current leaks.",
        "Step 3: Validate the current behavior by running the filter on the reproduction and inspecting outputs for uncensored values.",
        "Step 4: Design a fix to traverse nested containers (e.g., dicts, lists, tuples) while preserving container types and avoiding recursion into strings/bytes.",
        "Step 5: Add unit tests covering dictionaries, lists, tuples, nested and mixed structures, ensuring sensitive keys are masked and non-sensitive data remains unchanged.",
        "Step 6: Implement the fix with a minimal diff, introducing recursion for relevant iterables and maintaining case-insensitive key matching as needed.",
        "Step 7: Run focused tests for the filter and broader debug tests to catch regressions and verify overall stability.",
        "Step 8: Validate with an end-to-end scenario mirroring real settings structures, then document the change and its rationale."
      ],
      "source_clusters": [
        "Security and Authentication"
      ],
      "source_trajectories": [
        "django__django-12700"
      ]
    },
    {
      "name": "Ensuring Password Reset Tokens Invalidate on User Attribute Changes",
      "description": "Strengthen token generators so that changes to key user attributes (e.g., email) invalidate previously issued tokens while preserving compatibility with custom user models.",
      "steps": [
        "Step 1: Audit the token generator to inventory which user fields contribute to the hash value and identify missing attributes that should trigger invalidation.",
        "Step 2: Decide which user attributes (e.g., email) must be included to invalidate tokens appropriately on change.",
        "Step 3: Plan for custom user models by using APIs like get_email_field_name() and safe getattr defaults if the attribute is absent.",
        "Step 4: Add tests asserting tokens become invalid after changing the chosen attribute and retain existing tests for other behaviors.",
        "Step 5: Modify the hash construction to include the selected attribute value in a timezone-stable and null-safe manner.",
        "Step 6: Run token-related tests and the broader authentication suite to ensure backward compatibility and detect regressions.",
        "Step 7: Provide an end-to-end demonstration and documentation confirming invalidation on attribute change and correct behavior for new tokens."
      ],
      "source_clusters": [
        "Security and Authentication"
      ],
      "source_trajectories": [
        "django__django-13551"
      ]
    },
    {
      "name": "Aligning System Checks and Configuration Validation with Runtime and Inheritance Semantics",
      "description": "Identify, reproduce, and correct discrepancies in Django\u2019s core system checks and configuration validation (e.g., DEFAULT_AUTO_FIELD), aligning them with runtime behavior and subclass relationships.",
      "steps": [
        "Step 1: Review the reported error and Django documentation to understand expected behavior and identify the specific system check or validation involved.",
        "Step 2: Locate the check implementation in django/core/checks/ and related modules, as well as configuration validation code paths.",
        "Step 3: Create a minimal reproducible configuration using settings.configure and django.setup to trigger the system check/validation and observe failures.",
        "Step 4: Compare the check/validation logic with the corresponding runtime behavior in Django utilities and modules to identify mismatches (e.g., language fallback logic, template library discovery, or class/type handling).",
        "Step 5: Replace equality or membership-based checks with inheritance-aware logic (e.g., issubclass against known base classes) and ensure robust handling of non-type inputs.",
        "Step 6: Design and implement minimal, targeted patches that align checks/validation with runtime semantics while preserving invalid-case detection.",
        "Step 7: Add regression tests demonstrating previously failing scenarios, covering direct and multi-level subclassing and rejection of non-subclasses, and verifying corrected behavior.",
        "Step 8: Run targeted test suites (e.g., check_framework, i18n, templates, model_fields, model_options) to ensure correctness and avoid regressions.",
        "Step 9: Document the fix and rationale to aid future maintenance."
      ],
      "source_clusters": [
        "Core Utilities, System Checks, and Supporting Frameworks"
      ],
      "source_trajectories": [
        "django__django-12286",
        "django__django-15790",
        "django__django-14238"
      ]
    },
    {
      "name": "Adding Operator/Magic Method Support to Lazy Proxies",
      "description": "Extend LazyObject/SimpleLazyObject with missing special methods so Python\u2019s operator dispatch works correctly while preserving lazy initialization semantics.",
      "steps": [
        "Step 1: Identify the missing magic method(s) (e.g., __add__, __radd__, __eq__, etc.) that cause operator dispatch failures and confirm Python resolves these via the class, not the instance dict.",
        "Step 2: Create minimal reproduction tests demonstrating failures for both forward and reverse operator forms across common operators.",
        "Step 3: Inspect django/utils/functional.py to understand how LazyObject/SimpleLazyObject proxy attributes and when _setup() initializes _wrapped.",
        "Step 4: Implement the missing magic method(s) directly on LazyObject (or the appropriate proxy base) to ensure class-level operator resolution, calling _setup() as needed when _wrapped is unset.",
        "Step 5: Validate behavior with wrapped numeric, string, list, and custom types to confirm correct operator semantics and deferred evaluation are preserved.",
        "Step 6: Run Django\u2019s utils and related test suites to confirm no regressions and adjust edge-case tests as needed.",
        "Step 7: Document the change and rationale, emphasizing minimal surface area, Python operator semantics, and preservation of lazy behavior."
      ],
      "source_clusters": [
        "Core Utilities, System Checks, and Supporting Frameworks"
      ],
      "source_trajectories": [
        "django__django-15400"
      ]
    },
    {
      "name": "Preserving Function Metadata in Method Decorator Bindings",
      "description": "Ensure decorators applied to methods retain function attributes (name, module, docstring) so wrappers, introspection, and stacked decorators behave correctly.",
      "steps": [
        "Step 1: Reproduce the issue with a decorator that inspects function attributes (e.g., __name__) when applied via method_decorator.",
        "Step 2: Inspect django/utils/decorators.py to locate the binding logic where the method is adapted and passed to decorators.",
        "Step 3: Replace metadata-stripping constructs (such as functools.partial on bound methods) with a real wrapper bound to self, and copy metadata using functools.update_wrapper.",
        "Step 4: Validate behavior with single and multiple decorators, and class-level decoration via method_decorator(name=...) to ensure attributes are preserved consistently.",
        "Step 5: Run decorators and utils tests to ensure compatibility and confirm no regressions in existing decorator patterns.",
        "Step 6: Provide a concise verification and examples demonstrating preserved metadata in typical and stacked decorator usage."
      ],
      "source_clusters": [
        "Core Utilities, System Checks, and Supporting Frameworks"
      ],
      "source_trajectories": [
        "django__django-14787"
      ]
    },
    {
      "name": "Ensuring Serialization Round-Trip Integrity in Message Storage",
      "description": "Diagnose and fix serialization/deserialization edge cases in Django\u2019s messages framework so values round-trip correctly across cookie and session backends.",
      "steps": [
        "Step 1: Create minimal reproducers for encoder/decoder round-trips using edge inputs (e.g., empty strings, None, falsy extra_tags) to confirm the bug.",
        "Step 2: Inspect Message and storage backends (cookie and session) to identify where encoding/decoding decisions are made.",
        "Step 3: Find conditions that rely on truthiness and mis-handle valid falsy values; replace them with explicit checks (e.g., is None) to distinguish None from empty strings.",
        "Step 4: Validate end-to-end storage cycles for cookie and session backends and confirm templates can safely use message.extra_tags and related fields.",
        "Step 5: Run messages-specific tests to ensure the patch doesn\u2019t regress other behaviors or encodings.",
        "Step 6: Document the change, highlighting impacts on template usage and backend storage safety."
      ],
      "source_clusters": [
        "Core Utilities, System Checks, and Supporting Frameworks"
      ],
      "source_trajectories": [
        "django__django-15347"
      ]
    },
    {
      "name": "Adding Optional, Backward-Compatible Parameters to Core Utilities",
      "description": "Add optional parameters to core utility functions and their wrappers (e.g., json_script\u2019s JSON encoder) while preserving default behavior and updating dependents.",
      "steps": [
        "Step 1: Locate the utility function and any wrappers (e.g., template filters, helpers) that depend on it.",
        "Step 2: Define the new optional parameter with a default that exactly matches current behavior to ensure backward compatibility.",
        "Step 3: Update all wrappers to accept and pass through the new parameter, preserving existing call patterns and defaults.",
        "Step 4: Write tests and examples that cover both default behavior and customized usage of the new parameter.",
        "Step 5: Run targeted test suites for both the utility and wrappers to confirm correctness and compatibility.",
        "Step 6: Document usage patterns and best practices, including how to supply custom encoders or handle Django-specific types."
      ],
      "source_clusters": [
        "Core Utilities, System Checks, and Supporting Frameworks"
      ],
      "source_trajectories": [
        "django__django-15789"
      ]
    },
    {
      "name": "Propagating Supported Fields Through Layered Frameworks (including Syndication Feeds)",
      "description": "Ensure fields already supported by a downstream generator/output layer are correctly passed through upstream view/controller layers so they appear in generated artifacts; applicable to layered architectures and patterns like Django syndication feeds.",
      "steps": [
        "Step 1: Verify the output/generator layer already supports the target field by reviewing its API and output format (e.g., feedgenerator.add_item parameters).",
        "Step 2: Trace the data flow upstream to identify where items are constructed and passed to the generator, noting dynamic attribute access or mapping patterns.",
        "Step 3: Update the view/controller layer to pass the missing field through established mappings or dynamic accessors (e.g., add item_* methods on Feed subclasses and plumb them to add_item arguments).",
        "Step 4: Add or update tests asserting the field now appears in the generated output (e.g., RSS elements such as <comments>) and behaves as expected.",
        "Step 5: Validate with a minimal reproducer and run the relevant test subsets (e.g., tests/syndication_tests) to ensure no regressions.",
        "Step 6: Update documentation for the public API (e.g., Feed item_* attributes) if the new field is intended for authors."
      ],
      "source_clusters": [
        "Miscellaneous and Less Common Frameworks"
      ],
      "source_trajectories": [
        "django__django-13230"
      ]
    }
  ],
  "type2_workflows": [
    {
      "name": "Resolve ORDER BY name mapping to avoid pk flips and unnecessary FK joins",
      "description": "Audit and adjust Django's ORDER BY resolution in the SQL compiler to preserve descending pk across multi-table inheritance and prevent extra JOINs/wrong directions when ordering on FK columns.",
      "steps": [
        {
          "reasoning": "Identify where ORDER BY terms are resolved to fields and directions to locate logic that flips '-pk' or incorrectly injects related ordering.",
          "action": "grep -n \"def find_ordering_name\" django/db/models/sql/compiler.py && sed -n '690,750p' django/db/models/sql/compiler.py"
        },
        {
          "reasoning": "Confirm how default ordering and name resolution are applied when traversing relations, and find the pk shortcut and relation comparison.",
          "action": "sed -n '714,735p' django/db/models/sql/compiler.py"
        },
        {
          "reasoning": "Locate the condition that applies related model Meta.ordering when a relation is traversed and ensure we're comparing the final lookup piece.",
          "action": "grep -A 10 \"field.is_relation and opts.ordering\" {repo_path}/django/db/models/sql/compiler.py"
        },
        {
          "reasoning": "Skip relation-based Meta.ordering injection when the name is the 'pk' shortcut to preserve explicit pk direction through inheritance.",
          "action": "apply_patch {repo_path}/django/db/models/sql/compiler.py 's/\\(getattr(field, \\\"attname\\\", None) != name\\)/\\1 and name != \\\"pk\\\"/g'"
        },
        {
          "reasoning": "Compare the FK attname against the last lookup piece to correctly detect order_by('..._id') and avoid extra joins and wrong direction.",
          "action": "apply_patch {repo_path}/django/db/models/sql/compiler.py \"s/getattr(field, 'attname', None) != name/getattr(field, 'attname', None) != pieces[-1]/\""
        },
        {
          "reasoning": "Verify inheritance pk ordering remains stable and prints expected SQL.",
          "action": "python {workspace}/test_reproduce_issue.py"
        },
        {
          "reasoning": "Validate self-referential FK ordering on 'ref__parent_id' vs 'ref__parent__id' yields no extra join and correct ASC/DESC.",
          "action": "python {workspace}/test_self_ref_ordering.py"
        },
        {
          "reasoning": "Run suites covering ordering behavior and general queries to detect regressions.",
          "action": "cd {repo_path}/tests && python runtests.py ordering queries --verbosity=1"
        }
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-12470",
        "django__django-13033"
      ]
    },
    {
      "name": "Bind get_FOO_display to child field choices in inheritance",
      "description": "Ensure get_FOO_display autogeneration binds to the child field when overriding choices, while preserving explicit method overrides in the class dict.",
      "steps": [
        {
          "reasoning": "Locate the auto-binding of get_FOO_display during field contribution to understand current method attachment logic.",
          "action": "grep -n \"contribute_to_class\" {repo_path}/django/db/models/fields/__init__.py && sed -n '750,780p' {repo_path}/django/db/models/fields/__init__.py"
        },
        {
          "reasoning": "Modify the guard to avoid using an inherited method when choices are overridden on the subclass, but keep user-defined overrides intact.",
          "action": "apply_patch {repo_path}/django/db/models/fields/__init__.py \"s/if not hasattr(cls, 'get_%s_display' % self.name):/method_name = 'get_%s_display' % self.name\\n        if method_name not in cls.__dict__:/\""
        },
        {
          "reasoning": "Create a minimal app with an abstract base and child overriding choices; call the display method for new choice values.",
          "action": "python {repo_path}/test_display_bug.py"
        },
        {
          "reasoning": "Run model_fields and model_inheritance tests to ensure no regressions in display and inheritance behavior.",
          "action": "cd {repo_path} && PYTHONPATH={repo_path} python tests/runtests.py model_fields model_inheritance --verbosity=1"
        }
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-12284"
      ]
    },
    {
      "name": "Short-circuit combined queries when the parent QuerySet is empty",
      "description": "Make QuerySet.none() propagate emptiness for union/intersection/difference by raising EmptyResultSet early in the combinator SQL path.",
      "steps": [
        {
          "reasoning": "Open the SQL compiler method handling combined queries and identify where combined_queries are executed.",
          "action": "grep -n \"def get_combinator_sql\" {repo_path}/django/db/models/sql/compiler.py && sed -n '433,486p' {repo_path}/django/db/models/sql/compiler.py"
        },
        {
          "reasoning": "Insert an early guard to raise EmptyResultSet when the parent Query is empty to avoid executing the combinator.",
          "action": "apply_patch {repo_path}/django/db/models/sql/compiler.py \"\\n    if self.query.is_empty():\\n        raise EmptyResultSet\\n\""
        },
        {
          "reasoning": "Verify with a minimal script that union().none() yields zero rows and forms using union() don't add all items.",
          "action": "python {workspace}/test_bug_simple.py"
        },
        {
          "reasoning": "Run combinator and model_forms tests to ensure no regressions.",
          "action": "cd {repo_path}/tests && python runtests.py queries.test_qs_combinators model_forms --verbosity=2"
        }
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-13158"
      ]
    },
    {
      "name": "Make Q objects and conditional expressions commutative under boolean operators",
      "description": "Enable symmetric combination of Q and conditional expressions (e.g., Exists) by returning NotImplemented when appropriate and adding reverse-operator hooks.",
      "steps": [
        {
          "reasoning": "Locate Q operator definitions that currently enforce Q-only combinations and prevent reverse operator resolution.",
          "action": "sed -n '28,98p' {repo_path}/django/db/models/query_utils.py"
        },
        {
          "reasoning": "Modify Q.__and__/__or__ to return NotImplemented for conditional non-Q operands so Python tries the right-hand operand's reverse methods.",
          "action": "apply_patch {repo_path}/django/db/models/query_utils.py \"\\n    def __and__(self, other):\\n        if not isinstance(other, Q) and getattr(other, 'conditional', False):\\n            return NotImplemented\\n        return self._combine(other, self.AND)\\n\\n    def __or__(self, other):\\n        if not isinstance(other, Q) and getattr(other, 'conditional', False):\\n            return NotImplemented\\n        return self._combine(other, self.OR)\\n\""
        },
        {
          "reasoning": "Implement __rand__/__ror__ on Combinable to wrap both sides in Q and delegate to Q combination for conditional expressions.",
          "action": "apply_patch {repo_path}/django/db/models/expressions.py \"\\n    def __rand__(self, other):\\n        from django.db.models.query_utils import Q\\n        if getattr(self, 'conditional', False):\\n            return Q(other) & Q(self)\\n        return NotImplemented\\n\\n    def __ror__(self, other):\\n        from django.db.models.query_utils import Q\\n        if getattr(self, 'conditional', False):\\n            return Q(other) | Q(self)\\n        return NotImplemented\\n\""
        },
        {
          "reasoning": "Verify that Exists() & Q() and Q() & Exists() both work and return a Q.",
          "action": "python {workspace}/test_issue_exact.py"
        },
        {
          "reasoning": "Run expressions and queries suites to ensure overall stability.",
          "action": "cd {repo_path}/tests && python runtests.py expressions queries --verbosity=1"
        }
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-14017"
      ]
    },
    {
      "name": "Support namedtuple values in __range lookup",
      "description": "Make resolve_lookup_value reconstruct namedtuple inputs correctly for range lookups by unpacking resolved sub-values.",
      "steps": [
        {
          "reasoning": "Locate resolve_lookup_value where tuple-like values are reconstructed from generators and identify how named tuples are handled.",
          "action": "grep -n \"def resolve_lookup_value\" {repo_path}/django/db/models/sql/query.py && sed -n '1070,1120p' {repo_path}/django/db/models/sql/query.py"
        },
        {
          "reasoning": "Compute resolved sub-values and unpack them when rebuilding named tuples; retain container behavior for plain tuples/lists.",
          "action": "apply_patch {repo_path}/django/db/models/sql/query.py \"\\n    resolved_values = tuple(self.resolve_lookup_value(sub_value, can_reuse, allow_joins) for sub_value in value)\\n    if hasattr(value, '_fields'):\\n        return type(value)(*resolved_values)\\n    else:\\n        return type(value)(resolved_values)\\n\""
        },
        {
          "reasoning": "Run a minimal reproduction using a namedtuple Range with __range lookup to confirm no TypeError.",
          "action": "python {workspace}/test_namedtuple_range.py"
        },
        {
          "reasoning": "Execute expressions and queries tests covering iterable lookup behaviors to guard against regressions.",
          "action": "cd {repo_path}/tests && python runtests.py expressions lookup queries --verbosity=1"
        }
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-13590"
      ]
    },
    {
      "name": "Make ManyToManyRel.identity hashable with through_fields",
      "description": "Ensure relation identity tuples include hashable through_fields by wrapping them with make_hashable to prevent TypeError during hashing and checks.",
      "steps": [
        {
          "reasoning": "Inspect ManyToManyRel.identity composition to find where through_fields are included and might be unhashable.",
          "action": "sed -n '300,320p' {repo_path}/django/db/models/fields/reverse_related.py"
        },
        {
          "reasoning": "Wrap through_fields in make_hashable() to convert lists into tuples and nested containers into hashable types.",
          "action": "apply_patch {repo_path}/django/db/models/fields/reverse_related.py \"s/self.through_fields,/make_hashable(self.through_fields),/\""
        },
        {
          "reasoning": "Run a regression test verifying identity[-2] is a tuple and hashing works with proxy models and through_fields=['child','parent'].",
          "action": "cd {repo_path}/tests && python runtests.py m2m_through --verbosity=2"
        }
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-14672"
      ]
    },
    {
      "name": "Correct recursive relationship validation hint",
      "description": "Update invalid guidance suggesting symmetrical=False on ForeignKey to correctly recommend ManyToManyField with a through model.",
      "steps": [
        {
          "reasoning": "Search for the exact hint text in related field validation to locate the erroneous string.",
          "action": "grep -n \"If you want to create a recursive relationship\" {repo_path}/django/db/models/fields/related.py"
        },
        {
          "reasoning": "Replace the hint to recommend ManyToManyField with through and remove mention of symmetrical=False.",
          "action": "apply_patch {repo_path}/django/db/models/fields/related.py \"s/use ForeignKey(\\\"%s\\\", symmetrical=False, through=\\\"%s\\\")\\./use ManyToManyField(\\\"%s\\\", through=\\\"%s\\\")\\./g\""
        },
        {
          "reasoning": "Run invalid model tests to confirm the updated hint appears and assertions pass.",
          "action": "cd {repo_path}/tests && python runtests.py invalid_models_tests.test_relative_fields --verbosity=2"
        }
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-12497"
      ]
    },
    {
      "name": "Use concrete model metadata when traversing proxies with only()+select_related()",
      "description": "Resolve PK and deferred fields correctly when following a proxy foreign key via select_related() combined with only() by using concrete_model._meta.",
      "steps": [
        {
          "reasoning": "Locate metadata traversal during select-related population and deferred field resolution to identify current use of _meta.",
          "action": "grep -n \"opts = cur_model._meta\" {repo_path}/django/db/models/sql/query.py && sed -n '720,760p' {repo_path}/django/db/models/sql/query.py"
        },
        {
          "reasoning": "Change traversal to use cur_model._meta.concrete_model._meta so proxy models defer to the concrete model's metadata.",
          "action": "apply_patch {repo_path}/django/db/models/sql/query.py \"s/opts = cur_model._meta/opts = cur_model._meta.concrete_model._meta/\""
        },
        {
          "reasoning": "Run a regression test querying select_related('custom').only('custom__name') where custom is a proxy FK to confirm no ValueError.",
          "action": "cd {repo_path}/tests && python runtests.py defer_regress.tests.DeferRegressionTest.test_select_related_only_proxy_fk --verbosity=2"
        }
      ],
      "source_clusters": [
        "ORM and Query/Model Behavior Bugs"
      ],
      "source_trajectories": [
        "django__django-15814"
      ]
    },
    {
      "name": "Improve choice filtering and ModelChoiceField validation feedback",
      "description": "Eliminate duplicate choices produced by limit_choices_to joins by applying distinct(), and enhance ModelChoiceField's invalid choice message to include the offending value.",
      "steps": [
        {
          "reasoning": "Identify all code paths that apply limit_choices_to to querysets for forms and choice generation.",
          "action": "grep -r \"limit_choices_to\" django/ --include=\"*.py\""
        },
        {
          "reasoning": "Pinpoint form-side application of limit_choices_to for ModelChoiceField generation.",
          "action": "grep -n \"apply_limit_choices_to_to_formfield\" django/forms/models.py && sed -n '80,130p' django/forms/models.py"
        },
        {
          "reasoning": "Inspect get_choices implementations on model fields and reverse-related fields that may use complex_filter.",
          "action": "sed -n '850,920p' django/db/models/fields/__init__.py && sed -n '130,180p' django/db/models/fields/reverse_related.py"
        },
        {
          "reasoning": "Implement distinct() after complex_filter(limit_choices_to) to eliminate duplicates from joins on form fields.",
          "action": "Apply change in your editor: in django/forms/models.py apply_limit_choices_to_to_formfield(), set formfield.queryset = formfield.queryset.complex_filter(limit_choices_to).distinct()"
        },
        {
          "reasoning": "Ensure choices for admin/widgets also respect distinct() to avoid duplicate dropdown options.",
          "action": "Apply change in your editor: in django/db/models/fields/__init__.py Field.get_choices(), set qs = rel_model._default_manager.complex_filter(limit_choices_to).distinct()"
        },
        {
          "reasoning": "Propagate distinct() for reverse-related get_choices to cover all relation directions.",
          "action": "Apply change in your editor: in django/db/models/fields/reverse_related.py ForeignObjectRel.get_choices(), set qs = self.related_model._default_manager.complex_filter(limit_choices_to).distinct()"
        },
        {
          "reasoning": "Locate ModelChoiceField to inspect default_error_messages and ValidationError raising behavior.",
          "action": "grep -n \"class ModelChoiceField\" django/forms/models.py && sed -n '1180,1310p' django/forms/models.py"
        },
        {
          "reasoning": "Compare behavior with ModelMultipleChoiceField which already includes %(value)s and align messages.",
          "action": "grep -n \"class ModelMultipleChoiceField\" django/forms/models.py && sed -n '1310,1400p' django/forms/models.py"
        },
        {
          "reasoning": "Update the default error message to include the offending value placeholder.",
          "action": "Apply change in your editor: in ModelChoiceField.default_error_messages['invalid_choice'], use 'Select a valid choice. %(value)s is not one of the available choices.'"
        },
        {
          "reasoning": "Ensure the ValidationError includes params so the message interpolates the submitted value.",
          "action": "Apply change in your editor: in ModelChoiceField.to_python(), raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice', params={'value': value})"
        },
        {
          "reasoning": "Run targeted tests to verify error message formatting and overall stability.",
          "action": "cd tests && python runtests.py model_forms.test_modelchoicefield --verbosity=2"
        },
        {
          "reasoning": "Validate behavior with a focused test run in model_fields where limit_choices_to is exercised.",
          "action": "cd tests && python runtests.py model_fields --verbosity=2"
        }
      ],
      "source_clusters": [
        "Forms and Formsets Behavior and Rendering"
      ],
      "source_trajectories": [
        "django__django-13315",
        "django__django-13933"
      ]
    },
    {
      "name": "Enhance form/formset rendering and empty_form construction; suppress hidden-only deprecation warning",
      "description": "Improve rendering by adding a 'nonform' class to FormSet non-form errors, fix empty_form kwargs to avoid TypeError, and suppress default template deprecation warnings for forms with only hidden fields.",
      "steps": [
        {
          "reasoning": "Find where FormSet constructs non-form errors to attach a CSS class and ensure consistent error list handling.",
          "action": "grep -n \"non_form_errors\" django/forms/formsets.py && sed -n '280,390p' django/forms/formsets.py"
        },
        {
          "reasoning": "Initialize non-form errors with ErrorList that carries a 'nonform' class to distinguish rendering.",
          "action": "Apply change in your editor: set self._non_form_errors = self.error_class(error_class='nonform') in FormSet.full_clean() before validation aggregation"
        },
        {
          "reasoning": "Preserve the 'nonform' class when recreating ErrorList from a ValidationError.",
          "action": "Apply change in your editor: when catching ValidationError e, set self._non_form_errors = self.error_class(e.error_list, error_class='nonform')"
        },
        {
          "reasoning": "Find empty_form construction to see how kwargs are combined and why duplicates occur.",
          "action": "grep -n \"empty_form\" django/forms/formsets.py && sed -n '250,280p' django/forms/formsets.py"
        },
        {
          "reasoning": "Remove conflicting entries like empty_permitted from form_kwargs before calling the form constructor.",
          "action": "Apply change in your editor: in FormSet.empty_form, assign form_kwargs = self.get_form_kwargs(None); form_kwargs.pop('empty_permitted', None); then pass empty_permitted=True explicitly"
        },
        {
          "reasoning": "Locate where form rendering emits the deprecation warning for default templates.",
          "action": "grep -n \"DEFAULT_TEMPLATE_DEPRECATION\" django/forms/utils.py && sed -n '1,220p' django/forms/utils.py"
        },
        {
          "reasoning": "Implement a condition to skip the warning for forms that have no visible fields.",
          "action": "Apply change in your editor: in RenderableMixin.render(), before warnings.warn(...), check hasattr(self, 'visible_fields') and not self.visible_fields()"
        },
        {
          "reasoning": "Verify suppression with a reproduction script that renders ManagementForm and inspects warnings.",
          "action": "python - << 'PY'\nimport warnings, django\nfrom django.conf import settings\nsettings.configure(DEBUG=True, SECRET_KEY='x', FORM_RENDERER='django.forms.renderers.DjangoTemplates')\ndjango.setup()\nfrom django.forms.formsets import ManagementForm\nwith warnings.catch_warnings(record=True) as w:\n    warnings.simplefilter('always')\n    _ = ManagementForm().as_table()\n    print('Warnings count:', len(w))\nPY"
        },
        {
          "reasoning": "Run formset tests and admin inlines to confirm error rendering remains correct.",
          "action": "cd tests && python runtests.py forms_tests.tests.test_formsets admin_inlines --verbosity=1"
        },
        {
          "reasoning": "Run focused tests confirming empty_form construction works even when form_kwargs includes empty_permitted.",
          "action": "cd tests && python -m pytest tests/forms_tests/tests/test_formsets.py::FormsFormsetTestCase::test_form_kwargs_empty_form -q"
        },
        {
          "reasoning": "Validate across variants including model formsets and inline formsets.",
          "action": "cd tests && python runtests.py model_formsets inline_formsets --verbosity=1"
        },
        {
          "reasoning": "Run targeted deprecation tests to ensure regular forms still emit the appropriate warnings.",
          "action": "cd tests && python runtests.py forms_tests.tests.test_formsets.DeprecationTests.test_warning --verbosity=2"
        }
      ],
      "source_clusters": [
        "Forms and Formsets Behavior and Rendering"
      ],
      "source_trajectories": [
        "django__django-14608",
        "django__django-16041",
        "django__django-15902"
      ]
    },
    {
      "name": "Auditing and Verifying Django Admin Changes Quickly",
      "description": "Locate admin code surfaces with grep/find, verify refactorings via Python introspection, and bootstrap the Django tests settings for quick runtime checks without full test cases.",
      "steps": [
        {
          "reasoning": "Find where a target symbol is implemented and referenced to understand the scope of change.",
          "action": "grep -r \"{symbol_name}\" {project_root}/django/contrib/admin --include=\"*.py\""
        },
        {
          "reasoning": "Discover related admin files (e.g., views, options, sites) that may contain logic to modify.",
          "action": "find {project_root}/django/django -name \"*{keyword}*.py\" -path \"*/admin/*\""
        },
        {
          "reasoning": "Confirm exact file and line numbers before editing.",
          "action": "grep -n \"{symbol_name}\" {project_root}/django/django/contrib/admin/{module}.py"
        },
        {
          "reasoning": "Check that a refactored method exists and old methods are removed.",
          "action": "python -c \"from django.contrib.admin.sites import AdminSite; import inspect; print('build_app_dict exists:', hasattr(AdminSite, 'build_app_dict')); print('old _build_app_dict exists:', hasattr(AdminSite, '_build_app_dict'))\""
        },
        {
          "reasoning": "Verify internal callers use the new method name/signature.",
          "action": "python -c \"from django.contrib.admin.sites import AdminSite; import inspect; src=inspect.getsource(AdminSite.get_app_list); print('Calls build_app_dict:', 'build_app_dict(' in src)\""
        },
        {
          "reasoning": "Confirm new extension hooks exist and inspect defaults.",
          "action": "python -c \"from django.contrib.admin.views.autocomplete import AutocompleteJsonView; import inspect; print('serialize_result exists:', hasattr(AutocompleteJsonView,'serialize_result')); print(inspect.getsource(AutocompleteJsonView.serialize_result))\""
        },
        {
          "reasoning": "Initialize Django using the tests settings to import and quickly check admin components.",
          "action": "python -c \"import os, sys, django; sys.path.insert(0, '{project_root}/django'); sys.path.insert(0, '{project_root}/django/tests'); os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_sqlite'); django.setup(); print('Django initialized')\""
        },
        {
          "reasoning": "Execute a quick runtime check against admin views or sites without writing tests.",
          "action": "python -c \"import os, sys, django; sys.path.insert(0, '{project_root}/django'); sys.path.insert(0, '{project_root}/django/tests'); os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_sqlite'); django.setup(); from django.contrib.admin.views.autocomplete import AutocompleteJsonView; v=AutocompleteJsonView(); print('Has serialize_result:', hasattr(v,'serialize_result'))\""
        },
        {
          "reasoning": "Import and instantiate admin core classes to ensure no import/runtime errors after edits.",
          "action": "python -c \"import os, sys, django; sys.path.insert(0, '{project_root}/django'); sys.path.insert(0, '{project_root}/django/tests'); os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_sqlite'); django.setup(); from django.contrib.admin.sites import AdminSite; site=AdminSite(); print('AdminSite ready')\""
        }
      ],
      "source_clusters": [
        "Admin and Autocomplete Features"
      ],
      "source_trajectories": [
        "django__django-13447",
        "django__django-13710",
        "django__django-14752",
        "django__django-16139"
      ]
    },
    {
      "name": "Targeted testing and minimal Django reproduction scripts",
      "description": "Run Django\u2019s test runner against local changes and create minimal, programmatically configured scripts to reproduce issues quickly.",
      "steps": [
        {
          "reasoning": "Install the repository in editable mode so tests run against local changes.",
          "action": "cd {repo_root} && pip install -e ."
        },
        {
          "reasoning": "Run a specific module suite to verify a related fix without running the entire test suite.",
          "action": "cd {repo_root} && python tests/runtests.py {module_name} --verbosity=2"
        },
        {
          "reasoning": "Execute a single test class or method to quickly validate a particular behavior.",
          "action": "cd {repo_root} && python tests/runtests.py {dotted_test_path} --verbosity=2"
        },
        {
          "reasoning": "Optionally run with pytest for ad-hoc targeting if preferred.",
          "action": "cd {repo_root} && python -m pytest {file_path}::{test_class_or_method} -xvs"
        },
        {
          "reasoning": "Configure Django settings programmatically for a minimal environment.",
          "action": "python - << 'PY'\nfrom django.conf import settings\nsettings.configure(DEBUG=True, SECRET_KEY='test-key', INSTALLED_APPS=['django.contrib.contenttypes','django.contrib.auth'], DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}}, FORM_RENDERER='django.forms.renderers.DjangoTemplates')\nimport django; django.setup()\nPY"
        },
        {
          "reasoning": "Define minimal models/forms and create data to exercise the target behavior.",
          "action": "python - << 'PY'\nfrom django.db import models\nfrom django.forms import ModelForm\n# Define models and form here, create data and print problematic behavior\nPY"
        },
        {
          "reasoning": "Inspect warnings, errors, or querysets to confirm the issue and later validate the fix.",
          "action": "python - << 'PY'\nimport warnings\n# render or clean fields under warnings.catch_warnings to capture deprecations\nPY"
        }
      ],
      "source_clusters": [
        "Forms and Formsets Behavior and Rendering"
      ],
      "source_trajectories": [
        "django__django-13315",
        "django__django-14608",
        "django__django-15902",
        "django__django-16041"
      ]
    },
    {
      "name": "Targeted Test Execution and Minimal Reproductions for Django Changes",
      "description": "Install Django in editable mode, create minimal repro scripts, and run focused tests (modules, classes, methods) with optional settings and PYTHONPATH adjustments for fast validation of changes.",
      "steps": [
        {
          "reasoning": "Ensure local changes are importable and used by scripts/tests by installing Django in editable mode.",
          "action": "cd {repo_root} && pip install -e . && python -c \"import django; print(django.get_version())\""
        },
        {
          "reasoning": "Ensure the local repository code is used by the test runner.",
          "action": "cd {repo_root}/django && pip install -e ."
        },
        {
          "reasoning": "Confirm the issue in isolation to ensure you understand the failure and can verify the fix later.",
          "action": "cat > {repo_root}/{script_name}.py <<'PY'\n{script_contents}\nPY\npython {repo_root}/{script_name}.py"
        },
        {
          "reasoning": "Run a specific module\u2019s tests to verify targeted functionality.",
          "action": "cd {repo_root}/django && python tests/runtests.py {module_name} --verbosity=2"
        },
        {
          "reasoning": "Run a specific test module to get fast feedback on the fix.",
          "action": "cd {repo_root} && python tests/runtests.py {module_name} --verbosity=2"
        },
        {
          "reasoning": "Execute a single test class or test method for rapid feedback.",
          "action": "cd {repo_root}/django && python tests/runtests.py {module}.{TestClass}[.{test_method}] --verbosity=2"
        },
        {
          "reasoning": "Run a single test class or method to zoom in on a scenario.",
          "action": "cd {repo_root} && python tests/runtests.py {module_name}::{class_name}::{method_name} --verbosity=2"
        },
        {
          "reasoning": "Summarize results quickly to spot failures or errors.",
          "action": "cd {repo_root}/django && python tests/runtests.py {module_name} --verbosity=1 2>&1 | grep -E \"(Ran|OK|FAILED|ERROR)\""
        },
        {
          "reasoning": "If environment path issues arise, ensure the source path is on PYTHONPATH.",
          "action": "cd {repo_root}/django && PYTHONPATH={repo_root}/django:$PYTHONPATH python tests/runtests.py {suite_name} -v 2"
        },
        {
          "reasoning": "Some tests require a particular settings module; set it explicitly.",
          "action": "cd {repo_root} && DJANGO_SETTINGS_MODULE={settings_module} python tests/runtests.py {module_name} --verbosity=2"
        },
        {
          "reasoning": "Some schema or backend-specific tests need explicit settings; provide them when necessary.",
          "action": "cd {repo_root}/django && PYTHONPATH={repo_root}/django python tests/runtests.py schema.tests --settings=test_sqlite -v 2"
        },
        {
          "reasoning": "Run a specific Django test (file/class/method) with the correct settings to validate behavior quickly.",
          "action": "cd {repo_root}/tests && python -m django test {dotted_test_target} --settings={settings_module} -v 2"
        },
        {
          "reasoning": "Optionally run multiple related test packages to catch adjacent regressions.",
          "action": "cd {repo_root}/django && PYTHONPATH={repo_root}/django python tests/runtests.py migrations.test_writer migrations.test_operations migrations.test_autodetector --verbosity=0"
        },
        {
          "reasoning": "After applying a fix, re-run the reproduction to verify the specific behavior change.",
          "action": "python {repo_root}/{script_name}.py"
        }
      ],
      "source_clusters": [
        "Admin and Autocomplete Features",
        "HTTP and URL Handling",
        "Migrations and Schema Operations",
        "Developer Tooling (CLI, Devserver, Introspection)",
        "Security and Authentication"
      ],
      "source_trajectories": [
        "django__django-13447",
        "django__django-13710",
        "django__django-14752",
        "django__django-16139",
        "django__django-11848",
        "django__django-12184",
        "django__django-15498",
        "django__django-12125",
        "django__django-12708",
        "django__django-14580",
        "django__django-11583",
        "django__django-14382",
        "django__django-15851",
        "django__django-15819",
        "django__django-12700",
        "django__django-13551"
      ]
    },
    {
      "name": "HTTP Utilities and URL Resolver Fixes",
      "description": "Audit and patch Django\u2019s HTTP utilities and URL resolver: implement RFC7231 two-digit year parsing in parse_http_date, fix optional named group handling in URL resolving, and ensure empty If-Modified-Since headers are treated as modified.",
      "steps": [
        {
          "reasoning": "Locate the HTTP utilities implementation to audit parse_http_date.",
          "action": "find {repo_root}/django -path '*/utils/http.py'"
        },
        {
          "reasoning": "Open the file to inspect current logic and pinpoint the function to modify.",
          "action": "sed -n '1,220p' {repo_root}/django/django/utils/http.py | sed -n '/def parse_http_date/,/def/p'"
        },
        {
          "reasoning": "Identify existing tests referencing parse_http_date to understand expectations.",
          "action": "grep -R \"parse_http_date\" {repo_root}/django/tests -n --include='*.py'"
        },
        {
          "reasoning": "Open the relevant test module to see concrete cases and edge conditions.",
          "action": "sed -n '1,220p' {repo_root}/django/tests/utils_tests/test_http.py"
        },
        {
          "reasoning": "Create a boundary harness to compute expected years based on the current UTC year.",
          "action": "cat > {workspace}/test_rfc850_boundary.py << 'EOF'\nimport sys, datetime\nsys.path.insert(0, '{repo_root}/django')\nfrom django.utils.http import parse_http_date\ncases = [\n    'Sunday, 06-Nov-70 08:49:37 GMT',\n    'Sunday, 06-Nov-85 08:49:37 GMT',\n    'Sunday, 06-Nov-00 08:49:37 GMT',\n]\nnow_year = datetime.datetime.utcnow().year\nfor s in cases:\n    ts = parse_http_date(s)\n    y = datetime.datetime.utcfromtimestamp(ts).year\n    print(s, '->', y, '(current:', now_year, ')')\nEOF"
        },
        {
          "reasoning": "Execute the harness to observe current behavior before implementing a fix.",
          "action": "python {workspace}/test_rfc850_boundary.py"
        },
        {
          "reasoning": "Modify two-digit year handling to be relative to the current year per RFC 7231.",
          "action": "applypatch << 'PATCH'\n*** Begin Patch\n*** Update File: {repo_root}/django/django/utils/http.py\n@@\n-    if year < 100:\n-        if year < 70:\n-            year += 2000\n-        else:\n-            year += 1900\n+    # RFC 7231: interpret RFC850 two-digit years relative to the current year.\n+    if year < 100:\n+        current_year = datetime.datetime.utcnow().year\n+        year = year + (1900 if 2000 + year > current_year + 50 else 2000)\n*** End Patch\nPATCH"
        },
        {
          "reasoning": "Re-run the boundary harness to confirm the corrected mapping at the 50-year boundary.",
          "action": "python {workspace}/test_rfc850_boundary.py"
        },
        {
          "reasoning": "Run Django\u2019s utils HTTP tests to ensure no regressions.",
          "action": "cd {repo_root}/django && python tests/runtests.py utils_tests.test_http --verbosity=1"
        },
        {
          "reasoning": "Construct an in-memory URLConf to isolate and reproduce optional named groups behavior without a full project.",
          "action": "cat > {workspace}/test_optional_param.py << 'EOF'\nimport sys, types\nsys.path.insert(0, '{repo_root}/django')\nfrom django.conf import settings\nsettings.configure(DEBUG=True, ROOT_URLCONF='tmp_urls', ALLOWED_HOSTS=['*'], INSTALLED_APPS=['django.contrib.contenttypes'])\nimport django; django.setup()\nfrom django.urls import re_path, resolve\nmod = types.ModuleType('tmp_urls')\n\ndef modules(request, format='html'):\n    return f'format={format}'\nmod.modules = modules\nmod.urlpatterns = [re_path(r'^module/(?P<format>(html|json|xml))?/?$', modules)]\nsys.modules['tmp_urls'] = mod\nprint('Resolving /module/ ...')\nprint(resolve('/module/').args, resolve('/module/').kwargs)\nprint('Resolving /module/html/ ...')\nprint(resolve('/module/html/').args, resolve('/module/html/').kwargs)\nEOF\npython {workspace}/test_optional_param.py"
        },
        {
          "reasoning": "Audit resolver code to see how args and kwargs are derived from regex matches.",
          "action": "sed -n '140,180p' {repo_root}/django/django/urls/resolvers.py"
        },
        {
          "reasoning": "Exclude None from positional args derived from optional groups while keeping named-group precedence.",
          "action": "applypatch << 'PATCH'\n*** Begin Patch\n*** Update File: {repo_root}/django/django/urls/resolvers.py\n@@\n-            args = () if kwargs else match.groups()\n+            args = () if kwargs else tuple(g for g in match.groups() if g is not None)\n*** End Patch\nPATCH"
        },
        {
          "reasoning": "Re-run the reproducer to confirm the error is resolved and arguments are correct.",
          "action": "python {workspace}/test_optional_param.py"
        },
        {
          "reasoning": "Execute URL-related test suites to ensure no regressions.",
          "action": "cd {repo_root}/django && python tests/runtests.py urlpatterns_reverse --parallel=1 -v 1"
        },
        {
          "reasoning": "Create a minimal script to invoke was_modified_since and a request with an empty If-Modified-Since header to reproduce the crash.",
          "action": "cat > {workspace}/test_empty_ims.py << 'EOF'\nimport sys, os, datetime\nsys.path.insert(0, '{repo_root}/django')\nfrom django.views.static import was_modified_since\nfrom django.test.client import RequestFactory\nfrom django.http import HttpResponse\n\n# Direct call\nprint('was_modified_since(\"\") ->', was_modified_since(None, None, ''))\n\n# Serve-like check via RequestFactory\nrf = RequestFactory()\nreq = rf.get('/static/file.txt', HTTP_IF_MODIFIED_SINCE='')\nprint('Empty header request built OK')\nEOF\npython {workspace}/test_empty_ims.py"
        },
        {
          "reasoning": "Inspect exception handling around regex matches and date parsing to find missing cases.",
          "action": "sed -n '114,145p' {repo_root}/django/django/views/static.py"
        },
        {
          "reasoning": "Include TypeError in the exception clause to handle missing regex matches safely.",
          "action": "applypatch << 'PATCH'\n*** Begin Patch\n*** Update File: {repo_root}/django/django/views/static.py\n@@\n-    except (AttributeError, ValueError, OverflowError):\n+    except (AttributeError, TypeError, ValueError, OverflowError):\n         return True\n*** End Patch\nPATCH"
        },
        {
          "reasoning": "Re-run the script to verify empty headers no longer crash and are treated as modified.",
          "action": "python {workspace}/test_empty_ims.py"
        },
        {
          "reasoning": "Run related static serving tests to confirm no regressions.",
          "action": "cd {repo_root}/django && python tests/runtests.py view_tests.tests.test_static staticfiles_tests --verbosity=1"
        }
      ],
      "source_clusters": [
        "HTTP and URL Handling"
      ],
      "source_trajectories": [
        "django__django-11848",
        "django__django-15498",
        "django__django-12184"
      ]
    },
    {
      "name": "Migration Serialization and Writer Audit (Nested Classes/Enums and models.Model Imports)",
      "description": "Inspect and reproduce migration serialization issues for nested classes/enums, ensure proper handling of __qualname__, and fix serializer output so models.Model bases request the correct import. Validate with migration writer/operations/autodetector tests.",
      "steps": [
        {
          "reasoning": "Identify where Django serializes values and composes migration files to determine fix locations.",
          "action": "cd {repo_root} && find django/db/migrations -type f -name \"*.py\""
        },
        {
          "reasoning": "Inspect serializer logic for class path and import handling.",
          "action": "sed -n '1,220p' django/db/migrations/serializer.py | sed -n '220,440p'"
        },
        {
          "reasoning": "Review how the writer merges imports and formats migration files.",
          "action": "sed -n '1,220p' django/db/migrations/writer.py"
        },
        {
          "reasoning": "Search for special-cased references that might omit required imports.",
          "action": "grep -n \"models\\.Model\" django/db/migrations/serializer.py"
        },
        {
          "reasoning": "Check use of __qualname__ vs __name__ for nested class handling.",
          "action": "grep -n \"__qualname__\\|__name__\" django/db/migrations/serializer.py"
        },
        {
          "reasoning": "Create a standalone reproducer to observe how nested classes and enums are serialized.",
          "action": "python - <<'PY'\nimport sys\nsys.path.insert(0, '{repo_root}')\nfrom django.db.migrations.serializer import serializer_factory\nfrom django.db import models\nimport enum\nclass Outer:\n    class Inner(models.CharField):\n        pass\nclass Thing(models.Model):\n    class State(enum.Enum):\n        ON = 'on'\n        OFF = 'off'\nfield = Outer.Inner(max_length=10)\nprint('TypeSerializer for Outer.Inner:', serializer_factory(Outer.Inner).serialize())\nprint('Deconstructable serializer for field:', serializer_factory(field).serialize())\nprint('TypeSerializer for Thing.State:', serializer_factory(Thing.State).serialize())\nPY"
        },
        {
          "reasoning": "Ensure serializer requests the 'models' import when emitting 'models.Model' in migration bases.",
          "action": "grep -n \"(models\\.Model, \\\"models\\.Model\\\"\" {repo_root}/django/db/migrations/serializer.py"
        },
        {
          "reasoning": "Update the tuple to include the required import so the writer merges it into the migration header.",
          "action": "echo \"Edit {repo_root}/django/db/migrations/serializer.py to include ['from django.db import models'] for the models.Model special case.\""
        },
        {
          "reasoning": "Quickly assert the serializer now returns the correct import set for models.Model.",
          "action": "python - <<'PY'\nimport sys\nsys.path.insert(0, '{repo_root}')\nfrom django.db.migrations.serializer import serializer_factory\nfrom django.db import models\ns, imports = serializer_factory(models.Model).serialize()\nprint('Serialized:', s)\nprint('Imports:', imports)\nassert 'from django.db import models' in imports\nPY"
        },
        {
          "reasoning": "Run migration-related tests to validate changes and avoid regressions.",
          "action": "cd {repo_root} && PYTHONPATH={repo_root} python tests/runtests.py migrations.test_writer migrations.test_operations migrations.test_autodetector --verbosity=0"
        }
      ],
      "source_clusters": [
        "Migrations and Schema Operations"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-14580"
      ]
    },
    {
      "name": "Reproduce and Validate Schema Constraint Conflict (index_together vs unique_together)",
      "description": "Use in-memory SQLite and schema_editor to demonstrate the ValueError when removing an index overlapping a unique constraint and re-run after applying a fix.",
      "steps": [
        {
          "reasoning": "Use an in-memory SQLite DB to quickly exercise schema_editor operations that trigger the conflict.",
          "action": "python - <<'PY'\nimport sys\nsys.path.insert(0, '{repo_root}')\nfrom django.conf import settings\nsettings.configure(INSTALLED_APPS=[], DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}})\nimport django; django.setup()\nfrom django.db import connection, models\nclass T(models.Model):\n    a = models.IntegerField()\n    b = models.IntegerField()\n    class Meta:\n        app_label = 'app'\n        unique_together = (('a','b'),)\n        index_together = (('a','b'),)\nwith connection.schema_editor() as editor:\n    editor.create_model(T)\ntry:\n    with connection.schema_editor() as editor:\n        editor.alter_index_together(T, {('a','b')}, set())\n    print('No error thrown (unexpected before fix).')\nexcept Exception as e:\n    print('Got exception (expected before fix):', type(e).__name__, e)\nPY"
        },
        {
          "reasoning": "Re-run the same script after implementing the fix to confirm the error is resolved and behavior is correct.",
          "action": "python - <<'PY'\n# Repeat the same script; expect no ValueError after fix and the index-only constraint to be removed correctly.\nPY"
        }
      ],
      "source_clusters": [
        "Migrations and Schema Operations"
      ],
      "source_trajectories": [
        "django__django-12708"
      ]
    },
    {
      "name": "Diagnose Embedded Null Byte Signatures and Validate Autoreloader Resilience",
      "description": "Locate suspect code paths, search for embedded null byte error signatures, inspect context, and mock Path.resolve to verify Django\u2019s autoreloader handles errors without crashing.",
      "steps": [
        {
          "reasoning": "Need to identify the exact file and function where the issue occurs to scope the fix.",
          "action": "find {repo_root}/django -type f -name \"{filename}\" | head -20"
        },
        {
          "reasoning": "Open the candidate file to read the implementation and find the failing function.",
          "action": "sed -n '{start_line},{end_line}p' {repo_root}/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Locate all occurrences of a known problematic call to determine where to add defensive handling.",
          "action": "grep -n \"{symbol_or_call}\" {repo_root}/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Inspect the code around the matched lines to assess existing exception handling and context.",
          "action": "sed -n '{context_start},{context_end}p' {repo_root}/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Search the repository for the exact error message to find related code and tests.",
          "action": "grep -rn \"ValueError.*embedded null byte\" {repo_root} --include=\"*.py\""
        },
        {
          "reasoning": "Broaden to related keywords to discover other potential crash sites.",
          "action": "grep -rn \"Path.resolve\\|embedded null byte\" {repo_root} --include=\"*.py\""
        },
        {
          "reasoning": "Inline Python with mocking avoids modifying files and validates autoreloader behavior quickly.",
          "action": "python - <<'PY'\nimport sys\nsys.path.insert(0, '{repo_root}')\nfrom unittest import mock\nfrom django.utils import autoreload\nfrom pathlib import Path\n\n# Mock Path.resolve to raise ValueError\nwith mock.patch('django.utils.autoreload.Path') as MockPath:\n    instance = MockPath.return_value\n    instance.resolve.side_effect = ValueError('embedded null byte')\n    try:\n        files = autoreload.iter_modules_and_files(tuple(), frozenset())\n        print('Success: no crash, files:', files)\n    except Exception as e:\n        print('Failure:', e)\nPY"
        }
      ],
      "source_clusters": [
        "Developer Tooling (CLI, Devserver, Introspection)"
      ],
      "source_trajectories": [
        "django__django-11583",
        "django__django-14382",
        "django__django-15819"
      ]
    },
    {
      "name": "Diagnose and Patch startapp Trailing Slash Validation",
      "description": "Reproduce basename behavior with trailing separators, demonstrate startapp validation differences, apply a minimal patch to strip trailing separators before basename, and verify the fix.",
      "steps": [
        {
          "reasoning": "Ensure the local repository is on PYTHONPATH so that the django module resolves to the repo code.",
          "action": "export PYTHONPATH=\"{repo_root}:${PYTHONPATH}\""
        },
        {
          "reasoning": "Show how basename behaves differently with trailing path separators.",
          "action": "python -c \"import os; print(repr(os.path.basename('dir/'))); print(repr(os.path.basename('dir'.rstrip(os.sep))))\""
        },
        {
          "reasoning": "Run startapp with and without trailing slashes to observe the validation error.",
          "action": "python -m django startapp {app_name} {target_dir_with_slash}/ || true && python -m django startapp {app_name} {target_dir_no_slash}"
        },
        {
          "reasoning": "Automate the minimal change that strips trailing separators before basename to avoid empty identifier errors.",
          "action": "sed -i \"s/self.validate_name(os.path.basename(target), 'directory')/self.validate_name(os.path.basename(target.rstrip(os.sep)), 'directory')/\" {repo_root}/django/core/management/templates.py"
        },
        {
          "reasoning": "Run a quick reproduction to confirm the fix prevents the prior error.",
          "action": "export PYTHONPATH=\"{repo_root}:${PYTHONPATH}\" && python -m django startapp {app_name} {target_dir_with_slash}/"
        }
      ],
      "source_clusters": [
        "Developer Tooling (CLI, Devserver, Introspection)"
      ],
      "source_trajectories": [
        "django__django-14382"
      ]
    },
    {
      "name": "Verify PostgreSQL dbshell Argument Order",
      "description": "Validate that user-supplied parameters are placed before the database name in constructed psql args and ensure behavior via dedicated tests.",
      "steps": [
        {
          "reasoning": "Use a quick inline Python snippet to import the client and print the constructed args without running tests.",
          "action": "python -c \"import sys; sys.path.insert(0, '{repo_root}'); from django.db.backends.postgresql.client import DatabaseClient; args, _ = DatabaseClient.settings_to_cmd_args_env({'NAME': 'dbname'}, ['--help']); print(args)\""
        },
        {
          "reasoning": "Assert that parameters appear before the dbname to align with psql\u2019s documented syntax.",
          "action": "python -c \"import sys; sys.path.insert(0, '{repo_root}'); from django.db.backends.postgresql.client import DatabaseClient; args, _ = DatabaseClient.settings_to_cmd_args_env({'NAME': 'dbname'}, ['-c','SELECT 1']); print(args); assert args.index('dbname') > args.index('-c')\""
        },
        {
          "reasoning": "Run the dedicated dbshell PostgreSQL tests to validate behavior across scenarios.",
          "action": "cd {repo_root} && python tests/runtests.py dbshell.test_postgresql --verbosity=2"
        }
      ],
      "source_clusters": [
        "Developer Tooling (CLI, Devserver, Introspection)"
      ],
      "source_trajectories": [
        "django__django-15851"
      ]
    },
    {
      "name": "Generate and Inspect Models via inspectdb in a Temporary SQLite DB",
      "description": "Create a minimal schema with duplicate foreign keys, run inspectdb, and inspect the generated model code for related_name or duplicate reverse accessors.",
      "steps": [
        {
          "reasoning": "Use an inline Python script to create tables and run inspectdb without writing files.",
          "action": "python - <<'PY'\nimport os, sys\nsys.path.insert(0, '{repo_root}')\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\nimport django\nfrom django.core.management import call_command\nfrom django.db import connection\nfrom io import StringIO\n\ndjango.setup()\nwith connection.cursor() as c:\n    c.execute('CREATE TABLE IF NOT EXISTS test_category(id integer PRIMARY KEY);')\n    c.execute('CREATE TABLE IF NOT EXISTS test_product(id integer PRIMARY KEY, main_category_id integer REFERENCES test_category(id), sub_category_id integer REFERENCES test_category(id));')\nout = StringIO()\ncall_command('inspectdb', 'test_category', 'test_product', stdout=out)\nprint(out.getvalue())\nPY"
        },
        {
          "reasoning": "Search the generated output for related_name occurrences or duplicated reverse accessors.",
          "action": "python - <<'PY'\nfrom io import StringIO\nimport os, sys\nsys.path.insert(0, '{repo_root}')\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\nimport django\nfrom django.core.management import call_command\n\ndjango.setup()\nout = StringIO()\ncall_command('inspectdb', 'test_product', stdout=out)\ns = out.getvalue()\nprint('Contains related_name:', 'related_name' in s)\nprint(s)\nPY"
        }
      ],
      "source_clusters": [
        "Developer Tooling (CLI, Devserver, Introspection)"
      ],
      "source_trajectories": [
        "django__django-15819"
      ]
    },
    {
      "name": "Locate and Patch Django Security/Authentication Code",
      "description": "Find and inspect target security/auth symbols, apply a minimal, reviewable patch, and verify changes before testing.",
      "steps": [
        {
          "reasoning": "Need to quickly find where a target symbol (class/function) is implemented to inspect and modify behavior.",
          "action": "cd {repo_root} && grep -R --line-number \"{target_symbol}\" django | head -20"
        },
        {
          "reasoning": "After locating a candidate file, inspect the surrounding lines to understand the implementation and potential patch points.",
          "action": "sed -n '{start_line},{end_line}p' {file_path}"
        },
        {
          "reasoning": "Identify existing tests referencing this symbol to understand coverage and where to add new tests if needed.",
          "action": "find {repo_root}/tests -name \"*.py\" -type f | xargs grep -l \"{target_symbol}\" | sort | head -20"
        },
        {
          "reasoning": "Apply a minimal, reviewable patch to adjust the implementation while keeping changes focused.",
          "action": "git -C {repo_root} apply - <<'PATCH'\n--- a/{file_path}\n+++ b/{file_path}\n@@\n{patch_hunk}\nPATCH"
        },
        {
          "reasoning": "Verify that only the intended changes were made before running tests.",
          "action": "git -C {repo_root} diff -- {file_path}"
        }
      ],
      "source_clusters": [
        "Security and Authentication"
      ],
      "source_trajectories": [
        "django__django-12700",
        "django__django-13551"
      ]
    },
    {
      "name": "Transactional Test DB Deserialization: Locate, Patch, and Validate",
      "description": "Wrap test database deserialization in a single transaction to avoid foreign key integrity issues, trace serialized_rollback call paths, reference loaddata\u2019s transaction pattern, and validate via targeted test suites.",
      "steps": [
        {
          "reasoning": "Need to identify where the test database state is deserialized to implement a transactional fix.",
          "action": "cd {repo_root} && grep -r \"deserialize_db_from_string\" django --include=\"*.py\""
        },
        {
          "reasoning": "Open the backend creation module to inspect and edit the deserialization method.",
          "action": "$EDITOR {repo_root}/django/db/backends/base/creation.py"
        },
        {
          "reasoning": "Ensure transaction.atomic can be used in this module.",
          "action": "Add \"from django.db import transaction\" near the top-level imports in creation.py"
        },
        {
          "reasoning": "Wrap the deserialization loop so inserts happen within a single transaction, deferring FK checks until commit.",
          "action": "Change the body of deserialize_db_from_string to:\nwith transaction.atomic(using=self.connection.alias):\n    for obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n        obj.save()"
        },
        {
          "reasoning": "Verify the edit is correct and limited to the intended scope.",
          "action": "git -C {repo_root} diff django/db/backends/base/creation.py"
        },
        {
          "reasoning": "Identify tests that configure or assert behavior for serialized_rollback.",
          "action": "cd {repo_root} && grep -r \"serialized_rollback\" tests --include=\"*.py\""
        },
        {
          "reasoning": "Locate the code that triggers deserialization during test setup/teardown.",
          "action": "cd {repo_root} && grep -n \"deserialize_db_from_string\" django/test/testcases.py"
        },
        {
          "reasoning": "Inspect the surrounding code to understand when and how deserialization is invoked.",
          "action": "$EDITOR {repo_root}/django/test/testcases.py"
        },
        {
          "reasoning": "Use loaddata as a reference to ensure fixture-like deserialization follows best practices for transaction handling.",
          "action": "cd {repo_root} && $EDITOR django/core/management/commands/loaddata.py"
        },
        {
          "reasoning": "Verify that loaddata wraps deserialization in transaction.atomic and use that pattern as a reference.",
          "action": "cd {repo_root} && grep -n \"transaction.atomic\" django/core/management/commands/loaddata.py"
        },
        {
          "reasoning": "Ensure the test runner uses local code changes.",
          "action": "cd {repo_root} && pip install -e ."
        },
        {
          "reasoning": "Run tests that directly exercise TransactionTestCase and serialized_rollback behavior.",
          "action": "cd {repo_root} && python tests/runtests.py test_utils.test_transactiontestcase --verbosity=2"
        },
        {
          "reasoning": "Validate behavior around migrations and data persistence after changes to transactional handling.",
          "action": "cd {repo_root} && python tests/runtests.py migration_test_data_persistence --verbosity=2"
        },
        {
          "reasoning": "Sanity-check fixtures and test runner suites for broader regressions.",
          "action": "cd {repo_root} && python tests/runtests.py fixtures fixtures_regress test_runner --verbosity=1"
        },
        {
          "reasoning": "Use serial execution for deterministic debugging when needed.",
          "action": "cd {repo_root} && python tests/runtests.py test_utils.test_transactiontestcase migration_test_data_persistence --verbosity=2 --parallel=1"
        }
      ],
      "source_clusters": [
        "Testing Framework and Transactions"
      ],
      "source_trajectories": [
        "django__django-12453"
      ]
    },
    {
      "name": "Focused Test Authoring and Targeted Execution for Fast Feedback",
      "description": "Identify or add focused tests, then run only the relevant subset using pytest or Django\u2019s in-tree test runner with optional warnings-as-errors for rapid iteration.",
      "steps": [
        {
          "reasoning": "Find the most relevant test module to host or target specific tests following existing conventions.",
          "action": "cd /workspace/django && find tests -name \"{module_glob}\" -type f"
        },
        {
          "reasoning": "Add a new test case or method that captures the broken scenario and validates the corrected behavior.",
          "action": "Edit /workspace/django/tests/{relative_test_path}.py to insert test_{scenario_name}() or a new TestCase class with focused assertions"
        },
        {
          "reasoning": "Directly target a single test file for faster feedback using pytest.",
          "action": "cd {repo_root} && python -m pytest tests/test_utils/test_transactiontestcase.py -v"
        },
        {
          "reasoning": "Execute a specific Django test module via the in-tree runner to avoid the full suite.",
          "action": "cd /workspace/django && python tests/runtests.py {module_path} --verbosity=2"
        },
        {
          "reasoning": "Run a specific test class or method to focus on an exact failing scenario.",
          "action": "cd /workspace/django && python tests/runtests.py {module_path}.{TestClassName}[.{test_method_name}] --verbosity=2"
        },
        {
          "reasoning": "Enable warnings-as-errors when needed to surface deprecations or subtle issues.",
          "action": "cd {repo_root} && python -Wa tests/runtests.py test_utils.test_transactiontestcase.TestSerializedRollbackInhibitsPostMigrate --verbosity=2"
        }
      ],
      "source_clusters": [
        "Testing Framework and Transactions",
        "Core Utilities, System Checks, and Supporting Frameworks"
      ],
      "source_trajectories": [
        "django__django-12453",
        "django__django-12286",
        "django__django-14238",
        "django__django-14787",
        "django__django-15347",
        "django__django-15789",
        "django__django-15790"
      ]
    },
    {
      "name": "Environment Setup and Minimal Reproduction (Editable install, PYTHONPATH, inline scripts)",
      "description": "Make local Django sources importable, then validate behaviors using minimal reproducible snippets, one-liners, or standalone scripts.",
      "steps": [
        {
          "reasoning": "Ensure local changes are importable by Python and external scripts.",
          "action": "cd /workspace/django && python -m pip install -e ."
        },
        {
          "reasoning": "Confirm Python resolves Django to the local editable installation.",
          "action": "python -c \"import django; print(django.__file__)\""
        },
        {
          "reasoning": "Use an inline script with PYTHONPATH to configure settings and bootstrap Django for quick repro.",
          "action": "cd /workspace/django && PYTHONPATH=/workspace/django python -c \"from django.conf import settings; settings.configure(DEBUG=True, SECRET_KEY='test-key', USE_TZ=True, INSTALLED_APPS={installed_apps}); import django; django.setup(); {repro_code}\""
        },
        {
          "reasoning": "Create a small standalone script for clarity and repeated use.",
          "action": "Create /workspace/{script_name}.py with settings.configure, django.setup(), and minimal {repro_code}; then run: cd /workspace/django && PYTHONPATH=/workspace/django python /workspace/{script_name}.py"
        },
        {
          "reasoning": "Quickly validate messages encode/decode behavior with an empty extra_tags using a one-liner.",
          "action": "PYTHONPATH=/workspace/django python -c \"from django.conf import settings; settings.configure(DEBUG=True, SECRET_KEY='test', INSTALLED_APPS=['django.contrib.messages']); import django; django.setup(); from django.contrib.messages.storage.base import Message; from django.contrib.messages.storage.cookie import MessageEncoder, MessageDecoder; m=Message(10,'msg',extra_tags=''); print(MessageDecoder().decode(MessageEncoder().encode(m)).extra_tags=='')\""
        },
        {
          "reasoning": "Check None and non-empty values to ensure round-trip correctness across cases.",
          "action": "PYTHONPATH=/workspace/django python -c \"from django.conf import settings; settings.configure(DEBUG=True, SECRET_KEY='test', INSTALLED_APPS=['django.contrib.messages']); import django; django.setup(); from django.contrib.messages.storage.base import Message; from django.contrib.messages.storage.cookie import MessageEncoder, MessageDecoder; print(MessageDecoder().decode(MessageEncoder().encode(Message(10,'msg',extra_tags=None))).extra_tags is None); print(MessageDecoder().decode(MessageEncoder().encode(Message(10,'msg',extra_tags='important'))).extra_tags=='important')\""
        },
        {
          "reasoning": "If environment issues arise, bootstrap Django inline to ensure the setup is correct.",
          "action": "cd /workspace/django/tests && python -c \"import django; django.setup(); from django.contrib.syndication import views; class F(views.Feed): pass; print('Django setup OK')\""
        }
      ],
      "source_clusters": [
        "Core Utilities, System Checks, and Supporting Frameworks",
        "Miscellaneous and Less Common Frameworks"
      ],
      "source_trajectories": [
        "django__django-12286",
        "django__django-14238",
        "django__django-14787",
        "django__django-15347",
        "django__django-15789",
        "django__django-15790",
        "django__django-13230"
      ]
    },
    {
      "name": "Locate and Implement Targeted Code Changes, Verify via Diff, Tests, and Reproducer",
      "description": "Find the relevant Django source code, apply focused edits, inspect diffs, and validate via targeted tests and minimal reproductions (e.g., utility filters and syndication feeds).",
      "steps": [
        {
          "reasoning": "Quickly identify where a function, check, or symbol is implemented to begin diagnosis.",
          "action": "cd /workspace/django && find . -type f -name \"*.py\" -exec grep -n \"{symbol_name}\" {} + | head -20"
        },
        {
          "reasoning": "Open the target file to inspect surrounding logic and confirm the correct place for edits.",
          "action": "view /workspace/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Apply a minimal, focused edit aligned with intended behavior.",
          "action": "Edit /workspace/django/{relative_path_to_file} to apply the patch (e.g., adjust conditions, add methods, or change parameters)"
        },
        {
          "reasoning": "Verify precisely what changed and ensure no unintended edits were introduced.",
          "action": "cd /workspace/django && git diff {relative_path_to_file}"
        },
        {
          "reasoning": "Enable custom JSON encoding while retaining default behavior.",
          "action": "Edit /workspace/django/django/utils/html.py: change def json_script(value, element_id=None) to def json_script(value, element_id=None, encoder=None); use encoder or DjangoJSONEncoder when calling json.dumps"
        },
        {
          "reasoning": "Propagate the new parameter through the template filter wrapper.",
          "action": "Edit /workspace/django/django/template/defaultfilters.py: change def json_script(value, element_id=None) to def json_script(value, element_id=None, encoder=None); return _json_script(value, element_id, encoder)"
        },
        {
          "reasoning": "Run targeted tests to confirm both default and custom encoder cases work.",
          "action": "cd /workspace/django && python tests/runtests.py utils_tests.test_html template_tests.filter_tests.test_json_script --verbosity=2"
        },
        {
          "reasoning": "Identify relevant modules and files for syndication and feed generation.",
          "action": "find /workspace/django -type f -name \"*.py\" | grep -E \"(syndication|feed)\""
        },
        {
          "reasoning": "Confirm the syndication app layout.",
          "action": "ls -la /workspace/django/django/contrib/syndication"
        },
        {
          "reasoning": "Inspect the syndication views to see how items are constructed.",
          "action": "sed -n '1,240p' /workspace/django/django/contrib/syndication/views.py"
        },
        {
          "reasoning": "Verify feed generator support and parameter names.",
          "action": "sed -n '1,300p' /workspace/django/django/utils/feedgenerator.py"
        },
        {
          "reasoning": "Confirm the target field exists in the generator.",
          "action": "grep -n \"comments\" /workspace/django/django/utils/feedgenerator.py"
        },
        {
          "reasoning": "Find where items are added to the feed.",
          "action": "grep -n \"add_item\" /workspace/django/django/contrib/syndication/views.py"
        },
        {
          "reasoning": "Implement pass-through for the missing field following existing parameter patterns.",
          "action": "Open /workspace/django/django/contrib/syndication/views.py in your editor and add within feed.add_item(...): comments=self._get_dynamic_attr('item_comments', item)"
        },
        {
          "reasoning": "Ensure parameter style is consistent with adjacent fields.",
          "action": "Review nearby parameters (e.g., categories=self._get_dynamic_attr('item_categories', item)) in views.py and mirror the same structure"
        },
        {
          "reasoning": "Examine existing syndication tests for coverage and patterns.",
          "action": "sed -n '1,240p' /workspace/django/tests/syndication_tests/tests.py"
        },
        {
          "reasoning": "Check if the target field is already covered by tests.",
          "action": "grep -rn \"comments\" /workspace/django/tests/syndication_tests/"
        },
        {
          "reasoning": "Run tests against local code changes using editable install.",
          "action": "cd /workspace/django/tests && python -m pip install -e .."
        },
        {
          "reasoning": "Validate changes quickly by running the syndication subset.",
          "action": "cd /workspace/django/tests && python runtests.py syndication_tests -v 2"
        },
        {
          "reasoning": "Focus on a specific RSS test for faster iteration and output inspection.",
          "action": "cd /workspace/django/tests && python runtests.py syndication_tests.tests.SyndicationFeedTest.test_rss2_feed -v 2"
        },
        {
          "reasoning": "Create an end-to-end reproducer to confirm field propagation outside the full test harness.",
          "action": "Create /workspace/test_item_comments.py that defines a Feed subclass with item_comments() returning a URL, then run: cd /workspace/django && python /workspace/test_item_comments.py"
        }
      ],
      "source_clusters": [
        "Core Utilities, System Checks, and Supporting Frameworks",
        "Miscellaneous and Less Common Frameworks"
      ],
      "source_trajectories": [
        "django__django-12286",
        "django__django-14238",
        "django__django-14787",
        "django__django-15347",
        "django__django-15400",
        "django__django-15789",
        "django__django-15790",
        "django__django-13230"
      ]
    },
    {
      "name": "Align Translation System Check with Runtime Fallback Logic",
      "description": "Update the i18n system check to mirror how runtime resolves language variants, then validate with the translation checks tests.",
      "steps": [
        {
          "reasoning": "Inspect runtime language resolution to inform the check\u2019s behavior.",
          "action": "cd /workspace/django && grep -n \"get_supported_language_variant\\|generic_lang_code\" django/utils/translation/trans_real.py"
        },
        {
          "reasoning": "Modify the system check to accept base language and prefix-based fallbacks before raising errors.",
          "action": "Edit /workspace/django/django/core/checks/translation.py to add base-code and prefix-based acceptance before raising the error"
        },
        {
          "reasoning": "Run translation check tests to ensure the updated logic matches runtime behavior.",
          "action": "cd /workspace/django && python tests/runtests.py check_framework.test_translation --verbosity=2"
        }
      ],
      "source_clusters": [
        "Core Utilities, System Checks, and Supporting Frameworks"
      ],
      "source_trajectories": [
        "django__django-12286"
      ]
    }
  ]
}