{
  "type1_workflows": [
    {
      "name": "Hardening Django's Autoreloader Against Filesystem Anomalies",
      "description": "Prevent crashes in the development autoreloader by auditing path resolution and adding defensive handling.",
      "steps": [
        "Step 1: Review the error stack trace to identify the failing function and line number in the autoreloader",
        "Step 2: Locate django/utils/autoreload.py and examine functions that resolve file paths and modules",
        "Step 3: Search for calls to pathlib.Path.resolve and other path normalization points to find crash sites",
        "Step 4: Design a minimal defensive fix that catches unexpected exceptions (e.g., ValueError for embedded null bytes) without disabling file watching",
        "Step 5: Apply consistent exception handling across all relevant call sites (e.g., iter_modules_and_files and sys_path_directories)",
        "Step 6: Add a regression test that mocks the failing call (e.g., Path.resolve) to raise the observed exception and assert the autoreloader continues functioning",
        "Step 7: Run the autoreloader tests and any related developer tooling tests to confirm no regressions"
      ],
      "source_trajectories": [
        "django__django-11583"
      ]
    },
    {
      "name": "Fixing Argument Handling and Path Normalization in Management Commands",
      "description": "Correct ordering and normalization issues in management commands to match external tools and Python semantics.",
      "steps": [
        "Step 1: Reproduce the problematic CLI behavior with minimal scripts or direct command invocation to observe the exact failure",
        "Step 2: Consult external tool documentation (e.g., psql\u2019s expected argument syntax) or standard library behavior (e.g., os.path.basename) to understand the root cause",
        "Step 3: Locate the command implementation in django/core/management or backend client modules and inspect how arguments or paths are constructed",
        "Step 4: Identify the minimal change needed (e.g., placing user parameters before dbname; stripping trailing path separators before basename)",
        "Step 5: Implement the fix with a small, localized change to reduce risk",
        "Step 6: Add a regression test in the appropriate suite (e.g., tests/admin_scripts/ for startapp, tests/dbshell/ for dbshell) covering the exact failure scenario",
        "Step 7: Run targeted tests and then broader suites to ensure the change doesn\u2019t cause regressions elsewhere"
      ],
      "source_trajectories": [
        "django__django-14382",
        "django__django-15851"
      ]
    },
    {
      "name": "Improving inspectdb Relation Generation to Avoid Reverse Accessor Clashes",
      "description": "Ensure models generated by inspectdb produce unique reverse accessors by adding related_name for duplicate relations.",
      "steps": [
        "Step 1: Build a minimal database schema with multiple ForeignKey fields pointing to the same related model",
        "Step 2: Run inspectdb and review the generated model code to verify how related fields are emitted",
        "Step 3: Locate inspectdb\u2019s relation generation logic and determine where extra field parameters are built",
        "Step 4: Track repeated references to the same related model within a single model and generate a deterministic related_name for subsequent occurrences",
        "Step 5: Regenerate models and run Django\u2019s model checks to ensure fields.E304 reverse accessor clashes are resolved",
        "Step 6: Add a regression test in tests/inspectdb to cover multiple FKs to the same model and assert the presence of unique related_name values",
        "Step 7: Run inspectdb tests, and optionally cross-backend tests, to confirm correct behavior"
      ],
      "source_trajectories": [
        "django__django-15819"
      ]
    },
    {
      "name": "Running Django\u2019s In-Repo Test Suite Effectively",
      "description": "Set up and execute Django\u2019s tests using the project\u2019s preferred harness for reliable results.",
      "steps": [
        "Step 1: Install the repository in editable mode to ensure imports and entry points work as expected",
        "Step 2: Prefer Django\u2019s tests/runtests.py over external runners for consistent behavior within the repo",
        "Step 3: Run targeted modules, classes, or methods with increased verbosity to get focused feedback",
        "Step 4: Set DJANGO_SETTINGS_MODULE for tests that require a specific settings module",
        "Step 5: Use parallelization flags judiciously and iterate until a passing baseline is established",
        "Step 6: After applying fixes, run both targeted and broader suites to confirm there are no regressions"
      ],
      "source_trajectories": [
        "django__django-11583",
        "django__django-14382",
        "django__django-15851",
        "django__django-15819"
      ]
    },
    {
      "name": "Designing Regression Tests for Developer Tooling Changes",
      "description": "Create robust, minimal tests that exercise edge cases in Django\u2019s tooling and management commands.",
      "steps": [
        "Step 1: Identify the minimal failing condition and reproduce it with a small script or mocked scenario",
        "Step 2: Choose the appropriate existing test suite and pattern (e.g., admin_scripts for CLI, inspectdb tests for introspection)",
        "Step 3: Write assertions that verify the absence of crashes and the exact expected outputs or side effects",
        "Step 4: Use unique names and isolated directories to avoid cross-test interference and PYTHONPATH conflicts",
        "Step 5: Run only the affected tests to iterate quickly, then execute the broader suite to ensure integration stability",
        "Step 6: Document the test rationale and link it to the bug report or change for future maintainers"
      ],
      "source_trajectories": [
        "django__django-11583",
        "django__django-14382",
        "django__django-15851",
        "django__django-15819"
      ]
    }
  ],
  "type2_workflows": [
    {
      "name": "Locate and Inspect a Suspect Code Path",
      "description": "Find the implementation file and inspect lines around a suspected call that is causing failures.",
      "steps": [
        {
          "reasoning": "Need to identify the exact file and function where the issue occurs to scope the fix.",
          "action": "find {repo_root}/django -type f -name \"{filename}\" | head -20"
        },
        {
          "reasoning": "Open the candidate file to read the implementation and find the failing function.",
          "action": "sed -n '{start_line},{end_line}p' {repo_root}/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Locate all occurrences of a known problematic call to determine where to add defensive handling.",
          "action": "grep -n \"{symbol_or_call}\" {repo_root}/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Inspect the code around the matched lines to assess existing exception handling and context.",
          "action": "sed -n '{context_start},{context_end}p' {repo_root}/django/{relative_path_to_file}"
        }
      ],
      "source_trajectories": [
        "django__django-11583",
        "django__django-14382",
        "django__django-15819"
      ]
    },
    {
      "name": "Run Targeted Django Tests Using the In-Repo Runner",
      "description": "Execute specific tests or modules via Django\u2019s tests/runtests.py for focused validation.",
      "steps": [
        {
          "reasoning": "Editable install ensures the repository code is importable and test entry points are available.",
          "action": "cd {repo_root} && python -m pip install -e ."
        },
        {
          "reasoning": "Run a specific test module to get fast feedback on the fix.",
          "action": "cd {repo_root} && python tests/runtests.py {module_name} --verbosity=2"
        },
        {
          "reasoning": "Run a single test class or method to zoom in on a scenario.",
          "action": "cd {repo_root} && python tests/runtests.py {module_name}::{class_name}::{method_name} --verbosity=2"
        },
        {
          "reasoning": "Some tests require a particular settings module; set it explicitly.",
          "action": "cd {repo_root} && DJANGO_SETTINGS_MODULE={settings_module} python tests/runtests.py {module_name} --verbosity=2"
        }
      ],
      "source_trajectories": [
        "django__django-11583",
        "django__django-14382",
        "django__django-15851",
        "django__django-15819"
      ]
    },
    {
      "name": "Reproduce and Diagnose a Startapp Trailing Slash Issue",
      "description": "Demonstrate how trailing slashes affect os.path.basename and startapp command validation.",
      "steps": [
        {
          "reasoning": "Ensure the local repository is on PYTHONPATH so that the django module resolves to the repo code.",
          "action": "export PYTHONPATH=\"{repo_root}:${PYTHONPATH}\""
        },
        {
          "reasoning": "Show how basename behaves differently with trailing path separators.",
          "action": "python -c \"import os; print(repr(os.path.basename('dir/'))); print(repr(os.path.basename('dir'.rstrip(os.sep))))\""
        },
        {
          "reasoning": "Run startapp with and without trailing slashes to observe the validation error.",
          "action": "python -m django startapp {app_name} {target_dir_with_slash}/ || true && python -m django startapp {app_name} {target_dir_no_slash}"
        }
      ],
      "source_trajectories": [
        "django__django-14382"
      ]
    },
    {
      "name": "Verify PostgreSQL dbshell Argument Order",
      "description": "Check that user-supplied parameters are placed before the database name in constructed psql args.",
      "steps": [
        {
          "reasoning": "Use a quick inline Python snippet to import the client and print the constructed args without running tests.",
          "action": "python -c \"import sys; sys.path.insert(0, '{repo_root}'); from django.db.backends.postgresql.client import DatabaseClient; args, _ = DatabaseClient.settings_to_cmd_args_env({'NAME': 'dbname'}, ['--help']); print(args)\""
        },
        {
          "reasoning": "Assert that parameters appear before the dbname to align with psql\u2019s documented syntax.",
          "action": "python -c \"import sys; sys.path.insert(0, '{repo_root}'); from django.db.backends.postgresql.client import DatabaseClient; args, _ = DatabaseClient.settings_to_cmd_args_env({'NAME': 'dbname'}, ['-c','SELECT 1']); print(args); assert args.index('dbname') > args.index('-c')\""
        },
        {
          "reasoning": "Run the dedicated dbshell PostgreSQL tests to validate behavior across scenarios.",
          "action": "cd {repo_root} && python tests/runtests.py dbshell.test_postgresql --verbosity=2"
        }
      ],
      "source_trajectories": [
        "django__django-15851"
      ]
    },
    {
      "name": "Search for Known Error Signatures Across the Repo",
      "description": "Ensure the fix isn\u2019t duplicated and identify all locations that might need similar handling.",
      "steps": [
        {
          "reasoning": "Search the repository for the exact error message to find related code and tests.",
          "action": "grep -rn \"ValueError.*embedded null byte\" {repo_root} --include=\"*.py\""
        },
        {
          "reasoning": "Broaden to related keywords to discover other potential crash sites.",
          "action": "grep -rn \"Path.resolve\\|embedded null byte\" {repo_root} --include=\"*.py\""
        }
      ],
      "source_trajectories": [
        "django__django-11583"
      ]
    },
    {
      "name": "Generate and Inspect Models via inspectdb in a Temporary SQLite DB",
      "description": "Create a minimal schema with duplicate foreign keys, run inspectdb, and inspect the output.",
      "steps": [
        {
          "reasoning": "Use an inline Python script to create tables and run inspectdb without writing files.",
          "action": "python - <<'PY'\nimport os, sys\nsys.path.insert(0, '{repo_root}')\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\nimport django\nfrom django.core.management import call_command\nfrom django.db import connection\nfrom io import StringIO\n\ndjango.setup()\nwith connection.cursor() as c:\n    c.execute('CREATE TABLE IF NOT EXISTS test_category(id integer PRIMARY KEY);')\n    c.execute('CREATE TABLE IF NOT EXISTS test_product(id integer PRIMARY KEY, main_category_id integer REFERENCES test_category(id), sub_category_id integer REFERENCES test_category(id));')\nout = StringIO()\ncall_command('inspectdb', 'test_category', 'test_product', stdout=out)\nprint(out.getvalue())\nPY"
        },
        {
          "reasoning": "Search the generated output for related_name occurrences or duplicated reverse accessors.",
          "action": "python - <<'PY'\nfrom io import StringIO\nimport os, sys\nsys.path.insert(0, '{repo_root}')\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\nimport django\nfrom django.core.management import call_command\n\ndjango.setup()\nout = StringIO()\ncall_command('inspectdb', 'test_product', stdout=out)\ns = out.getvalue()\nprint('Contains related_name:', 'related_name' in s)\nprint(s)\nPY"
        }
      ],
      "source_trajectories": [
        "django__django-15819"
      ]
    },
    {
      "name": "Mock Path.resolve to Validate Autoreloader Resilience",
      "description": "Simulate a failing Path.resolve and assert the autoreloader handles the error gracefully.",
      "steps": [
        {
          "reasoning": "Inline Python with mocking avoids modifying files and validates behavior quickly.",
          "action": "python - <<'PY'\nimport sys\nsys.path.insert(0, '{repo_root}')\nfrom unittest import mock\nfrom django.utils import autoreload\nfrom pathlib import Path\n\n# Mock Path.resolve to raise ValueError\nwith mock.patch('django.utils.autoreload.Path') as MockPath:\n    instance = MockPath.return_value\n    instance.resolve.side_effect = ValueError('embedded null byte')\n    try:\n        files = autoreload.iter_modules_and_files(tuple(), frozenset())\n        print('Success: no crash, files:', files)\n    except Exception as e:\n        print('Failure:', e)\nPY"
        }
      ],
      "source_trajectories": [
        "django__django-11583"
      ]
    },
    {
      "name": "Patch a Minimal Line Change via sed and Verify Behavior",
      "description": "Apply a small in-place modification to a command and validate it through a reproduction.",
      "steps": [
        {
          "reasoning": "Automate the minimal change that strips trailing separators before basename to avoid empty identifier errors.",
          "action": "sed -i \"s/self.validate_name(os.path.basename(target), 'directory')/self.validate_name(os.path.basename(target.rstrip(os.sep)), 'directory')/\" {repo_root}/django/core/management/templates.py"
        },
        {
          "reasoning": "Run a quick reproduction to confirm the fix prevents the prior error.",
          "action": "export PYTHONPATH=\"{repo_root}:${PYTHONPATH}\" && python -m django startapp {app_name} {target_dir_with_slash}/"
        }
      ],
      "source_trajectories": [
        "django__django-14382"
      ]
    }
  ]
}