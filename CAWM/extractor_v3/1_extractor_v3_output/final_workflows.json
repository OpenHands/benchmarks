{
  "type1_workflows": [
    {
      "name": "Reproduce, Localize, and Validate Framework Bugs",
      "description": "From a high-level report, identify the responsible code paths, build a deterministic minimal reproduction, and validate assumptions before fixing.",
      "steps": [
        {
          "reasoning": "You need to know which module or subsystem is responsible before making changes.",
          "action": "Translate the symptom into likely subsystems and search the codebase (e.g., migrations serializer, ORM compiler, URL resolver, test framework, i18n checks) to pinpoint candidates."
        },
        {
          "reasoning": "Existing tests reveal intended behavior and regression boundaries.",
          "action": "Search for relevant tests to understand expectations and constraints; if none, plan to write or sketch targeted tests."
        },
        {
          "reasoning": "A minimal reproduction isolates the problem from broader environment noise.",
          "action": "Create a minimal script or definitions that trigger the issue (e.g., nested class serialization, inherited choices, optional named URL group, language variant check)."
        },
        {
          "reasoning": "Automating setup avoids environment-specific noise and errors.",
          "action": "Programmatically configure the framework (e.g., settings.configure) and include only the necessary settings/modules for the scenario."
        },
        {
          "reasoning": "Direct reproduction in the real environment may be unreliable or hard to set up.",
          "action": "Use mocks to force the error condition (e.g., Path.resolve raising ValueError, time-dependent boundaries) and assert expected behavior."
        },
        {
          "reasoning": "Capturing the exact failure signature ensures you\u2019re fixing the right issue.",
          "action": "Run the reproduction and verify outputs or error identifiers (e.g., generated migration strings, get_FOO_display() labels, resolved URL args, specific check IDs like translation.E004)."
        },
        {
          "reasoning": "Prevent regressions by codifying the reproduction.",
          "action": "Promote the minimal reproduction into the official test suite using the project\u2019s testing conventions."
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs",
        "Developer Tooling (Autoreload and Test Framework)",
        "Internationalization and Language Settings"
      ]
    },
    {
      "name": "Layered, Project-Aware Test Execution and Verification",
      "description": "Prepare the environment, run targeted tests efficiently, and verify changes from micro to system level with clear, reviewable outputs.",
      "steps": [
        {
          "reasoning": "Missing dependencies block tests and scripts.",
          "action": "Install all required runtime and test dependencies."
        },
        {
          "reasoning": "Editable installs and correct PYTHONPATH ensure your local changes are executed.",
          "action": "Install the project in editable mode or set PYTHONPATH to point to the working tree."
        },
        {
          "reasoning": "Project-provided runners often handle settings, database setup, and test discovery.",
          "action": "Use the project\u2019s test runner script or documented command to run tests."
        },
        {
          "reasoning": "Quicker feedback loops speed up development and reduce flakiness.",
          "action": "Run the smallest targeted test modules first, then expand to broader suites once local checks pass; disable parallelism or adjust runner flags when debugging intermittent or order-dependent failures."
        },
        {
          "reasoning": "Quick feedback loops help catch glaring issues early.",
          "action": "Start with lightweight, focused scripts or one-liners to validate the specific logic change."
        },
        {
          "reasoning": "Component-level tests catch nuanced interactions within the module.",
          "action": "Execute targeted test modules for the impacted area (e.g., utils_tests/test_http.py, urlpatterns_reverse, i18n checks, debug/exception filtering)."
        },
        {
          "reasoning": "System-level tests provide confidence no broader regressions were introduced.",
          "action": "Run broader related suites (e.g., handlers, requests, generic views, ORM) and review failures; iterate if discrepancies arise."
        },
        {
          "reasoning": "Visibility into changes helps reviewers and future maintainers.",
          "action": "Generate diffs of modified core and test files and provide succinct change notes."
        },
        {
          "reasoning": "Project hygiene avoids repository noise and confusion.",
          "action": "Remove temporary scripts and artifacts once the fix is validated."
        }
      ],
      "source_clusters": [
        "Developer Tooling (Autoreload and Test Framework)",
        "Request Routing and HTTP Parsing",
        "Internationalization and Language Settings",
        "Security and Error Reporting Sanitization"
      ]
    },
    {
      "name": "Standards-Compliant Parser Correction with Boundary-Focused Tests",
      "description": "Fix protocol parsing to comply with evolving RFC specifications, with dynamic, boundary-focused tests to ensure long-term correctness.",
      "steps": [
        {
          "reasoning": "Understanding the normative requirement prevents ad hoc fixes and ensures long-term correctness.",
          "action": "Identify and read the relevant RFC sections describing the expected behavior, focusing on edge-case rules (e.g., RFC 7231 two-digit year interpretation)."
        },
        {
          "reasoning": "Localizing the implementation avoids broad, risky changes and speeds iteration.",
          "action": "Locate the parsing function in the codebase and inspect its current logic, especially hardcoded assumptions versus dynamic rules."
        },
        {
          "reasoning": "A correct fix must reflect the spec\u2019s conditional logic rather than fixed ranges.",
          "action": "Design a replacement algorithm that uses dynamic context (e.g., current year + 50) and define precise boundary behavior."
        },
        {
          "reasoning": "Time-relative logic changes as the current year advances; static fixtures can become invalid.",
          "action": "Compute expectations relative to the current UTC year rather than hardcoding expected centuries."
        },
        {
          "reasoning": "Boundaries are where off-by-one and interpretation bugs appear.",
          "action": "Test values just below, at, and just above the threshold (e.g., now+49, now+50, now+51 equivalents) and extreme ends (00, 99)."
        },
        {
          "reasoning": "Cross-format coverage ensures parsing consistency.",
          "action": "Include cases for all supported date formats and verify identical year resolution when applicable."
        },
        {
          "reasoning": "Validating across existing cases ensures no regressions in other supported formats.",
          "action": "Run existing tests and add targeted checks for RFC1123, RFC850, and asctime inputs to ensure compatibility."
        },
        {
          "reasoning": "Verification under real runtime conditions validates both correctness and performance implications.",
          "action": "Execute the full or targeted test suite and compare outcomes before and after the change, iterating if discrepancies arise."
        }
      ],
      "source_clusters": [
        "Request Routing and HTTP Parsing"
      ]
    },
    {
      "name": "Route Resolution Regression Diagnosis and Fix",
      "description": "Diagnose and fix regressions in URL parameter handling, especially with optional named groups and positional/keyword argument passing.",
      "steps": [
        {
          "reasoning": "Reproducing the issue ensures you are fixing the right problem and provides a baseline.",
          "action": "Construct a minimal URL pattern and view signature reflecting the bug (e.g., optional named group) and trigger the failing path."
        },
        {
          "reasoning": "Understanding how arguments are constructed from regex matches reveals the exact failure mode.",
          "action": "Inspect the URL matching/resolver path, focusing on how kwargs discard None and how positional args are formed when kwargs are empty."
        },
        {
          "reasoning": "A surgical fix reduces risk: only adjust the logic that introduces invalid arguments.",
          "action": "Refine args construction to exclude None entries while preserving documented behavior (e.g., ignore unnamed groups when named groups exist)."
        },
        {
          "reasoning": "Targeted tests validate both the original failure and guard against future regressions.",
          "action": "Add or run tests for optional named groups, mixed named/unnamed groups, and typical request resolution paths."
        },
        {
          "reasoning": "Ensuring compatibility with existing behaviors avoids breaking downstream applications.",
          "action": "Run a subset of URL-related and handler tests and confirm no changes in documented behavior beyond the intended fix."
        }
      ],
      "source_clusters": [
        "Request Routing and HTTP Parsing"
      ]
    },
    {
      "name": "Harden Exception Handling in Filesystem-Based Developer Utilities",
      "description": "Robustly handle unexpected filesystem/path errors in autoreloaders or watchers without crashing, with regression tests for reliability.",
      "steps": [
        {
          "reasoning": "Start from the concrete failure context to avoid guesswork and pinpoint the code path raising the exception.",
          "action": "Use the error message or stack trace to identify the function and module where the exception originates."
        },
        {
          "reasoning": "Understanding the implementation around the failing call reveals current error handling gaps.",
          "action": "Open and read the implementation around the reported line(s); locate calls to filesystem/path APIs (e.g., Path.resolve)."
        },
        {
          "reasoning": "Determine which exceptions can surface in real environments so the code can handle them gracefully.",
          "action": "Audit and expand exception handling (e.g., catch ValueError alongside FileNotFoundError) to skip problematic entries instead of crashing."
        },
        {
          "reasoning": "Document intent for future maintainers and prevent accidental removal of necessary guards.",
          "action": "Add comments explaining why broader exceptions are caught (e.g., network mounts or embedded null bytes)."
        },
        {
          "reasoning": "Guard against regressions and confirm behavior without relying on flaky environments.",
          "action": "Add a regression test that mocks the problematic call (e.g., Path.resolve raising ValueError) and asserts graceful handling."
        },
        {
          "reasoning": "Ensure changes don\u2019t break unaffected functionality.",
          "action": "Run the existing test suite and targeted modules relevant to the change; iterate if failures arise."
        }
      ],
      "source_clusters": [
        "Developer Tooling (Autoreload and Test Framework)"
      ]
    },
    {
      "name": "Make Test Framework Data Restoration Transactional",
      "description": "Resolve integrity errors during rollback deserialization by mirroring transactional behavior from similar code paths.",
      "steps": [
        {
          "reasoning": "Understanding the root cause (e.g., FK ordering plus lack of transaction) guides the minimal, correct fix.",
          "action": "Analyze how objects are deserialized/saved and identify assumptions about ordering or atomicity."
        },
        {
          "reasoning": "Established patterns in similar components (e.g., loaddata) provide a proven reference.",
          "action": "Compare with existing components that do similar work (loaddata) and note transactional patterns (transaction.atomic)."
        },
        {
          "reasoning": "Wrapping deserialization in a transaction ensures all-or-nothing behavior and defers constraints until end.",
          "action": "Wrap the deserialization/save loop in a transaction.atomic(using=alias) block."
        },
        {
          "reasoning": "Changes to transactional behavior can have wide impact; focused testing reduces risk.",
          "action": "Run relevant test suites (TransactionTestCase, migration data persistence, fixtures) to validate correctness and catch regressions."
        },
        {
          "reasoning": "Confirm applicability across supported backends and scenarios.",
          "action": "If available, run tests for multiple databases/backends and adjust if backend-specific issues arise."
        }
      ],
      "source_clusters": [
        "Developer Tooling (Autoreload and Test Framework)"
      ]
    },
    {
      "name": "Align Configuration Checks with Runtime Semantics for Internationalization",
      "description": "Identify and reconcile mismatches between system checks and runtime i18n behavior, implement a minimal fix, and validate across edge cases.",
      "steps": [
        {
          "reasoning": "You need to understand where the rule is enforced to know what to fix.",
          "action": "Locate the validation/check implementation and read its logic."
        },
        {
          "reasoning": "Runtime behavior defines the intended semantics.",
          "action": "Identify and study the runtime code that resolves language variants/fallbacks."
        },
        {
          "reasoning": "Documentation and tests define expected behavior and constraints.",
          "action": "Review docs and tests around the feature (e.g., language code fallback) to confirm expectations."
        },
        {
          "reasoning": "A clear mapping of check logic vs runtime logic reveals gaps causing false positives.",
          "action": "Compare the check's conditions to how runtime resolves languages and list discrepancies."
        },
        {
          "reasoning": "A minimal reproducer accelerates debugging and validates correctness repeatedly.",
          "action": "Write a small script/test configuring only the necessary settings to trigger the issue; programmatically configure settings and run the relevant checks."
        },
        {
          "reasoning": "Capturing the exact error code ensures you\u2019re fixing the right issue.",
          "action": "Filter and assert on the specific check ID in the output (e.g., translation.E004)."
        },
        {
          "reasoning": "Small, well-scoped changes reduce risk and ease review.",
          "action": "Target the conditional(s) that cause the misclassification rather than broad refactors."
        },
        {
          "reasoning": "Mirroring runtime semantics ensures consistency.",
          "action": "Align check logic with runtime variant resolution (e.g., exact match, base-language fallback, prefix handling)."
        },
        {
          "reasoning": "Edge cases frequently break naive logic.",
          "action": "Handle multi-segment tags (e.g., zh-hans-cn), region-specific codes (e.g., fr-ca), and generic prefixes explicitly."
        },
        {
          "reasoning": "Backwards compatibility prevents new false negatives/positives.",
          "action": "Confirm unchanged behavior in unaffected paths and document any intentional behavior change."
        },
        {
          "reasoning": "Targeted suites run quickly and focus on the area of change.",
          "action": "Run only the relevant check framework/i18n test modules before broader runs; then expand to larger subsets or the full suite."
        },
        {
          "reasoning": "Ensuring runtime and checks treat variants uniformly prevents inconsistencies.",
          "action": "Verify both the system checks and runtime resolvers accept the same set of variants; add or update tests to cover each edge case explicitly."
        },
        {
          "reasoning": "A clear summary speeds up review and future maintenance.",
          "action": "Review diffs; document the problem, the changes, and verification results, including example inputs/outputs showing pre- and post-fix behavior."
        }
      ],
      "source_clusters": [
        "Internationalization and Language Settings"
      ]
    },
    {
      "name": "Design a Robust Serialization Fix for Nested Symbols",
      "description": "Adjust serialization to correctly reference nested classes/enums while maintaining compatibility with local classes and importability.",
      "steps": [
        {
          "reasoning": "Nested classes require qualified names to be unambiguous in migrations/serialization.",
          "action": "Prefer __qualname__ over __name__ when serializing types so inner classes/enums are fully qualified."
        },
        {
          "reasoning": "Locally defined classes (in function scope) produce <locals> in __qualname__ which aren\u2019t importable.",
          "action": "Fallback to __name__ if __qualname__ contains '<locals>' to preserve previous behavior for non-importable symbols."
        },
        {
          "reasoning": "Deconstructible objects and fields may return paths that don\u2019t clearly indicate module boundaries for nested classes.",
          "action": "Resolve importable module boundaries progressively (left-to-right) to split module vs attribute path correctly."
        },
        {
          "reasoning": "Ensure the fix works across real cases and doesn\u2019t regress existing behavior.",
          "action": "Validate with migration writer tests and custom scripts that simulate makemigrations scenarios involving nested classes and enums."
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs"
      ]
    },
    {
      "name": "Safely Change Method Injection Under Inheritance",
      "description": "Adjust dynamic method creation (e.g., get_FOO_display()) to respect inheritance and preserve explicit overrides.",
      "steps": [
        {
          "reasoning": "Generated methods need to reflect the child class\u2019s field metadata, not the base class\u2019s, when fields are overridden.",
          "action": "Identify where the method is injected (e.g., Field.contribute_to_class) and understand current override checks."
        },
        {
          "reasoning": "hasattr detects inherited methods and blocks correct reinjection on child classes.",
          "action": "Replace hasattr-based guards with a direct cls.__dict__ check to allow overriding inherited auto-generated methods while preserving explicit user-defined ones."
        },
        {
          "reasoning": "Different inheritance patterns (abstract vs concrete) have distinct semantics for field overriding.",
          "action": "Verify behavior across abstract base classes (where overriding is valid) and avoid scenarios that the framework disallows (concrete same-name override)."
        },
        {
          "reasoning": "Prevent regressions in behavior of existing features using choices and display methods.",
          "action": "Run focused and broader test suites around model fields and forms that rely on choices and get_FOO_display()."
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs"
      ]
    },
    {
      "name": "Fix ORM Ordering Resolution Without Regressions",
      "description": "Resolve ordering bugs by tracing direction propagation and applying minimal changes to avoid unrelated regressions.",
      "steps": [
        {
          "reasoning": "Understanding how direction (ASC/DESC) is propagated is key to fixing subtle ordering issues.",
          "action": "Trace flow in the compiler (e.g., find_ordering_name, get_order_dir) and identify where default order direction interacts with field names like 'pk'."
        },
        {
          "reasoning": "A direct change to direction propagation can break other query behaviors.",
          "action": "Attempt a minimal fix and immediately validate against known ordering and query tests to catch regressions early."
        },
        {
          "reasoning": "Upstream history often contains a minimal, safe resolution and rationale.",
          "action": "Consult repository history/commits for similar fixes and align with the approach that resolved edge cases (e.g., skip recursion when name == 'pk')."
        },
        {
          "reasoning": "Ensure both the reported bug and previously working behaviors remain correct.",
          "action": "Re-run targeted reproductions and broader suites (ordering, model_inheritance, queries) to confirm the fix."
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs"
      ]
    },
    {
      "name": "Correct User-Facing Error Hints",
      "description": "Update error hint messages to reference the correct API, reflect current framework versions, and maintain clarity.",
      "steps": [
        {
          "reasoning": "Hints guide users; wrong API references mislead and cause confusion.",
          "action": "Search for the error string and confirm the surrounding validation logic to ensure the hint applies to the right condition."
        },
        {
          "reasoning": "API semantics evolve; hints must stay current.",
          "action": "Update hint wording to use the correct field type and current arguments; remove outdated flags or parameters."
        },
        {
          "reasoning": "Tests often verify exact hint text; ensure alignment.",
          "action": "Adjust or add tests verifying the updated hint text and run the invalid models/tests to validate."
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs"
      ]
    },
    {
      "name": "Diagnose and Fix Sensitive Data Leakage in Exception Reports",
      "description": "Identify insufficient sanitization in error reporting and deliver a safe, regression-free recursive cleansing fix.",
      "steps": [
        {
          "reasoning": "Understanding the code location and responsibility helps target the fix to the right component.",
          "action": "Locate the exception reporting filter implementation and review how settings and context are cleansed."
        },
        {
          "reasoning": "Tests reveal current behavior and constraints, guiding what changes are safe.",
          "action": "Explore existing tests related to exception reporting to learn expected sanitization."
        },
        {
          "reasoning": "A minimal reproduction clarifies the exact failure mode and confirms assumptions.",
          "action": "Create a focused scenario using nested settings structures to demonstrate the leak."
        },
        {
          "reasoning": "Before changing code, planning the approach avoids breaking behavior and preserves compatibility.",
          "action": "Design a recursive sanitization that handles dicts and non-dict iterables, defines sensitive keys (e.g., 'secret', 'token', 'password'), preserves container types, avoids mutation, and guards recursion depth/unexpected types."
        },
        {
          "reasoning": "Adding targeted tests prevents regressions and documents the newly supported scenarios.",
          "action": "Write tests covering lists, tuples, nested containers, and mixed structures with sensitive keys at various nesting levels."
        },
        {
          "reasoning": "Running the suite ensures that the change integrates without impacting other components.",
          "action": "Execute relevant subsets and the broader test suite to validate the patch comprehensively."
        },
        {
          "reasoning": "Cleanup and summarization provide maintainability and transparency.",
          "action": "Remove temporary artifacts and document the fix rationale and coverage."
        }
      ],
      "source_clusters": [
        "Security and Error Reporting Sanitization"
      ]
    }
  ],
  "type2_workflows": [
    {
      "name": "Set Up Local Django Dev Environment and Run Targeted Tests",
      "description": "Prepare a local Django source tree for development, verify imports use your working copy, and run focused/broad test suites efficiently.",
      "steps": [
        {
          "reasoning": "Editable install ensures Python imports your local changes.",
          "action": "cd /workspace/django && pip install -e ."
        },
        {
          "reasoning": "If editable install isn't used, ensure Python can import the source tree.",
          "action": "export PYTHONPATH=/workspace/django:$PYTHONPATH"
        },
        {
          "reasoning": "Confirm the Django version and that the source is the working tree.",
          "action": "python -c \"import django,inspect; print(django.__version__, inspect.getsourcefile(django))\""
        },
        {
          "reasoning": "Run focused modules for rapid iteration.",
          "action": "python /workspace/django/tests/runtests.py migrations.test_writer -v 2"
        },
        {
          "reasoning": "Run targeted test modules relevant to routing and requests.",
          "action": "python /workspace/django/tests/runtests.py urlpatterns_reverse handlers requests -v 1"
        },
        {
          "reasoning": "Run utility tests (e.g., HTTP date parsing).",
          "action": "python /workspace/django/tests/runtests.py utils_tests -v 1"
        },
        {
          "reasoning": "Run ORM-related suites to detect regressions.",
          "action": "python /workspace/django/tests/runtests.py ordering model_inheritance queries -v 1"
        },
        {
          "reasoning": "Target an individual failing test to speed up debugging.",
          "action": "python /workspace/django/tests/runtests.py queries.tests.Queries1Tests.test_tickets_2076_7256 -v 2"
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs",
        "Request Routing and HTTP Parsing",
        "Developer Tooling (Autoreload and Test Framework)",
        "Internationalization and Language Settings",
        "Security and Error Reporting Sanitization"
      ]
    },
    {
      "name": "Investigate ORM/Migrations Bug: Locate, Reproduce, and Validate",
      "description": "Systematically find relevant code and tests in Django\u2019s ORM/migrations, create a minimal reproduction, and validate behavior.",
      "steps": [
        {
          "reasoning": "Find where the error message or function is defined to narrow down the fix location.",
          "action": "grep -r \"If you want to create a recursive relationship\" django/"
        },
        {
          "reasoning": "Open the file at the lines surrounding the match for context.",
          "action": "sed -n '1250,1350p' django/db/models/fields/related.py"
        },
        {
          "reasoning": "Find corresponding tests to understand expected behavior.",
          "action": "grep -rn \"E334\\|E335\" tests/"
        },
        {
          "reasoning": "Inspect test logic to confirm how the message is asserted.",
          "action": "sed -n '130,165p' tests/invalid_models_tests/test_relative_fields.py"
        },
        {
          "reasoning": "Django needs settings configured before model import/use.",
          "action": "In a Python script: import django; from django.conf import settings; settings.configure(INSTALLED_APPS=[...], DATABASES=..., SECRET_KEY='x'); django.setup()"
        },
        {
          "reasoning": "Models defined outside apps must have an app_label to avoid registration issues.",
          "action": "Define models with class Meta: app_label = 'test_app'"
        },
        {
          "reasoning": "Ensure local Django source is used for reproduction.",
          "action": "PYTHONPATH=/workspace/django python test_script.py"
        },
        {
          "reasoning": "Confirm the issue by printing/inspecting behavior.",
          "action": "Trigger behavior (e.g., instance.get_FOO_display(), migration serialization output, queryset.query) and print results"
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs"
      ]
    },
    {
      "name": "Improve Migration Serializer for Nested Types and Deconstructible Paths",
      "description": "Make migration serialization robust for nested/local classes and for deconstructible object paths where module boundaries are ambiguous.",
      "steps": [
        {
          "reasoning": "Identify where class types are converted to strings.",
          "action": "Open django/db/migrations/serializer.py and locate TypeSerializer.serialize()"
        },
        {
          "reasoning": "Use fully qualified names for nested classes to serialize correctly.",
          "action": "Change code to use obj.__qualname__ instead of obj.__name__"
        },
        {
          "reasoning": "Avoid non-importable names for locally defined classes.",
          "action": "Add a fallback: if '<locals>' in qualname, use obj.__name__"
        },
        {
          "reasoning": "Current split by last dot can misidentify module vs attribute for nested classes.",
          "action": "Open django/db/migrations/serializer.py and find DeconstructableSerializer._serialize_path"
        },
        {
          "reasoning": "Ensure the module part is importable by progressively testing prefixes.",
          "action": "Implement progressive import: iterate components left-to-right and import '.'.join(parts[:i]) until success; remaining parts form the attribute path"
        },
        {
          "reasoning": "Handle edge cases with no dots or invalid imports gracefully.",
          "action": "Add guards for paths without dots and exceptions during import to avoid breaking serialization"
        },
        {
          "reasoning": "Verify new behavior against migration writer tests and custom scripts.",
          "action": "python /workspace/django/tests/runtests.py migrations.test_writer -v 2; run a custom script that serializes nested enums/classes and Field.deconstruct() outputs"
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs"
      ]
    },
    {
      "name": "Preserve Manual Overrides When Injecting get_FOO_display",
      "description": "Adjust Field.contribute_to_class to allow child overwrite of generated methods while preserving user-defined methods.",
      "steps": [
        {
          "reasoning": "Find where get_%s_display is added to the class.",
          "action": "Open django/db/models/fields/__init__.py and locate contribute_to_class"
        },
        {
          "reasoning": "Avoid blocking reinjection due to inherited methods.",
          "action": "Replace hasattr(cls, method_name) with method_name not in cls.__dict__ condition"
        },
        {
          "reasoning": "Confirm the fix on a minimal example.",
          "action": "Run a script that defines an abstract base with choices and a child adding new choices; assert child_instance.get_FOO_display() returns labels for new values"
        },
        {
          "reasoning": "Verify regression safety across related areas.",
          "action": "python /workspace/django/tests/runtests.py model_fields model_forms -v 1"
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs"
      ]
    },
    {
      "name": "Fix Inherited '-pk' Ordering in ORM",
      "description": "Prevent incorrect direction flipping for '-pk' on inherited models while preserving other ordering behaviors.",
      "steps": [
        {
          "reasoning": "Identify where Meta.ordering is resolved for related fields and primary key.",
          "action": "Open django/db/models/sql/compiler.py and locate find_ordering_name"
        },
        {
          "reasoning": "Avoid recursing into related ordering when ordering by 'pk' which maps to the primary key field.",
          "action": "Update recursion condition to include: and name != 'pk'"
        },
        {
          "reasoning": "Validate the specific bug fix.",
          "action": "Run a reproduction script that defines Parent.Meta.ordering=['-pk'] and queries Child; inspect queryset.query to ensure DESC"
        },
        {
          "reasoning": "Ensure no regressions in complex query ordering.",
          "action": "python /workspace/django/tests/runtests.py ordering model_inheritance queries -v 1"
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs"
      ]
    },
    {
      "name": "Update ManyToMany Recursive Relationship Error Hint",
      "description": "Correct the validation hint to reference ManyToManyField and remove outdated arguments for recursive relationships.",
      "steps": [
        {
          "reasoning": "Find the offending hint string to edit.",
          "action": "grep -r \"recursive relationship\" django/db/models/fields/related.py"
        },
        {
          "reasoning": "Align hint with correct API and current version semantics.",
          "action": "Replace 'ForeignKey(\"%s\", symmetrical=False, through=\"%s\")' with 'ManyToManyField(\"%s\", through=\"%s\")' in both E334 and E335 cases"
        },
        {
          "reasoning": "Validate the message against tests that assert exact text.",
          "action": "python /workspace/django/tests/runtests.py invalid_models_tests.test_relative_fields.RelativeFieldTests.test_ambiguous_relationship_model -v 2"
        },
        {
          "reasoning": "Ensure no other related validations are affected.",
          "action": "python /workspace/django/tests/runtests.py many_to_many m2m_through m2m_recursive -v 1"
        }
      ],
      "source_clusters": [
        "ORM and Migrations Bugs"
      ]
    },
    {
      "name": "Fix HTTP Date Parsing Two-Digit Year Rule (RFC 7231)",
      "description": "Implement the dynamic 50-year window rule for two-digit years in HTTP date parsing and validate behavior across formats.",
      "steps": [
        {
          "reasoning": "Quickly find the function definition and related code.",
          "action": "grep -rn \"parse_http_date\" django | head -20"
        },
        {
          "reasoning": "Open the suspected file to inspect the implementation.",
          "action": "sed -n '1,220p' django/utils/http.py"
        },
        {
          "reasoning": "Confirm the presence of hardcoded year range logic.",
          "action": "grep -nE \"1900|2000|\\byear\\b\" django/utils/http.py"
        },
        {
          "reasoning": "Modify the mapping from two-digit years to full years per RFC 7231.",
          "action": "Edit django/utils/http.py: use datetime.utcnow().year to implement: if yy+2000 > current_year + 50 -> use 1900+yy else 2000+yy"
        },
        {
          "reasoning": "Empirically verify current behavior before and after changing code.",
          "action": "python - << 'PY'\nfrom django.utils.http import parse_http_date\nfor d in [\"Sunday, 06-Nov-74 08:49:37 GMT\", \"Sunday, 06-Nov-85 08:49:37 GMT\", \"Sun Nov  6 08:49:37 0037\"]:\n    print(d, '->', parse_http_date(d))\nPY"
        },
        {
          "reasoning": "Test boundary cases that reveal off-by-one issues.",
          "action": "python - << 'PY'\nfrom datetime import datetime\nfrom django.utils.http import parse_http_date\nnow = datetime.utcnow().year\nsamples = [0, 49, 50, 51, 69, 70, 85, 99]\nfor yy in samples:\n    s = f\"Sunday, 06-Nov-{yy:02d} 08:49:37 GMT\"\n    ts = parse_http_date(s)\n    print(s, '->', ts)\nPY"
        },
        {
          "reasoning": "Ensure other formats continue to work as expected.",
          "action": "python - << 'PY'\nfrom django.utils.http import parse_http_date\ncases = [\n    'Sun, 06 Nov 1994 08:49:37 GMT',\n    'Sunday, 06-Nov-94 08:49:37 GMT',\n    'Sun Nov  6 08:49:37 1994',\n]\nfor c in cases:\n    print(c, '->', parse_http_date(c))\nPY"
        },
        {
          "reasoning": "Validate via Django test suite for utils.",
          "action": "python /workspace/django/tests/runtests.py utils_tests -v 1"
        }
      ],
      "source_clusters": [
        "Request Routing and HTTP Parsing"
      ]
    },
    {
      "name": "Patch URL Resolver to Ignore None Positional Args from Optional Groups",
      "description": "Ensure RegexPattern.match() doesn't pass extra None positional arguments when optional named groups are unmatched.",
      "steps": [
        {
          "reasoning": "Self-contained reproduction isolates the issue.",
          "action": "python - << 'PY'\nfrom django.conf import settings\nfrom django.urls import re_path, resolve\nfrom django.http import HttpResponse\nsettings.configure(ROOT_URLCONF=__name__, DEBUG=True, SECRET_KEY='x')\n\ndef modules(request, format='html'):\n    return HttpResponse(format)\nurlpatterns = [re_path(r'^module/(?P<format>(html|json|xml))?/?$', modules)]\n\nfrom django.test import RequestFactory\nrf = RequestFactory()\nmatch = resolve('/module/')\nprint('args:', match.args, 'kwargs:', match.kwargs)\nresp = match.func(rf.get('/module/'), *match.args, **match.kwargs)\nprint('response:', resp.status_code)\nPY"
        },
        {
          "reasoning": "Inspect regex behavior to understand None propagation.",
          "action": "python - << 'PY'\nimport re\np = re.compile(r'^module/(?P<format>(html|json|xml))?/?$')\nfor path in ['module/', 'module/html/']:\n    m = p.match(path)\n    print(path, 'groupdict=', m.groupdict(), 'groups=', m.groups())\nPY"
        },
        {
          "reasoning": "Identify the exact code constructing args/kwargs to implement a minimal, safe change.",
          "action": "sed -n '120,190p' django/urls/resolvers.py | nl | sed -n '145,170p'"
        },
        {
          "reasoning": "Exclude None values when forming positional args if no kwargs are present.",
          "action": "Edit django/urls/resolvers.py: change\nargs = () if kwargs else match.groups()\n# to\nargs = () if kwargs else tuple(g for g in match.groups() if g is not None)"
        },
        {
          "reasoning": "Verify the fix resolves the crash and preserves expected behavior.",
          "action": "python - << 'PY'\nfrom django.conf import settings\nfrom django.urls import re_path, resolve\nfrom django.http import HttpResponse\nsettings.configure(ROOT_URLCONF=__name__, DEBUG=True, SECRET_KEY='x')\n\ndef modules(request, format='html'):\n    return HttpResponse(format)\nurlpatterns = [re_path(r'^module/(?P<format>(html|json|xml))?/?$', modules)]\n\nfrom django.test import RequestFactory\nrf = RequestFactory()\nfor path in ['/module/', '/module/html/']:\n    match = resolve(path)\n    print('path:', path, 'args:', match.args, 'kwargs:', match.kwargs)\n    resp = match.func(rf.get(path), *match.args, **match.kwargs)\n    print('status:', resp.status_code)\nPY"
        },
        {
          "reasoning": "Run routing-related tests to ensure no regressions.",
          "action": "python /workspace/django/tests/runtests.py urlpatterns_reverse -v 2; python /workspace/django/tests/runtests.py handlers requests -v 1"
        }
      ],
      "source_clusters": [
        "Request Routing and HTTP Parsing"
      ]
    },
    {
      "name": "Handle ValueError from Path.resolve in Autoreloader and Add Regression Test",
      "description": "Patch Django\u2019s autoreloader to skip problematic filesystem entries that raise ValueError (e.g., embedded null bytes) and add a regression test.",
      "steps": [
        {
          "reasoning": "Quickly find the relevant module implementing the feature.",
          "action": "find /workspace/django -type f -name \"autoreload.py\""
        },
        {
          "reasoning": "Identify exact usage of the problematic API to align with the stack trace.",
          "action": "grep -n \"resolve(\\|Path.resolve\" /workspace/django/django/utils/autoreload.py"
        },
        {
          "reasoning": "View context to confirm control flow and error handling.",
          "action": "sed -n '1,220p' /workspace/django/django/utils/autoreload.py"
        },
        {
          "reasoning": "Broaden exception handling to skip problematic entries without crashing.",
          "action": "Edit /workspace/django/django/utils/autoreload.py: change `except FileNotFoundError:` to `except (FileNotFoundError, ValueError):` in iter_modules_and_files() and sys_path_directories(); add a comment explaining embedded null bytes/network mounts."
        },
        {
          "reasoning": "Create a unit test that simulates Path.resolve raising ValueError.",
          "action": "Edit /workspace/django/tests/utils_tests/test_autoreload.py: add test_iter_modules_and_files_handles_embedded_null_bytes that patches pathlib.Path.resolve to raise ValueError(\"embedded null byte\") and asserts no crash/empty result."
        },
        {
          "reasoning": "Validate the fix with the test suite.",
          "action": "python /workspace/django/tests/runtests.py utils_tests.test_autoreload -v2"
        },
        {
          "reasoning": "Audit the exact code modifications to ensure only intended changes are present.",
          "action": "git diff /workspace/django/django/utils/autoreload.py"
        },
        {
          "reasoning": "Run broader tests around utils and test tooling to catch regressions.",
          "action": "python /workspace/django/tests/runtests.py test_runner fixtures transactions --verbosity=1"
        }
      ],
      "source_clusters": [
        "Developer Tooling (Autoreload and Test Framework)"
      ]
    },
    {
      "name": "Wrap Test DB Rollback Deserialization in a Transaction",
      "description": "Ensure deserialize_db_from_string runs inside an atomic transaction to avoid partial state and integrity errors.",
      "steps": [
        {
          "reasoning": "Open the backend creation module where deserialization occurs.",
          "action": "vi /workspace/django/django/db/backends/base/creation.py"
        },
        {
          "reasoning": "Import the transaction API needed for atomic blocks.",
          "action": "Modify imports to `from django.db import router, transaction`"
        },
        {
          "reasoning": "Ensure deserialization is all-or-nothing to avoid integrity errors.",
          "action": "Wrap the object save loop with `with transaction.atomic(using=alias):` inside deserialize_db_from_string"
        },
        {
          "reasoning": "Confirm that the intended changes are in place before running tests.",
          "action": "sed -n '1,150p' /workspace/django/django/db/backends/base/creation.py | sed -n '120,150p'"
        },
        {
          "reasoning": "Run relevant tests to verify correctness and catch regressions.",
          "action": "python /workspace/django/tests/runtests.py test_utils.test_transactiontestcase migration_test_data_persistence --verbosity=2"
        }
      ],
      "source_clusters": [
        "Developer Tooling (Autoreload and Test Framework)"
      ]
    },
    {
      "name": "Fix translation.E004: Accept Base and Variant Language Codes",
      "description": "Modify the system check to accept LANGUAGE_CODE variants when the base language is present in LANGUAGES, mirroring runtime fallback behavior.",
      "steps": [
        {
          "reasoning": "Locate translation check implementation and E004.",
          "action": "cd /workspace/django && find django -type f -name \"*.py\" | grep core/checks | xargs grep -n \"translation\""
        },
        {
          "reasoning": "Open the file to inspect the check logic and E004.",
          "action": "sed -n '1,200p' django/django/core/checks/translation.py"
        },
        {
          "reasoning": "Study runtime language fallback to mirror in checks.",
          "action": "grep -R \"get_supported_language_variant\\|generic_lang_code\" django/django/utils/translation -n && sed -n '1,180p' django/django/utils/translation/__init__.py && sed -n '1,150p;350,520p' django/django/utils/translation/trans_real.py"
        },
        {
          "reasoning": "Programmatically trigger the E004 system check to reproduce the issue.",
          "action": "python - << 'PY'\nfrom django.conf import settings\nfrom django.core.checks import run_checks\nif not settings.configured:\n    settings.configure(SECRET_KEY='x', INSTALLED_APPS=[], USE_I18N=True, LANGUAGE_CODE='de-at', LANGUAGES=[('de','German')])\nerrors = [e for e in run_checks() if e.id=='translation.E004']\nprint('translation.E004 found:', bool(errors))\nfor e in errors:\n    print(e.id, e.msg)\nPY"
        },
        {
          "reasoning": "Implement check logic to accept exact match, base match, and prefix variants.",
          "action": "Edit django/django/core/checks/translation.py: in check_language_settings_consistent, accept if LANGUAGE_CODE is in dict(LANGUAGES) or if base LANGUAGE_CODE.split('-')[0] is in LANGUAGES or any code in LANGUAGES startswith base+'-'."
        },
        {
          "reasoning": "Quickly validate the fix against the minimal reproducer.",
          "action": "python - << 'PY'\nfrom django.conf import settings\nfrom django.core.checks import run_checks\nsettings.configure(SECRET_KEY='x', USE_I18N=True, LANGUAGE_CODE='de-at', LANGUAGES=[('de','German')])\nerrs = [e for e in run_checks() if e.id=='translation.E004']\nprint('translation.E004 found:', bool(errs))\nPY"
        },
        {
          "reasoning": "Run targeted tests for translation checks.",
          "action": "python /workspace/django/tests/runtests.py check_framework.test_translation -v 2"
        },
        {
          "reasoning": "Test multiple scenarios to cover variants and direct matches.",
          "action": "python - << 'PY'\nfrom django.conf import settings\nfrom django.core.checks import run_checks\ncases=[('de-at',[('de','German')]), ('es-ar',[('es-ar','')]), ('zh-hans-cn',[('zh-hans','')])]\nfor code, langs in cases:\n    settings._wrapped=None\n    settings.configure(SECRET_KEY='x', USE_I18N=True, LANGUAGE_CODE=code, LANGUAGES=langs)\n    errs=[e for e in run_checks() if e.id=='translation.E004']\n    print(code, 'E004:', bool(errs))\nPY"
        },
        {
          "reasoning": "Confirm overall stability after the fix.",
          "action": "python /workspace/django/tests/runtests.py check_framework i18n -v 1"
        },
        {
          "reasoning": "Show what changed for review.",
          "action": "git diff django/django/core/checks/translation.py"
        }
      ],
      "source_clusters": [
        "Internationalization and Language Settings"
      ]
    },
    {
      "name": "Recursively Sanitize Nested Iterables in SafeExceptionReporterFilter",
      "description": "Ensure exception reporting sanitization recurses into lists/tuples and mixed structures, preserving container types, without leaking sensitive values.",
      "steps": [
        {
          "reasoning": "Open the suspected module to inspect current cleanse_setting implementation.",
          "action": "sed -n '1,240p' /workspace/django/django/views/debug.py"
        },
        {
          "reasoning": "Search tests referencing SafeExceptionReporterFilter for existing expectations.",
          "action": "grep -R \"SafeExceptionReporterFilter\" /workspace/django/tests"
        },
        {
          "reasoning": "Locate specific tests to target during iteration.",
          "action": "grep -n \"cleanse_setting\" /workspace/django/tests/view_tests/tests/test_debug.py"
        },
        {
          "reasoning": "Reproduce the sanitization failure with nested lists/tuples containing dicts of sensitive keys.",
          "action": "python - << 'PY'\nfrom django.views.debug import SafeExceptionReporterFilter\nf = SafeExceptionReporterFilter()\nval = [{'token': 'secret'}, ({'password': 'p'}, {'nested': [{'api_key':'x'}]})]\nprint('before:', val)\nprint('after:', f.cleanse_setting('IGNORED', val))\nPY"
        },
        {
          "reasoning": "Add handling for iterables to recurse while preserving type.",
          "action": "Edit /workspace/django/django/views/debug.py: in cleanse_setting, add branches for list/tuple \u2192 map cleanse_setting over items \u2192 reconstruct list or tuple; keep dict handling intact and recurse into values."
        },
        {
          "reasoning": "Add new tests for list/tuple/mixed recursive cleansing.",
          "action": "Edit /workspace/django/tests/view_tests/tests/test_debug.py: add tests under SafeExceptionReporterFilterTests for lists, tuples, and mixed nested structures containing sensitive keys."
        },
        {
          "reasoning": "Run targeted tests to validate behavior.",
          "action": "python /workspace/django/tests/runtests.py view_tests.tests.test_debug.SafeExceptionReporterFilterTests -v 2"
        },
        {
          "reasoning": "Run the broader view_tests suite to catch regressions.",
          "action": "python /workspace/django/tests/runtests.py view_tests -v 2"
        },
        {
          "reasoning": "Show diffs for review and keep repository tidy.",
          "action": "git diff /workspace/django/django/views/debug.py /workspace/django/tests/view_tests/tests/test_debug.py"
        }
      ],
      "source_clusters": [
        "Security and Error Reporting Sanitization"
      ]
    }
  ]
}