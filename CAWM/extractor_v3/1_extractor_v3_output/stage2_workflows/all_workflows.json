{
  "ORM and Migrations Bugs": {
    "type1_workflows": [
      {
        "name": "Localize and Validate a Framework Bug via Source and Tests",
        "description": "From a high-level bug report, identify the responsible code paths, confirm with tests, and build a minimal reproduction to validate assumptions.",
        "steps": [
          {
            "reasoning": "You need to know which module or subsystem is responsible before making changes.",
            "action": "Translate the symptom into likely subsystems and search the codebase (e.g., migrations serializer, ORM compiler, field contribute_to_class) to pinpoint candidates."
          },
          {
            "reasoning": "Existing tests reveal intended behavior and regression boundaries.",
            "action": "Search for relevant tests to understand expectations and constraints; if none, plan to write or sketch targeted tests."
          },
          {
            "reasoning": "A minimal reproduction isolates the problem from broader environment noise.",
            "action": "Create a minimal script or model definitions that triggers the issue (e.g., nested class serialization, inherited choices, inherited ordering)."
          },
          {
            "reasoning": "Confirm that your reproduction matches the reported behavior to avoid fixing the wrong thing.",
            "action": "Run the reproduction and verify outputs (e.g., generated migration strings, get_FOO_display() labels, SQL ordering)."
          }
        ]
      },
      {
        "name": "Design a Robust Serialization Fix for Nested Symbols",
        "description": "Adjust serialization to correctly reference nested classes/enums while maintaining compatibility with local classes and importability.",
        "steps": [
          {
            "reasoning": "Nested classes require qualified names to be unambiguous in migrations/serialization.",
            "action": "Prefer __qualname__ over __name__ when serializing types so inner classes/enums are fully qualified."
          },
          {
            "reasoning": "Locally defined classes (in function scope) produce <locals> in __qualname__ which aren\u2019t importable.",
            "action": "Fallback to __name__ if __qualname__ contains '<locals>' to preserve previous behavior for non-importable symbols."
          },
          {
            "reasoning": "Deconstructible objects and fields may return paths that don\u2019t clearly indicate module boundaries for nested classes.",
            "action": "Resolve importable module boundaries progressively (left-to-right) to split module vs attribute path correctly."
          },
          {
            "reasoning": "Ensure the fix works across real cases and doesn\u2019t regress existing behavior.",
            "action": "Validate with migration writer tests and custom scripts that simulate makemigrations scenarios involving nested classes and enums."
          }
        ]
      },
      {
        "name": "Safely Change Method Injection Under Inheritance",
        "description": "Adjust dynamic method creation (e.g., get_FOO_display()) to respect inheritance and preserve explicit overrides.",
        "steps": [
          {
            "reasoning": "Generated methods need to reflect the child class\u2019s field metadata, not the base class\u2019s, when fields are overridden.",
            "action": "Identify where the method is injected (e.g., Field.contribute_to_class) and understand current override checks."
          },
          {
            "reasoning": "hasattr detects inherited methods and blocks correct reinjection on child classes.",
            "action": "Replace hasattr-based guards with a direct cls.__dict__ check to allow overriding inherited auto-generated methods while preserving explicit user-defined ones."
          },
          {
            "reasoning": "Different inheritance patterns (abstract vs concrete) have distinct semantics for field overriding.",
            "action": "Verify behavior across abstract base classes (where overriding is valid) and avoid scenarios that Django disallows (concrete same-name override)."
          },
          {
            "reasoning": "Prevent regressions in behavior of existing features using choices and display methods.",
            "action": "Run focused and broader test suites around model fields and forms that rely on choices and get_FOO_display()."
          }
        ]
      },
      {
        "name": "Fix ORM Ordering Resolution Without Regressions",
        "description": "Resolve ordering bugs (e.g., inherited '-pk' ordering) by tracing direction propagation and applying minimal changes to avoid unrelated regressions.",
        "steps": [
          {
            "reasoning": "Understanding how direction (ASC/DESC) is propagated is key to fixing subtle ordering issues.",
            "action": "Trace flow in the compiler (e.g., find_ordering_name, get_order_dir) and identify where default order direction interacts with field names like 'pk'."
          },
          {
            "reasoning": "A direct change to direction propagation can break other query behaviors.",
            "action": "Attempt a minimal fix and immediately validate against known ordering and query tests to catch regressions early."
          },
          {
            "reasoning": "Upstream history often contains a minimal, safe resolution and rationale.",
            "action": "Consult repository history/commits for similar fixes and align with the approach that resolved edge cases (e.g., skip recursion when name == 'pk')."
          },
          {
            "reasoning": "Ensure both the reported bug and previously working behaviors remain correct.",
            "action": "Re-run targeted reproductions and broader suites (ordering, model_inheritance, queries) to confirm the fix."
          }
        ]
      },
      {
        "name": "Correct User-Facing Error Hints",
        "description": "Update error hint messages to reference the correct API, reflect current framework versions, and maintain clarity.",
        "steps": [
          {
            "reasoning": "Hints guide users; wrong API references mislead and cause confusion.",
            "action": "Search for the error string and confirm the surrounding validation logic to ensure the hint applies to the right condition."
          },
          {
            "reasoning": "API semantics evolve (e.g., symmetrical=False became unnecessary).",
            "action": "Update hint wording to use the correct field type and current arguments; remove outdated flags."
          },
          {
            "reasoning": "Tests often verify exact hint text; ensure alignment.",
            "action": "Adjust or add tests verifying the updated hint text and run the invalid models tests to validate."
          }
        ]
      }
    ],
    "type2_workflows": [
      {
        "name": "Search Codebase for Feature/Bug Location",
        "description": "Quickly locate relevant Django source and tests related to a reported issue.",
        "steps": [
          {
            "reasoning": "Find where the error message or function is defined to narrow down the fix location.",
            "action": "grep -r \"If you want to create a recursive relationship\" django/"
          },
          {
            "reasoning": "Open the file at the lines surrounding the match for context.",
            "action": "sed -n '1250,1350p' django/db/models/fields/related.py"
          },
          {
            "reasoning": "Find corresponding tests to understand expected behavior.",
            "action": "grep -rn \"E334\\|E335\" tests/"
          },
          {
            "reasoning": "Inspect test logic to confirm how the message is asserted.",
            "action": "sed -n '130,165p' tests/invalid_models_tests/test_relative_fields.py"
          }
        ]
      },
      {
        "name": "Set Up and Run a Standalone Django Reproduction Script",
        "description": "Create a minimal script to reproduce a bug without full test harness.",
        "steps": [
          {
            "reasoning": "Django needs settings configured before model import/use.",
            "action": "In a Python script: import django, from django.conf import settings; settings.configure(INSTALLED_APPS=[...], DATABASES=..., SECRET_KEY='x'); django.setup()"
          },
          {
            "reasoning": "Models defined outside apps must have an app_label to avoid registration issues.",
            "action": "Define models with class Meta: app_label = 'test_app'"
          },
          {
            "reasoning": "Ensure local Django source is used for reproduction.",
            "action": "Set PYTHONPATH=/workspace/django when running: PYTHONPATH=/workspace/django python test_script.py"
          },
          {
            "reasoning": "Confirm the issue by printing/inspecting behavior.",
            "action": "Trigger behavior (e.g., instance.get_FOO_display(), migration serialization output, queryset.query) and print results"
          }
        ]
      },
      {
        "name": "Run Django Tests (Focused and Broad) in Dev Environment",
        "description": "Install Django in editable mode and run selective test modules/cases.",
        "steps": [
          {
            "reasoning": "Editable install ensures the test runner imports your local changes.",
            "action": "cd /workspace/django && pip install -e ."
          },
          {
            "reasoning": "Use Django\u2019s test runner to run specific modules for fast iteration.",
            "action": "PYTHONPATH=/workspace/django tests/runtests.py migrations.test_writer -v 2"
          },
          {
            "reasoning": "Run broader suites to detect unintended regressions.",
            "action": "tests/runtests.py ordering model_inheritance queries -v 1"
          },
          {
            "reasoning": "Target individual failing tests to speed up debugging.",
            "action": "tests/runtests.py queries.tests.Queries1Tests.test_tickets_2076_7256 -v 2"
          }
        ]
      },
      {
        "name": "Implement Nested Type Serialization with __qualname__ Fallback",
        "description": "Modify serializer to correctly handle nested classes and local classes and verify with tests.",
        "steps": [
          {
            "reasoning": "Identify where class types are converted to strings.",
            "action": "Open django/db/migrations/serializer.py and locate TypeSerializer.serialize()"
          },
          {
            "reasoning": "Use fully qualified names for nested classes to serialize correctly.",
            "action": "Change code to use obj.__qualname__ instead of obj.__name__"
          },
          {
            "reasoning": "Avoid non-importable names for locally defined classes.",
            "action": "Add a fallback: if '<locals>' in qualname, use obj.__name__"
          },
          {
            "reasoning": "Verify new behavior against migration writer tests and custom scripts.",
            "action": "Run: tests/runtests.py migrations.test_writer -v 2; execute custom script that serializes nested enums/classes"
          }
        ]
      },
      {
        "name": "Resolve Module Boundaries in Deconstructible Path Serialization",
        "description": "Make _serialize_path find importable module path for nested attributes.",
        "steps": [
          {
            "reasoning": "Current split by last dot can misidentify module vs attribute for nested classes.",
            "action": "Open django/db/migrations/serializer.py and find DeconstructableSerializer._serialize_path"
          },
          {
            "reasoning": "Ensure the module part is importable by progressively testing prefixes.",
            "action": "Implement progressive import: iterate components left-to-right and import '.'.join(parts[:i]) until success; remaining parts form the attribute path"
          },
          {
            "reasoning": "Handle edge cases with no dots or invalid imports gracefully.",
            "action": "Add guards for paths without dots and exceptions during import to avoid breaking serialization"
          },
          {
            "reasoning": "Validate against realistic model/field deconstruct outputs.",
            "action": "Run custom scripts that call Field.deconstruct() and confirm resulting import statements are correct; then run migrations.test_writer"
          }
        ]
      },
      {
        "name": "Preserve Manual Overrides When Injecting get_FOO_display",
        "description": "Adjust Field.contribute_to_class to allow child overwrite of generated methods while preserving user methods.",
        "steps": [
          {
            "reasoning": "Find where get_%s_display is added to the class.",
            "action": "Open django/db/models/fields/__init__.py and locate contribute_to_class"
          },
          {
            "reasoning": "Avoid blocking reinjection due to inherited methods.",
            "action": "Replace hasattr(cls, method_name) with method_name not in cls.__dict__ condition"
          },
          {
            "reasoning": "Confirm the fix on a minimal example.",
            "action": "Run a script that defines an abstract base with choices and a child adding new choices; assert child_instance.get_FOO_display() returns labels for new values"
          },
          {
            "reasoning": "Verify regression safety.",
            "action": "Run: tests/runtests.py model_fields model_forms -v 1"
          }
        ]
      },
      {
        "name": "Fix Inherited '-pk' Ordering in ORM",
        "description": "Modify compiler to prevent incorrect direction flipping for '-pk' while preserving other ordering behaviors.",
        "steps": [
          {
            "reasoning": "Identify where Meta.ordering is resolved for related fields and primary key.",
            "action": "Open django/db/models/sql/compiler.py and locate find_ordering_name"
          },
          {
            "reasoning": "Avoid recursing into related ordering when ordering by 'pk' which maps to the primary key field.",
            "action": "Update recursion condition to include: and name != 'pk'"
          },
          {
            "reasoning": "Validate the specific bug fix.",
            "action": "Run a reproduction script that defines Parent.Meta.ordering=['-pk'] and queries Child; inspect queryset.query to ensure DESC"
          },
          {
            "reasoning": "Ensure no regressions in complex query ordering.",
            "action": "Run: tests/runtests.py ordering model_inheritance queries -v 1; re-run any previously failing query tests"
          }
        ]
      },
      {
        "name": "Update ManyToMany Recursive Relationship Error Hint",
        "description": "Correct the hint to reference ManyToManyField and remove outdated arguments.",
        "steps": [
          {
            "reasoning": "Find the offending hint string to edit.",
            "action": "grep -r \"recursive relationship\" django/db/models/fields/related.py"
          },
          {
            "reasoning": "Align hint with correct API and current version semantics.",
            "action": "Replace 'ForeignKey(\"%s\", symmetrical=False, through=\"%s\")' with 'ManyToManyField(\"%s\", through=\"%s\")' in both E334 and E335 cases"
          },
          {
            "reasoning": "Validate the message against tests that assert exact text.",
            "action": "Run: tests/runtests.py invalid_models_tests.test_relative_fields.RelativeFieldTests.test_ambiguous_relationship_model -v 2"
          },
          {
            "reasoning": "Ensure no other related validations are affected.",
            "action": "Run: tests/runtests.py many_to_many m2m_through m2m_recursive -v 1"
          }
        ]
      }
    ]
  },
  "Request Routing and HTTP Parsing": {
    "type1_workflows": [
      {
        "name": "Standards-Aware Parser Correction",
        "description": "Fix protocol parsing to comply with evolving RFC specifications (e.g., HTTP date parsing).",
        "steps": [
          {
            "reasoning": "Understanding the normative requirement prevents ad hoc fixes and ensures long-term correctness.",
            "action": "Identify and read the relevant RFC section describing the expected behavior, focusing on edge-case rules (e.g., RFC 7231 two-digit year interpretation)."
          },
          {
            "reasoning": "Localizing the implementation avoids broad, risky changes and speeds iteration.",
            "action": "Locate the parsing function in the codebase and inspect its current logic, especially hardcoded assumptions versus dynamic rules."
          },
          {
            "reasoning": "A correct fix must reflect the spec\u2019s conditional logic (e.g., relative to current time) rather than fixed ranges.",
            "action": "Design a replacement algorithm that uses dynamic context (e.g., current year + 50) and define precise boundary behavior."
          },
          {
            "reasoning": "Edge-case tests prevent regressions on tricky boundaries (e.g., 49, 50, 51 years ahead).",
            "action": "Draft comprehensive tests across formats and edge cases, including dynamic expectations based on the current year."
          },
          {
            "reasoning": "Validating across existing cases ensures no regressions in other supported date formats.",
            "action": "Run existing tests and add targeted checks for RFC1123, RFC850, and asctime inputs to ensure compatibility."
          },
          {
            "reasoning": "Verification under real runtime conditions validates both correctness and performance implications.",
            "action": "Execute the full or targeted test suite and compare outcomes before and after the change, iterating if discrepancies arise."
          }
        ]
      },
      {
        "name": "Route Resolution Regression Diagnosis",
        "description": "Diagnose and fix regressions in URL parameter handling (optional named groups and positional/keyword argument passing).",
        "steps": [
          {
            "reasoning": "Reproducing the issue ensures you are fixing the right problem and provides a baseline.",
            "action": "Construct a minimal URL pattern and view signature reflecting the bug (e.g., optional named group) and trigger the failing path."
          },
          {
            "reasoning": "Understanding how arguments are constructed from regex matches reveals the exact failure mode.",
            "action": "Inspect the URL matching/resolver path, focusing on how kwargs discard None and how positional args are formed when kwargs are empty."
          },
          {
            "reasoning": "A surgical fix reduces risk: only adjust the logic that introduces invalid arguments.",
            "action": "Refine args construction to exclude None entries while preserving documented behavior (e.g., ignore unnamed groups when named groups exist)."
          },
          {
            "reasoning": "Targeted tests validate both the original failure and guard against future regressions.",
            "action": "Add or run tests for optional named groups, mixed named/unnamed groups, and typical request resolution paths."
          },
          {
            "reasoning": "Ensuring compatibility with existing behaviors avoids breaking downstream applications.",
            "action": "Run a subset of URL-related and handler tests and confirm no changes in documented behavior beyond the intended fix."
          }
        ]
      },
      {
        "name": "Boundary-Focused Test Design for Temporal Logic",
        "description": "Design dynamic tests for time-relative parsing rules to ensure behavior stays correct over time.",
        "steps": [
          {
            "reasoning": "Time-relative logic changes as the current year advances; static fixtures can become invalid.",
            "action": "Compute expectations relative to the current UTC year (e.g., year <= now+50 rule) rather than hardcoding expected centuries."
          },
          {
            "reasoning": "Boundaries are where off-by-one and interpretation bugs appear.",
            "action": "Test values just below, at, and just above the threshold (e.g., now+49, now+50, now+51 equivalents) and extreme ends (00, 99)."
          },
          {
            "reasoning": "Cross-format coverage ensures parsing consistency.",
            "action": "Include cases for all supported date formats and verify identical year resolution when applicable."
          }
        ]
      },
      {
        "name": "Layered Verification and Regression Safety",
        "description": "Confirm fixes thoroughly by combining micro, component, and system-level checks.",
        "steps": [
          {
            "reasoning": "Quick feedback loops help catch glaring issues early.",
            "action": "Run lightweight, focused scripts or one-liners to validate the specific logic change."
          },
          {
            "reasoning": "Component-level tests catch nuanced interactions within the module.",
            "action": "Execute targeted test modules (e.g., utils_tests/test_http.py or urlpatterns_reverse)."
          },
          {
            "reasoning": "System-level tests provide confidence no broader regressions were introduced.",
            "action": "Run a broader set of related test suites (e.g., handlers, requests, generic views) and review failures."
          }
        ]
      }
    ],
    "type2_workflows": [
      {
        "name": "Locate and Inspect HTTP Date Parsing Logic",
        "description": "Find the implementation of HTTP date parsing and identify hardcoded logic.",
        "steps": [
          {
            "reasoning": "Quickly find the function definition and related code.",
            "action": "grep -rn \"parse_http_date\" django | head -20"
          },
          {
            "reasoning": "Open the suspected file to inspect the implementation.",
            "action": "sed -n '1,220p' django/utils/http.py | sed -n '1,220p'"
          },
          {
            "reasoning": "Confirm the presence of hardcoded year range logic.",
            "action": "grep -nE \"1900|2000|\\byear\\b\" django/utils/http.py"
          },
          {
            "reasoning": "Empirically verify current behavior before changing code.",
            "action": "python - << 'PY'\nfrom django.utils.http import parse_http_date\nfor d in [\"Sunday, 06-Nov-74 08:49:37 GMT\", \"Sunday, 06-Nov-85 08:49:37 GMT\", \"Sun Nov  6 08:49:37 0037\"]:\n    print(d, '->', parse_http_date(d))\nPY"
          }
        ]
      },
      {
        "name": "Implement RFC 7231 Two-Digit Year Rule and Validate",
        "description": "Apply the dynamic 50-year rule for two-digit years and validate with dynamic tests.",
        "steps": [
          {
            "reasoning": "Modify the mapping from two-digit years to full years per RFC 7231.",
            "action": "Edit django/utils/http.py: replace hardcoded ranges with logic:\n# Pseudocode in place\nfrom datetime import datetime\ncurrent_year = datetime.utcnow().year\n# if yy+2000 is > current_year + 50, use 1900+yy else 2000+yy"
          },
          {
            "reasoning": "Test boundary cases that reveal off-by-one issues.",
            "action": "python - << 'PY'\nfrom datetime import datetime\nfrom django.utils.http import parse_http_date\nnow = datetime.utcnow().year\nsamples = [0, 49, 50, 51, 69, 70, 85, 99]\nfor yy in samples:\n    s = f\"Sunday, 06-Nov-{yy:02d} 08:49:37 GMT\"\n    ts = parse_http_date(s)\n    print(s, '->', ts)\nPY"
          },
          {
            "reasoning": "Ensure other formats continue to work as expected.",
            "action": "python - << 'PY'\nfrom django.utils.http import parse_http_date\ncases = [\n    'Sun, 06 Nov 1994 08:49:37 GMT',\n    'Sunday, 06-Nov-94 08:49:37 GMT',\n    'Sun Nov  6 08:49:37 1994',\n]\nfor c in cases:\n    print(c, '->', parse_http_date(c))\nPY"
          }
        ]
      },
      {
        "name": "Reproduce Optional URL Param Bug with Minimal Script",
        "description": "Create a minimal Django setup to reproduce the optional named group crashing view invocation.",
        "steps": [
          {
            "reasoning": "Self-contained reproduction isolates the issue from project-specific factors.",
            "action": "python - << 'PY'\nfrom django.conf import settings\nfrom django.urls import re_path, resolve\nfrom django.http import HttpResponse\nsettings.configure(ROOT_URLCONF=__name__, DEBUG=True, SECRET_KEY='x')\n\ndef modules(request, format='html'):\n    return HttpResponse(format)\nurlpatterns = [re_path(r'^module/(?P<format>(html|json|xml))?/?$', modules)]\n\nfrom django.test import RequestFactory\nrf = RequestFactory()\nmatch = resolve('/module/')\nprint('args:', match.args, 'kwargs:', match.kwargs)\n# Attempt to call view like handler would\nresp = match.func(rf.get('/module/'), *match.args, **match.kwargs)\nprint('response:', resp.status_code)\nPY"
          },
          {
            "reasoning": "Inspect regex behavior to understand None propagation.",
            "action": "python - << 'PY'\nimport re\np = re.compile(r'^module/(?P<format>(html|json|xml))?/?$')\nfor path in ['module/', 'module/html/']:\n    m = p.match(path)\n    print(path, 'groupdict=', m.groupdict(), 'groups=', m.groups())\nPY"
          }
        ]
      },
      {
        "name": "Patch URL Resolver to Filter None Positional Args",
        "description": "Modify RegexPattern.match() so unmatched optional groups do not produce extra positional arguments.",
        "steps": [
          {
            "reasoning": "Identify the exact code constructing args/kwargs to implement a minimal, safe change.",
            "action": "sed -n '120,190p' django/urls/resolvers.py | nl | sed -n '145,170p'"
          },
          {
            "reasoning": "Exclude None values when forming positional args if no kwargs are present.",
            "action": "Edit django/urls/resolvers.py: change\nargs = () if kwargs else match.groups()\n# to\nargs = () if kwargs else tuple(g for g in match.groups() if g is not None)"
          },
          {
            "reasoning": "Verify the fix resolves the crash and preserves expected behavior.",
            "action": "python - << 'PY'\n# Re-run the minimal reproduction from earlier after patching\nfrom django.conf import settings\nfrom django.urls import re_path, resolve\nfrom django.http import HttpResponse\nsettings.configure(ROOT_URLCONF=__name__, DEBUG=True, SECRET_KEY='x')\n\ndef modules(request, format='html'):\n    return HttpResponse(format)\nurlpatterns = [re_path(r'^module/(?P<format>(html|json|xml))?/?$', modules)]\n\nfrom django.test import RequestFactory\nrf = RequestFactory()\nfor path in ['/module/', '/module/html/']:\n    match = resolve(path)\n    print('path:', path, 'args:', match.args, 'kwargs:', match.kwargs)\n    resp = match.func(rf.get(path), *match.args, **match.kwargs)\n    print('status:', resp.status_code)\nPY"
          }
        ]
      },
      {
        "name": "Run Targeted Django Test Suites",
        "description": "Execute specific Django test modules to validate routing and parsing behavior before and after patches.",
        "steps": [
          {
            "reasoning": "Installing in editable mode enables running Django tests against your working tree.",
            "action": "pip install -e ./django"
          },
          {
            "reasoning": "Running focused suites speeds feedback and isolates regressions.",
            "action": "python django/tests/runtests.py urlpatterns_reverse -v 2"
          },
          {
            "reasoning": "Handlers and requests suites exercise view dispatch and argument passing.",
            "action": "python django/tests/runtests.py handlers requests -v 1"
          },
          {
            "reasoning": "Run utils tests that may include HTTP date parsing checks.",
            "action": "python django/tests/runtests.py utils_tests -v 1"
          }
        ]
      }
    ]
  },
  "Developer Tooling (Autoreload and Test Framework)": {
    "type1_workflows": [
      {
        "name": "Harden exception handling in filesystem-based developer utilities",
        "description": "Robustly handle unexpected filesystem/path errors (e.g., ValueError from Path.resolve) in autoreloaders or watchers without crashing, and back it with tests.",
        "steps": [
          {
            "reasoning": "Start from the concrete failure context to avoid guesswork and pinpoint the code path raising the exception.",
            "action": "Use the error message or stack trace to identify the function and module where the exception originates."
          },
          {
            "reasoning": "Understanding the implementation around the failing call reveals current error handling gaps.",
            "action": "Open and read the implementation around the reported line(s); locate calls to filesystem/path APIs (e.g., Path.resolve)."
          },
          {
            "reasoning": "Determine which exceptions can surface in real environments so the code can handle them gracefully.",
            "action": "Audit and expand exception handling (e.g., catch ValueError alongside FileNotFoundError) to skip problematic entries instead of crashing."
          },
          {
            "reasoning": "Document intent for future maintainers and prevent accidental removal of necessary guards.",
            "action": "Add comments explaining why broader exceptions are caught (e.g., network mounts or embedded null bytes)."
          },
          {
            "reasoning": "Guard against regressions and confirm behavior without relying on flaky environments.",
            "action": "Add a regression test that mocks the problematic call (e.g., Path.resolve raising ValueError) and asserts graceful handling."
          },
          {
            "reasoning": "Ensure changes don\u2019t break unaffected functionality.",
            "action": "Run the existing test suite and targeted modules relevant to the change; iterate if failures arise."
          }
        ]
      },
      {
        "name": "Make test framework data restoration transactional",
        "description": "Resolve integrity errors during rollback deserialization by mirroring transactional behavior from similar code paths.",
        "steps": [
          {
            "reasoning": "Understanding the root cause (e.g., FK ordering plus lack of transaction) guides the minimal, correct fix.",
            "action": "Analyze how objects are deserialized/saved and identify assumptions about ordering or atomicity."
          },
          {
            "reasoning": "Established patterns in similar components (e.g., loaddata) provide a proven reference.",
            "action": "Compare with existing components that do similar work (loaddata) and note transactional patterns (transaction.atomic)."
          },
          {
            "reasoning": "Wrapping deserialization in a transaction ensures all-or-nothing behavior and defers constraints until end.",
            "action": "Wrap the deserialization/save loop in a transaction.atomic(using=alias) block."
          },
          {
            "reasoning": "Changes to transactional behavior can have wide impact; focused testing reduces risk.",
            "action": "Run relevant test suites (TransactionTestCase, migration data persistence, fixtures) to validate correctness and catch regressions."
          },
          {
            "reasoning": "Confirm applicability across supported backends and scenarios.",
            "action": "If available, run tests for multiple databases/backends and adjust if backend-specific issues arise."
          }
        ]
      },
      {
        "name": "Bootstrap and execute tests in large Python projects",
        "description": "Set up the environment and use project-specific runners to efficiently validate changes.",
        "steps": [
          {
            "reasoning": "Tests may rely on an editable install for import paths and plugin hooks.",
            "action": "Install the project in editable mode if imports fail or test runner can\u2019t locate modules."
          },
          {
            "reasoning": "Project-provided runners often handle settings, database setup, and test discovery.",
            "action": "Use the project\u2019s test runner script or documented command to run tests."
          },
          {
            "reasoning": "Quicker feedback loops speed up development and reduce flakiness.",
            "action": "Run the smallest targeted test modules first, then expand to broader suites once local checks pass."
          },
          {
            "reasoning": "Parallelism or environment issues can mask failures or cause flakiness.",
            "action": "Disable parallelism or adjust runner flags when debugging intermittent or order-dependent failures."
          }
        ]
      },
      {
        "name": "Create deterministic reproductions for environment-specific bugs",
        "description": "Simulate flaky or environment-dependent errors (e.g., filesystem anomalies) via mocking or standalone scripts to validate fixes.",
        "steps": [
          {
            "reasoning": "Direct reproduction in the real environment may be unreliable or hard to set up.",
            "action": "Create a minimal standalone script that exercises the failing function(s) with controlled inputs."
          },
          {
            "reasoning": "Mocking specific API calls (e.g., Path.resolve) isolates the failure mode without external dependencies.",
            "action": "Use mocks to force the error condition (e.g., raise ValueError) and assert expected behavior."
          },
          {
            "reasoning": "Fast feedback ensures the fix addresses the actual failure mode.",
            "action": "Run the standalone script/tests before and after the patch to confirm the change resolves the issue."
          },
          {
            "reasoning": "Prevent regressions by promoting the reproduction into the official test suite.",
            "action": "Integrate the reproduction as a unit test case using the project\u2019s testing conventions."
          }
        ]
      }
    ],
    "type2_workflows": [
      {
        "name": "Locate error sources and inspect surrounding code",
        "description": "Find the implementation and call sites for failing functions and inspect their context.",
        "steps": [
          {
            "reasoning": "Quickly find the relevant module implementing the feature (e.g., autoreloader).",
            "action": "find /workspace/django -type f -name \"autoreload.py\""
          },
          {
            "reasoning": "Identify exact usage of the problematic API to align with the stack trace.",
            "action": "grep -n \"resolve(\\|Path.resolve\" /workspace/django/django/utils/autoreload.py"
          },
          {
            "reasoning": "View the immediate context without opening a full editor to confirm control flow and error handling.",
            "action": "sed -n '130,200p' /workspace/django/django/utils/autoreload.py"
          },
          {
            "reasoning": "Check whether the error message is referenced elsewhere or has prior handling.",
            "action": "grep -R \"embedded null byte\" /workspace/django || true"
          },
          {
            "reasoning": "Read the full file to understand related helper functions and shared patterns.",
            "action": "sed -n '1,220p' /workspace/django/django/utils/autoreload.py"
          }
        ]
      },
      {
        "name": "Run Django\u2019s test suites and subsets",
        "description": "Execute targeted and broader tests using Django\u2019s test runner and ensure environment readiness.",
        "steps": [
          {
            "reasoning": "Editable install resolves imports and package metadata needed by the runner.",
            "action": "pip install -e /workspace/django"
          },
          {
            "reasoning": "Run a focused test module to validate changes quickly.",
            "action": "python /workspace/django/tests/runtests.py utils_tests.test_autoreload -v2"
          },
          {
            "reasoning": "Verify behavior across other relevant test areas.",
            "action": "python /workspace/django/tests/runtests.py test_utils.test_transactiontestcase -v2"
          },
          {
            "reasoning": "Test migration-related behavior affected by serialized rollback.",
            "action": "python /workspace/django/tests/runtests.py migration_test_data_persistence --verbosity=2"
          },
          {
            "reasoning": "Reduce flakiness and isolate failures when necessary.",
            "action": "python /workspace/django/tests/runtests.py test_utils.test_transactiontestcase migration_test_data_persistence --parallel=1"
          }
        ]
      },
      {
        "name": "Patch autoreloader to handle ValueError from Path.resolve",
        "description": "Modify autoreload.py to catch ValueError in file iteration functions and validate with a standalone reproduction.",
        "steps": [
          {
            "reasoning": "Open the implementation to adjust exception handling.",
            "action": "vi /workspace/django/django/utils/autoreload.py"
          },
          {
            "reasoning": "Broaden exception handling to skip problematic entries without crashing.",
            "action": "Change `except FileNotFoundError:` to `except (FileNotFoundError, ValueError):` in iter_modules_and_files() and sys_path_directories(); add a comment explaining embedded null bytes/network mounts."
          },
          {
            "reasoning": "Validate the failure mode and confirm the patch fixes it.",
            "action": "python /workspace/test_embedded_null_byte.py"
          },
          {
            "reasoning": "Ensure no regressions in existing tests.",
            "action": "python /workspace/django/tests/runtests.py utils_tests.test_autoreload -v2"
          }
        ]
      },
      {
        "name": "Wrap rollback deserialization in a transaction",
        "description": "Adjust deserialize_db_from_string to run inside transaction.atomic and verify via targeted suites.",
        "steps": [
          {
            "reasoning": "Open the backend creation module where deserialization occurs.",
            "action": "vi /workspace/django/django/db/backends/base/creation.py"
          },
          {
            "reasoning": "Import the transaction API needed for atomic blocks.",
            "action": "Modify imports to `from django.db import router, transaction`"
          },
          {
            "reasoning": "Ensure deserialization is all-or-nothing to avoid integrity errors.",
            "action": "Wrap the object save loop with `with transaction.atomic(using=alias):`"
          },
          {
            "reasoning": "Confirm that the intended changes are in place before running tests.",
            "action": "sed -n '1,150p' /workspace/django/django/db/backends/base/creation.py | sed -n '120,150p'"
          },
          {
            "reasoning": "Run relevant tests to verify correctness and catch regressions.",
            "action": "python /workspace/django/tests/runtests.py test_utils.test_transactiontestcase migration_test_data_persistence --verbosity=2"
          }
        ]
      },
      {
        "name": "Add a regression test with mocking for autoreload",
        "description": "Create a unit test that simulates Path.resolve raising ValueError to ensure the autoreloader handles it gracefully.",
        "steps": [
          {
            "reasoning": "Open the existing test module to add a new test case alongside related tests.",
            "action": "vi /workspace/django/tests/utils_tests/test_autoreload.py"
          },
          {
            "reasoning": "Simulate the environment-specific failure deterministically.",
            "action": "Add a test (e.g., test_iter_modules_and_files_handles_embedded_null_bytes) that patches pathlib.Path.resolve to raise ValueError(\"embedded null byte\") and asserts no crash/empty result."
          },
          {
            "reasoning": "Run only the modified module to get quick feedback.",
            "action": "python /workspace/django/tests/runtests.py utils_tests.test_autoreload -v2"
          }
        ]
      },
      {
        "name": "Repository-wide verification and diff review",
        "description": "Confirm applied changes and review their scope before finalizing.",
        "steps": [
          {
            "reasoning": "Audit the exact code modifications to ensure only intended changes are present.",
            "action": "git diff /workspace/django/django/utils/autoreload.py /workspace/django/django/db/backends/base/creation.py"
          },
          {
            "reasoning": "Run an expanded test set to catch unrelated regressions.",
            "action": "python /workspace/django/tests/runtests.py test_runner fixtures transactions --verbosity=1"
          }
        ]
      }
    ]
  },
  "Internationalization and Language Settings": {
    "type1_workflows": [
      {
        "name": "Diagnose configuration-vs-runtime inconsistency",
        "description": "Identify and reconcile mismatches between system checks and runtime behavior (e.g., translation fallback).",
        "steps": [
          {
            "reasoning": "You need to understand where the rule is enforced to know what to fix.",
            "action": "Locate the validation/check implementation and read its logic."
          },
          {
            "reasoning": "Runtime behavior (e.g., fallback resolution) defines the intended semantics.",
            "action": "Identify and study the runtime code that resolves language variants/fallbacks."
          },
          {
            "reasoning": "Documentation and tests define expected behavior and constraints.",
            "action": "Review docs and tests around the feature (e.g., language code fallback) to confirm expectations."
          },
          {
            "reasoning": "A clear mapping of check logic vs runtime logic reveals gaps causing false positives.",
            "action": "Compare the check's conditions to how runtime resolves languages and list discrepancies."
          }
        ]
      },
      {
        "name": "Design a minimal, behavior-preserving fix",
        "description": "Craft a change that aligns checks with runtime while minimizing risk and scope.",
        "steps": [
          {
            "reasoning": "Small, well-scoped changes reduce risk and ease review.",
            "action": "Target the conditional(s) that cause the misclassification rather than broad refactors."
          },
          {
            "reasoning": "Mirroring runtime semantics ensures consistency (e.g., base-language acceptance for sublanguages).",
            "action": "Align check logic with runtime variant resolution (e.g., exact match, base-language fallback, prefix handling)."
          },
          {
            "reasoning": "Edge cases (e.g., multi-segment tags like zh-hans-cn) frequently break naive logic.",
            "action": "Enumerate edge patterns and ensure the new logic handles them explicitly."
          },
          {
            "reasoning": "Backwards compatibility prevents new false negatives/positives.",
            "action": "Confirm unchanged behavior in unaffected paths and document any intentional behavior change."
          }
        ]
      },
      {
        "name": "Establish a reproducible failing case",
        "description": "Create a minimal example that demonstrates the issue and can verify the fix.",
        "steps": [
          {
            "reasoning": "A minimal reproducer accelerates debugging and validates correctness repeatedly.",
            "action": "Write a small script/test configuring only the necessary settings to trigger the issue."
          },
          {
            "reasoning": "Automating setup avoids environment-specific noise and errors.",
            "action": "Programmatically configure the framework (e.g., settings.configure) and run the relevant checks."
          },
          {
            "reasoning": "Capturing the exact error code ensures you\u2019re fixing the right issue.",
            "action": "Filter and assert on the specific check ID (e.g., translation.E004) in the output."
          }
        ]
      },
      {
        "name": "Iterative validation with targeted test suites",
        "description": "Validate changes incrementally to isolate regressions early.",
        "steps": [
          {
            "reasoning": "Targeted suites run quickly and focus on the area of change.",
            "action": "Run only the relevant test modules (e.g., check framework/i18n) before broader runs."
          },
          {
            "reasoning": "Broader suites catch unintended side effects.",
            "action": "Once targeted suites pass, run larger subsets or the full test suite."
          },
          {
            "reasoning": "Quick feedback loops reduce iteration time.",
            "action": "Repeat tests after each small code adjustment."
          }
        ]
      },
      {
        "name": "Edge-case driven expansion",
        "description": "Systematically uncover and address non-trivial cases in language tag handling.",
        "steps": [
          {
            "reasoning": "Language tags can be multi-part and nuanced; common pitfalls often appear in these cases.",
            "action": "List and test multi-segment variants (e.g., zh-hans-cn), region-specific codes (e.g., fr-ca), and generic prefixes."
          },
          {
            "reasoning": "Ensuring runtime and checks treat these uniformly prevents inconsistencies.",
            "action": "Verify both the system checks and runtime resolvers accept the same set of variants."
          },
          {
            "reasoning": "Prevent regressions by codifying these cases.",
            "action": "Add or update tests to cover each edge case explicitly."
          }
        ]
      },
      {
        "name": "Change verification and documentation",
        "description": "Summarize, verify, and communicate the changes made and their impact.",
        "steps": [
          {
            "reasoning": "Reviewing diffs ensures only intended lines changed.",
            "action": "Inspect the code diff for the modified files."
          },
          {
            "reasoning": "A clear summary speeds up review and future maintenance.",
            "action": "Document the problem, the changes, and verification results (including tests and manual checks)."
          },
          {
            "reasoning": "Visibility into verification increases confidence and reproducibility.",
            "action": "Include example inputs and outputs showing pre- and post-fix behavior."
          }
        ]
      },
      {
        "name": "Environment readiness for framework development",
        "description": "Prepare the environment to run framework tests and develop locally.",
        "steps": [
          {
            "reasoning": "Missing dependencies block tests and scripts.",
            "action": "Install all required runtime and test dependencies."
          },
          {
            "reasoning": "Editable installs and correct PYTHONPATH ensure your local changes are executed.",
            "action": "Install the project in editable mode or set PYTHONPATH to point to the working tree."
          },
          {
            "reasoning": "Consistency across runs reduces flakiness.",
            "action": "Standardize command invocations (e.g., use the project\u2019s test runner)."
          }
        ]
      }
    ],
    "type2_workflows": [
      {
        "name": "Locate translation check implementation and E004",
        "description": "Find where translation.E004 is defined and implemented.",
        "steps": [
          {
            "reasoning": "Identify files that contain the translation checks.",
            "action": "cd /workspace/django && find django -type f -name \"*.py\" | grep core/checks | xargs grep -n \"translation\""
          },
          {
            "reasoning": "Open the file to inspect the check logic and E004.",
            "action": "sed -n '1,200p' django/django/core/checks/translation.py"
          },
          {
            "reasoning": "Search tests referencing the specific check ID for expectations.",
            "action": "grep -R \"translation.E004\" tests/ --include=\"*.py\" -n"
          }
        ]
      },
      {
        "name": "Inspect runtime language fallback logic",
        "description": "Study how Django resolves language variants at runtime to mirror in checks.",
        "steps": [
          {
            "reasoning": "Find the module handling translation internals and fallback logic.",
            "action": "grep -R \"get_supported_language_variant\\|generic_lang_code\" django/django/utils/translation -n"
          },
          {
            "reasoning": "Open the relevant sections to understand exact behavior.",
            "action": "sed -n '1,150p' django/django/utils/translation/trans_real.py; sed -n '350,520p' django/django/utils/translation/trans_real.py"
          },
          {
            "reasoning": "Cross-reference public API usage.",
            "action": "sed -n '1,180p' django/django/utils/translation/__init__.py"
          }
        ]
      },
      {
        "name": "Run targeted tests for translation checks",
        "description": "Execute only the tests related to translation checks for quick feedback.",
        "steps": [
          {
            "reasoning": "Validate current behavior and identify failing expectations.",
            "action": "python tests/runtests.py check_framework.test_translation -v 2"
          },
          {
            "reasoning": "If using pytest is preferred or available, run the specific test.",
            "action": "pytest tests/check_framework/test_translation.py::TranslationCheckTests::test_inconsistent_language_settings -xvs"
          }
        ]
      },
      {
        "name": "Create and run a minimal reproduction script for translation.E004",
        "description": "Programmatically trigger the E004 system check to reproduce the issue.",
        "steps": [
          {
            "reasoning": "A small script isolates the failing condition without full test overhead.",
            "action": "cat > reproduce_issue.py << 'PY'\nfrom django.conf import settings\nfrom django.core.checks import run_checks\n\nif not settings.configured:\n    settings.configure(\n        SECRET_KEY='x',\n        INSTALLED_APPS=[],\n        USE_I18N=True,\n        LANGUAGE_CODE='de-at',\n        LANGUAGES=[('de', 'German')],\n    )\n\nerrors = [e for e in run_checks() if e.id.startswith('translation.E004')]\nprint('E004 count:', len(errors))\nfor e in errors:\n    print(e.id, e.msg)\nPY"
          },
          {
            "reasoning": "Run and confirm the error reproduces before fixing.",
            "action": "python reproduce_issue.py"
          },
          {
            "reasoning": "If imports fail due to missing dependencies, install them.",
            "action": "pip install asgiref pytz sqlparse"
          },
          {
            "reasoning": "Re-run after resolving dependencies to confirm reproduction.",
            "action": "python reproduce_issue.py"
          }
        ]
      },
      {
        "name": "Prepare development environment for running Django from source",
        "description": "Ensure local changes are used when running tests and scripts.",
        "steps": [
          {
            "reasoning": "Editable install makes Python import the local working tree.",
            "action": "cd /workspace/django && pip install -e ."
          },
          {
            "reasoning": "If not using editable install, set PYTHONPATH to include the source tree.",
            "action": "export PYTHONPATH=/workspace/django:$PYTHONPATH"
          },
          {
            "reasoning": "Confirm the Django version/source in use.",
            "action": "python -c \"import django,inspect; print(django.__version__, inspect.getsourcefile(django))\""
          }
        ]
      },
      {
        "name": "Implement and iterate on translation check fix",
        "description": "Modify the check to accept sublanguages when the base language is present and handle prefixes.",
        "steps": [
          {
            "reasoning": "Open the file to implement the change.",
            "action": "vi django/django/core/checks/translation.py"
          },
          {
            "reasoning": "Add logic: accept exact match; if '-' in LANGUAGE_CODE, accept if base is in LANGUAGES; also accept any LANGUAGES entry starting with base+'-'.",
            "action": "Edit the check function (e.g., check_language_settings_consistent) to mirror get_supported_language_variant semantics."
          },
          {
            "reasoning": "Quickly validate the fix against the minimal reproducer.",
            "action": "python reproduce_issue.py"
          },
          {
            "reasoning": "Test tricky variants align with runtime.",
            "action": "python - << 'PY'\nfrom django.conf import settings\nfrom django.utils.translation import get_supported_language_variant\nsettings.configure(SECRET_KEY='x', LANGUAGES=[('zh-hans',''),('de',''),('en','')])\nfor code in ['zh-hans-cn','de-at','en-us']:\n    print(code, '->', get_supported_language_variant(code, strict=False))\nPY"
          }
        ]
      },
      {
        "name": "Run targeted and broader test suites",
        "description": "Execute relevant test groups and escalate to broader coverage.",
        "steps": [
          {
            "reasoning": "Check only the relevant areas first for rapid feedback.",
            "action": "python tests/runtests.py check_framework i18n -v 1"
          },
          {
            "reasoning": "Confirm overall stability after targeted passes.",
            "action": "python tests/runtests.py -v 0"
          },
          {
            "reasoning": "Summarize outcomes quickly.",
            "action": "python tests/runtests.py check_framework i18n --verbosity=1 2>&1 | grep -E \"^(Ran|OK|FAILED)\""
          }
        ]
      },
      {
        "name": "Verify checks programmatically via run_checks and filter E004",
        "description": "Ensure translation.E004 no longer triggers for acceptable variants.",
        "steps": [
          {
            "reasoning": "Programmatic verification replicates production usage of system checks.",
            "action": "python - << 'PY'\nfrom django.conf import settings\nfrom django.core.checks import run_checks\nsettings.configure(SECRET_KEY='x', USE_I18N=True, LANGUAGE_CODE='de-at', LANGUAGES=[('de','German')])\nerrs = [e for e in run_checks() if e.id=='translation.E004']\nprint('translation.E004 found:', bool(errs))\nPY"
          },
          {
            "reasoning": "Test multiple scenarios to cover variants and direct matches.",
            "action": "python - << 'PY'\nfrom django.conf import settings\nfrom django.core.checks import run_checks\ncases=[('de-at',[('de','German')]), ('es-ar',[('es-ar','')]), ('zh-hans-cn',[('zh-hans','')])]\nfor code, langs in cases:\n    settings._wrapped=None\n    settings.configure(SECRET_KEY='x', USE_I18N=True, LANGUAGE_CODE=code, LANGUAGES=langs)\n    errs=[e for e in run_checks() if e.id=='translation.E004']\n    print(code, 'E004:', bool(errs))\nPY"
          }
        ]
      },
      {
        "name": "Review and present changes",
        "description": "Show what changed and summarize verification.",
        "steps": [
          {
            "reasoning": "A diff helps reviewers focus on the exact modifications.",
            "action": "git diff django/django/core/checks/translation.py"
          },
          {
            "reasoning": "A short report communicates impact and test results.",
            "action": "printf \"%s\\n\" \"Summary of fix, rationale, and test outcomes\" > VERIFICATION_REPORT.md && cat VERIFICATION_REPORT.md"
          }
        ]
      }
    ]
  },
  "Security and Error Reporting Sanitization": {
    "type1_workflows": [
      {
        "name": "Diagnose and Fix Sensitive Data Leakage in Exception Reports",
        "description": "Identify insufficient sanitization in error reporting and deliver a safe, regression-free fix.",
        "steps": [
          {
            "reasoning": "Understanding the code location and responsibility helps target the fix to the right component.",
            "action": "Locate the exception reporting filter implementation and review how settings are cleansed."
          },
          {
            "reasoning": "Tests reveal current behavior and constraints, guiding what changes are safe.",
            "action": "Explore existing tests related to exception reporting to learn expected sanitization."
          },
          {
            "reasoning": "A minimal reproduction clarifies the exact failure mode and confirms assumptions.",
            "action": "Create a focused script or scenario using nested settings structures to demonstrate the leak."
          },
          {
            "reasoning": "Before changing code, planning the approach avoids breaking behavior and preserves compatibility.",
            "action": "Design a recursive sanitization that handles dicts and non-dict iterables, preserving types and respecting sensitive keys."
          },
          {
            "reasoning": "Adding targeted tests prevents regressions and documents the newly supported scenarios.",
            "action": "Write tests covering lists, tuples, nested containers, and mixed structures with sensitive keys."
          },
          {
            "reasoning": "Running the suite ensures that the change integrates without impacting other components.",
            "action": "Execute relevant subsets and the broader test suite to validate the patch comprehensively."
          },
          {
            "reasoning": "Cleanup and summarization provide maintainability and transparency.",
            "action": "Remove temporary artifacts and document the fix rationale and coverage."
          }
        ]
      },
      {
        "name": "Design Robust Recursive Cleansing for Nested Data Structures",
        "description": "Extend a sanitize function to correctly handle nested dicts and iterable containers while preserving types.",
        "steps": [
          {
            "reasoning": "A precise definition of sensitive keys avoids over-sanitization and maintains useful debugging information.",
            "action": "Determine which keys (e.g., 'secret', 'token', 'password') should be redacted and at what nesting levels."
          },
          {
            "reasoning": "Understanding data shape diversity prevents blind spots (e.g., lists of dicts, tuples, mixed containers).",
            "action": "Enumerate supported structures: dicts, lists, tuples, possibly sets; decide recursion rules and type preservation."
          },
          {
            "reasoning": "Type-preserving transformations ensure downstream code and reports behave consistently.",
            "action": "Map the cleanse function over iterable items, reconstructing the same container type."
          },
          {
            "reasoning": "Avoiding mutation and maintaining immutability where expected reduces side effects.",
            "action": "Return new containers rather than mutating in place, unless framework conventions dictate otherwise."
          },
          {
            "reasoning": "Guarding recursion depth and unexpected types reduces the risk of performance issues or errors.",
            "action": "Include base cases for primitives and add defensive checks for unsupported or callable values."
          },
          {
            "reasoning": "Comprehensive tests across edge cases ensure reliability.",
            "action": "Test deep nesting, empty containers, mixed types, and values with both sensitive and non-sensitive keys."
          }
        ]
      },
      {
        "name": "Regression-Safe Patch Integration in Mature Codebases",
        "description": "Integrate changes with minimal disruption using targeted testing, tooling awareness, and verification.",
        "steps": [
          {
            "reasoning": "Knowing how the project\u2019s test runner is configured saves time and avoids false negatives.",
            "action": "Identify and use the project-preferred test runner and settings (e.g., Django\u2019s test command over pytest in some setups)."
          },
          {
            "reasoning": "Focusing on impacted modules speeds iteration and isolates failures.",
            "action": "Run subsets of tests relevant to the modified component (e.g., debug-related tests or specific test classes)."
          },
          {
            "reasoning": "Iterative verification from micro to macro catches issues early and confirms overall stability.",
            "action": "Start with custom reproduction tests, then module tests, and finally broader suite runs."
          },
          {
            "reasoning": "Visibility into changes helps reviewers and future maintainers.",
            "action": "Generate diffs of modified core and test files and provide succinct change notes."
          },
          {
            "reasoning": "Project hygiene avoids repository noise and confusion.",
            "action": "Remove temporary scripts and artifacts once the fix is validated."
          }
        ]
      }
    ],
    "type2_workflows": [
      {
        "name": "Locate Implementation and Related Tests",
        "description": "Find the target module and existing test coverage for exception reporting and sanitization.",
        "steps": [
          {
            "reasoning": "Navigating into the repository root ensures commands run in the correct context.",
            "action": "Terminal: cd /workspace/django \u2192 ls"
          },
          {
            "reasoning": "Opening the suspected module reveals current implementation details.",
            "action": "View file: django/views/debug.py"
          },
          {
            "reasoning": "Searching tests by keyword quickly surfaces existing behaviors and constraints.",
            "action": "Terminal: grep -R \"SafeExceptionReporterFilter\" tests"
          },
          {
            "reasoning": "Scanning the specific test file gives the expectations around cleanse_setting.",
            "action": "View file: tests/view_tests/tests/test_debug.py"
          },
          {
            "reasoning": "Pinpointing test names allows targeted runs during iteration.",
            "action": "Terminal: grep -n \"cleanse_setting\" tests/view_tests/tests/test_debug.py"
          }
        ]
      },
      {
        "name": "Create and Run a Reproduction for Nested Iterable Sanitization",
        "description": "Demonstrate the sanitization failure with lists/tuples containing dicts with sensitive keys.",
        "steps": [
          {
            "reasoning": "A minimal script reproduces the exact leak and serves as a quick validation tool.",
            "action": "Create file: reproduce_issue.py (construct settings with nested lists/tuples containing {'token': 'secret'} and print sanitized output)"
          },
          {
            "reasoning": "Ensuring the local package is importable allows the script to use the current code.",
            "action": "Terminal: pip install -e ."
          },
          {
            "reasoning": "Running the reproduction confirms the issue is present before changes.",
            "action": "Terminal: python reproduce_issue.py"
          }
        ]
      },
      {
        "name": "Implement Recursive Iterable Cleansing",
        "description": "Modify the sanitization to recurse into lists/tuples while preserving container type.",
        "steps": [
          {
            "reasoning": "Identifying where to implement recursion prevents scattered changes.",
            "action": "View file: django/views/debug.py (focus on cleanse_setting implementation)"
          },
          {
            "reasoning": "Adding a branch for iterable types introduces recursive cleansing while keeping dict handling intact.",
            "action": "Edit django/views/debug.py: add handling for (list, tuple) \u2192 map cleanse_setting over items \u2192 reconstruct list or tuple"
          },
          {
            "reasoning": "Quick local validation speeds iteration and catches obvious mistakes.",
            "action": "Terminal: python test_fix.py (custom tests hitting lists/tuples/mixed)"
          },
          {
            "reasoning": "Re-validate with the original reproduction to ensure the symptom is resolved.",
            "action": "Terminal: python reproduce_issue.py"
          }
        ]
      },
      {
        "name": "Run Targeted and Suite-Level Tests in Django",
        "description": "Use Django\u2019s test runner to validate changes without switching frameworks midstream.",
        "steps": [
          {
            "reasoning": "Running specific classes and modules accelerates feedback cycles.",
            "action": "Terminal: django test view_tests.tests.test_debug.ExceptionReporterFilterTests -v 2"
          },
          {
            "reasoning": "If initial attempts with pytest fail or mismatch environment, switch to Django\u2019s runner for consistency.",
            "action": "Conditional: If pytest errors or uses wrong settings \u2192 Terminal: django test view_tests.tests.test_debug -v 2"
          },
          {
            "reasoning": "Inspecting head/tail of test output quickly surfaces failure context.",
            "action": "Terminal: django test view_tests.tests.test_debug -v 2 | head \u2192 django test view_tests.tests.test_debug | tail"
          },
          {
            "reasoning": "Locating exact test function/class names helps granular troubleshooting.",
            "action": "Terminal: grep -n \"test_cleanse_setting_recurses_in_dictionary\" tests/view_tests/tests/test_debug.py \u2192 grep -n \"class .*Tests\" -n tests/view_tests/tests/test_debug.py"
          },
          {
            "reasoning": "Broad test runs ensure no regressions in related areas.",
            "action": "Terminal: django test view_tests -v 2"
          }
        ]
      },
      {
        "name": "Add New Tests and Verify",
        "description": "Extend the test suite with scenarios covering nested lists, tuples, and mixed structures.",
        "steps": [
          {
            "reasoning": "Placing new tests near existing ones keeps coverage discoverable and consistent.",
            "action": "Edit tests/view_tests/tests/test_debug.py: add tests for list/tuple/mixed recursive cleansing"
          },
          {
            "reasoning": "Running new test methods directly validates their correctness.",
            "action": "Terminal: django test view_tests.tests.test_debug.SafeExceptionReporterFilterTests.test_cleanse_setting_recurses_in_list -v 2 (repeat for each new test)"
          },
          {
            "reasoning": "Running the encompassing class confirms cohesive behavior.",
            "action": "Terminal: django test view_tests.tests.test_debug.SafeExceptionReporterFilterTests -v 2"
          }
        ]
      },
      {
        "name": "Produce Diffs and Clean Temporary Artifacts",
        "description": "Show changes clearly and keep the repository tidy.",
        "steps": [
          {
            "reasoning": "Diffs communicate the precise modifications for review.",
            "action": "Terminal: git diff django/views/debug.py \u2192 git diff tests/view_tests/tests/test_debug.py"
          },
          {
            "reasoning": "Removing temporary scripts avoids clutter and accidental commits.",
            "action": "Terminal: rm reproduce_issue.py test_fix.py test_edge_cases.py final_verification.py"
          }
        ]
      }
    ]
  }
}