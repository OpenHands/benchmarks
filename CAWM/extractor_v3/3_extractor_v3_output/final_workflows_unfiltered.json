{
  "type1_workflows": [
    {
      "name": "Debugging Django Migration Serialization of Nested Classes and Enums",
      "description": "Identify and fix incorrect serialization paths in migrations for nested classes and enums so that makemigrations produces importable, qualified references.",
      "steps": [
        "Step 1: Examine the models using nested classes or enums and define the expected serialized import paths",
        "Step 2: Create a minimal reproduction script or temporary app that triggers makemigrations-like serialization",
        "Step 3: Inspect django/db/migrations/serializer.py to understand TypeSerializer and DeconstructableSerializer behavior",
        "Step 4: Verify how Field.deconstruct() returns path tuples and how the serializer splits module and name",
        "Step 5: Implement a fix to use __qualname__ for nested types and detect the actual module boundary for import generation",
        "Step 6: Add a fallback to __name__ for local classes when __qualname__ includes '<locals>'",
        "Step 7: Run migration writer and serializer tests to validate expected outputs and catch regressions",
        "Step 8: Simulate makemigrations on a temporary app and confirm qualified paths and imports are correct",
        "Step 9: Iterate on the fix until all targeted and broader migration tests pass"
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12125"
      ]
    },
    {
      "name": "Fixing get_FOO_display with Inherited Choices in Model Fields",
      "description": "Ensure get_FOO_display uses the child model\u2019s overridden or extended choices and preserves manual overrides when inheriting from abstract base models.",
      "steps": [
        "Step 1: Reproduce the issue with an abstract base model defining choices and a child model extending those choices",
        "Step 2: Confirm get_FOO_display returns the raw value for new choices by printing or asserting the outputs",
        "Step 3: Locate Model._get_FIELD_display in django/db/models/base.py and Field.contribute_to_class in django/db/models/fields/__init__.py",
        "Step 4: Analyze how the display method is attached during class construction and how inheritance affects it",
        "Step 5: Adjust contribute_to_class to set the display method only if it isn\u2019t explicitly overridden in the current class (e.g., check cls.__dict__)",
        "Step 6: Validate that child models now use extended choices and that manual get_FOO_display overrides remain intact",
        "Step 7: Run model_fields, model_inheritance, and model_forms tests to ensure no regressions"
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12284"
      ]
    },
    {
      "name": "Resolving Inherited Meta.ordering Issues across Multi-Table Inheritance",
      "description": "Diagnose and correct incorrect SQL ORDER BY direction when inheriting Meta.ordering from a parent model, ensuring stable and predictable ordering across relations.",
      "steps": [
        "Step 1: Inspect model definitions where a parent sets Meta.ordering and a child inherits it",
        "Step 2: Create a minimal test case and print the generated SQL to verify the ordering direction",
        "Step 3: Explore django/db/models/sql/compiler.py to find find_ordering_name and related ordering logic",
        "Step 4: Understand get_order_dir parsing and how default_order propagates through relation recursion",
        "Step 5: Implement a targeted fix that avoids flipping order for special cases like 'pk' (e.g., skip relation recursion when name == 'pk')",
        "Step 6: Run ordering, model_inheritance, and queries test suites to detect regressions",
        "Step 7: If necessary, consult upstream commits for prior fixes and align with established approaches",
        "Step 8: Verify complex ordering chains across related models still behave as expected"
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12470"
      ]
    },
    {
      "name": "Correcting Misleading Error Hints for Relationship Configuration",
      "description": "Update developer-facing error hints to reference the correct API and remove outdated or irrelevant keywords for relation validation errors.",
      "steps": [
        "Step 1: Reproduce the validation error by defining an intermediary model with ambiguous ForeignKeys and missing through_fields",
        "Step 2: Search the codebase for the error message hint to identify its source in related field checks",
        "Step 3: Verify the context of occurrence (E334/E335) and ensure the hint accurately reflects ManyToManyField configuration",
        "Step 4: Update the hint string to reference ManyToManyField with through and omit outdated symmetrical=False",
        "Step 5: Adjust existing tests that assert the hint text to match the corrected message",
        "Step 6: Run invalid_models_tests and ManyToMany-related suites to confirm correctness and no regressions",
        "Step 7: Document the change and its rationale for future maintainers"
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12497"
      ]
    },
    {
      "name": "Diagnosing and Fixing Django HTTP Parsing and URL Resolver Issues with Minimal Reproductions",
      "description": "A general strategy to ensure HTTP utilities adhere to RFC specifications and URL resolver behavior is correct for optional regex groups, using concise, script-based reproductions.",
      "steps": [
        "Step 1: Review the relevant RFCs (e.g., RFC 7231, RFC 2822) and clarify expected behavior for edge cases such as two-digit years",
        "Step 2: Configure lightweight Django settings programmatically (e.g., ROOT_URLCONF) within a single script to avoid full project overhead",
        "Step 3: Dynamically define a minimal URLConf with patterns (including optional named groups) and a simple view to isolate resolver behavior",
        "Step 4: Verify Python regex behavior with the chosen patterns to understand groupdict/groups outputs, especially None values for unmatched optional groups",
        "Step 5: Locate the implementations in Django (e.g., django/utils/http.py for date parsing and django/urls/resolvers.py for URL resolving) and identify logic that deviates from the spec or expected behavior",
        "Step 6: Design fixes: adhere to RFC parsing (e.g., two-digit year handling based on current UTC year and boundary conditions) and adjust URL resolver to filter out None values or correct args/kwargs precedence for optional groups",
        "Step 7: Implement changes with minimal impact and clear comments, ensuring maintainable code and defensive handling of edge cases",
        "Step 8: Validate using the minimal reproduction scripts and additional edge cases (date formats, named vs. unnamed groups, presence/absence of optional segments)",
        "Step 9: Run Django\u2019s HTTP and URL-related test suites to ensure no regressions introduced",
        "Step 10: Document the root causes, fixes, and outcomes to aid future maintenance"
      ],
      "source_clusters": [
        "HTTP and URL Handling"
      ],
      "source_trajectories": [
        "django__django-11848",
        "django__django-12184"
      ]
    },
    {
      "name": "Reconciling i18n System Checks with Runtime Language Resolution and Validating Settings",
      "description": "A comprehensive strategy to align Django\u2019s i18n system checks with runtime language fallback behavior and validate LANGUAGE_CODE/LANGUAGES settings using iterative, minimal reproductions.",
      "steps": [
        "Step 1: Survey the codebase to locate both the system check implementation and the runtime utilities for language resolution (e.g., get_supported_language_variant)",
        "Step 2: Read the system check logic to understand its assumptions and conditions that trigger errors and warnings",
        "Step 3: Inspect runtime translation resolution code and documentation to understand documented fallback behavior (base and variant fallbacks)",
        "Step 4: Create a minimal standalone script that configures minimal Django settings (LANGUAGE_CODE, LANGUAGES) to deterministically reproduce mismatches between checks and runtime behavior",
        "Step 5: Execute the script to confirm the issue manifests with the specific settings; ensure environment dependencies are installed",
        "Step 6: Implement a minimal change to the system check to match runtime expectations, starting with the most common fallback cases",
        "Step 7: Expand the fix to cover edge cases, such as prefix-based variants and special language codes; adjust settings or check logic as appropriate",
        "Step 8: Add tests covering exact matches, fallback matches, and invalid configurations to prevent regressions",
        "Step 9: Integrate verification using Django\u2019s test runner and run the check_framework and i18n test subsets to validate changes",
        "Step 10: Summarize and record the fix, rationale, and verification steps for future reference"
      ],
      "source_clusters": [
        "Internationalization and Translation Validation"
      ],
      "source_trajectories": [
        "django__django-12286"
      ]
    },
    {
      "name": "Diagnosing and Fixing Non-Transactional Deserialization and Validating Rollback Behavior",
      "description": "Identify and fix issues where data deserialization occurs outside transactional boundaries, causing FK integrity errors and rollback failures, and navigate Django\u2019s test suites to validate changes.",
      "steps": [
        "Step 1: Define simple models with foreign key relationships and create their tables using a schema editor",
        "Step 2: Serialize objects in an order that places FK-dependent objects before their referenced objects",
        "Step 3: Write a script to deserialize and save the objects without using a transaction and observe the integrity error",
        "Step 4: Modify the script to wrap deserialization and saves in transaction.atomic for the specific database alias and confirm successful execution",
        "Step 5: Reproduce the problem by running the smallest relevant test module or creating a minimal script that triggers FK integrity errors during deserialization",
        "Step 6: Locate the code path responsible for deserialization in the repository and confirm how it is invoked by the failing test or setup routine; compare with management commands (e.g., loaddata) for transaction handling patterns",
        "Step 7: Design and implement a minimal fix that wraps the deserialization and object saving loop in a transaction.atomic context",
        "Step 8: Identify relevant test modules and classes (e.g., TransactionTestCase, fixtures, migration persistence) by searching for rollback/serialization keywords",
        "Step 9: Run targeted tests with increased verbosity; if tests are flaky or environment-sensitive, reduce parallelism to 1 to simplify diagnostics",
        "Step 10: Expand to adjacent suites (test_runner, transactions, fixtures) to check for regressions, using single-test or single-class runs to isolate failures and iterate quickly",
        "Step 11: Confirm stability by re-running combined suites and capture results in a verification summary",
        "Step 12: Document the change, rationale, and test results; verify diffs to ensure only intended modifications were introduced"
      ],
      "source_clusters": [
        "Testing and Transaction Rollback"
      ],
      "source_trajectories": [
        "django__django-12453"
      ]
    },
    {
      "name": "Debugging Development Autoreloader and File Watching Errors",
      "description": "Identify and fix crashes or misbehavior in Django\u2019s development autoreloader by introducing defensive handling without disrupting file watching functionality.",
      "steps": [
        "Step 1: Review the error stack trace to identify the failing module and line number; if a stack trace is unavailable, search for the error string in the repository",
        "Step 2: Locate the relevant source file (e.g., django/utils/autoreload.py) and read the surrounding code to understand how paths or modules are collected and resolved",
        "Step 3: Identify risky operations (e.g., Path.resolve()) and assess current exception handling for invalid inputs or rare filesystem states",
        "Step 4: Design a defensive fix that gracefully skips problematic inputs (e.g., catch ValueError alongside FileNotFoundError) while preserving normal behavior",
        "Step 5: Create a minimal reproduction (e.g., mock Path.resolve() to raise the observed exception) to validate the fix deterministically",
        "Step 6: Implement the fix with minimal, targeted changes and ensure it covers all relevant call sites",
        "Step 7: Add unit tests that simulate the failure mode and assert the autoreloader continues without crashing",
        "Step 8: Run targeted and broader test suites to ensure the fix introduces no regressions",
        "Step 9: Clean up any temporary scripts and document the change for future maintainers"
      ],
      "source_clusters": [
        "Developer Tooling and Debugging"
      ],
      "source_trajectories": [
        "django__django-11583"
      ]
    },
    {
      "name": "Strengthening Exception Reporting Sanitization Across Nested Structures",
      "description": "Ensure Django\u2019s SafeExceptionReporterFilter properly cleanses sensitive values in nested settings structures, including lists and tuples, while preserving container types.",
      "steps": [
        "Step 1: Examine the implementation of SafeExceptionReporterFilter (e.g., cleanse_setting) to understand current recursion and type handling",
        "Step 2: Review existing tests to see what is covered and identify gaps in list/tuple recursion and type preservation",
        "Step 3: Create a minimal settings configuration with nested lists/tuples containing sensitive keys to reproduce the sanitization gap",
        "Step 4: Design a fix to recursively cleanse dicts and iterables, preserve container types, and avoid recursing into strings/bytes",
        "Step 5: Implement the fix by extending cleanse_setting to handle lists/tuples and maintain original types",
        "Step 6: Add tests for lists, nested lists, tuples, and mixed structures to comprehensively validate sanitization behavior",
        "Step 7: Run the relevant test modules/classes using Django\u2019s test runner with appropriate settings to verify the changes",
        "Step 8: Verify behavior with standalone scripts and remove any temporary files after validation"
      ],
      "source_clusters": [
        "Developer Tooling and Debugging"
      ],
      "source_trajectories": [
        "django__django-12700"
      ]
    }
  ],
  "type2_workflows": [
    {
      "name": "Code Location and Inspection Toolbox",
      "description": "Quickly locate features, functions, errors, and surrounding context in Django\u2019s source, and find related tests.",
      "steps": [
        {
          "reasoning": "Need to locate where a specific message or feature is implemented to understand or change it",
          "action": "grep -r \"{search_phrase}\" /workspace/django/django/ --line-number"
        },
        {
          "reasoning": "Once a matching file is found, inspect surrounding context to understand conditions and usage",
          "action": "sed -n '{start_line},{end_line}p' /workspace/django/django/{path_to_file}"
        },
        {
          "reasoning": "Need to locate the exact file and function definition to inspect current logic.",
          "action": "grep -Rn \"def {function_name}\" {repo_root}/django | head -10"
        },
        {
          "reasoning": "Open the identified file to review the implementation details around the function.",
          "action": "sed -n '{start_line},{end_line}p' {repo_root}/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Quickly jump to the function within the file to focus on its logic.",
          "action": "grep -n \"{function_name}\" {repo_root}/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Start from the observed error to pinpoint where in the codebase the failure occurs.",
          "action": "cd {repo_root} && grep -R \"{error_keyword}\" -n django | head -20"
        },
        {
          "reasoning": "If the failing module is known, find the exact file path for inspection.",
          "action": "cd {repo_root} && find django -type f -name \"{module_file_name}\" | head -5"
        },
        {
          "reasoning": "Locate specific function calls or patterns (e.g., Path.resolve) to narrow down the problematic region.",
          "action": "cd {repo_root} && grep -n \"{pattern}\" django/{relative_module_path}"
        },
        {
          "reasoning": "Inspect surrounding lines to understand current logic and exception handling.",
          "action": "sed -n '{start_line},{end_line}p' {repo_root}/django/{relative_module_path}"
        },
        {
          "reasoning": "Discover related tests to assess existing coverage and plan new tests.",
          "action": "cd {repo_root} && find tests -name \"*{module_or_feature_keyword}*\" -type f | xargs grep -l \"{class_or_function_name}\""
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs",
        "HTTP and URL Handling",
        "Developer Tooling and Debugging"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-12497",
        "django__django-11848",
        "django__django-12184",
        "django__django-11583",
        "django__django-12700"
      ]
    },
    {
      "name": "Running Targeted Django Tests Across Runners",
      "description": "Execute focused Django tests using multiple runners and strategies, with options for specific modules, classes, methods, and settings.",
      "steps": [
        {
          "reasoning": "Run a specific app's tests to verify behavior related to the change",
          "action": "cd /workspace/django/tests && python runtests.py {module_name} --verbosity=2"
        },
        {
          "reasoning": "Run a specific test class or test method to validate a focused scenario",
          "action": "cd /workspace/django/tests && python runtests.py {module_name}.{TestClassName}.{test_method} --verbosity=2"
        },
        {
          "reasoning": "Run multiple related modules to check for cross-module regressions",
          "action": "cd /workspace/django/tests && python runtests.py {module1} {module2} {module3} --verbosity=1"
        },
        {
          "reasoning": "Verify a fix in a focused area by running only the relevant test suite.",
          "action": "cd {repo_root}/django && python tests/runtests.py {module_name} -v 2"
        },
        {
          "reasoning": "Run a specific test case or class when narrowing down behavior or regressions.",
          "action": "cd {repo_root}/django && python tests/runtests.py {module_name}.{test_class_or_method} --settings={settings_module} -v 2"
        },
        {
          "reasoning": "Optionally install Django in editable mode to simplify imports and environment setup for tests.",
          "action": "cd {repo_root}/django && pip install -e ."
        },
        {
          "reasoning": "Use Django\u2019s custom test runner to run a specific test module with verbose output.",
          "action": "cd {repo_root}/tests && python runtests.py {module_name} --settings={settings_module} -v 2"
        },
        {
          "reasoning": "Run a specific test class or method via django-admin test when the repo is installed or importable.",
          "action": "cd {repo_root}/tests && python -m django test {full_test_path} --settings={settings_module} -v 2"
        },
        {
          "reasoning": "If imports fail due to environment issues, install the repository in editable mode first.",
          "action": "cd {repo_root} && pip install -e ."
        },
        {
          "reasoning": "As a fallback, run tests directly via unittest for simple modules or local checks.",
          "action": "cd {repo_root} && python -m unittest {python_test_module_path}"
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs",
        "HTTP and URL Handling",
        "Developer Tooling and Debugging"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-12284",
        "django__django-12470",
        "django__django-12497",
        "django__django-11848",
        "django__django-12184",
        "django__django-11583",
        "django__django-12700"
      ]
    },
    {
      "name": "Setting Up Local Django Environment for Development and Tests",
      "description": "Install Django in editable mode and ensure required dependencies are present.",
      "steps": [
        {
          "reasoning": "Use Django from the local source tree and allow modifications to be tested immediately",
          "action": "cd /workspace/django && python -m pip install -e ."
        },
        {
          "reasoning": "Install core Django runtime dependencies needed for test execution",
          "action": "python -m pip install asgiref sqlparse pytz"
        },
        {
          "reasoning": "Ensure Python can import the local Django package during scripts",
          "action": "export PYTHONPATH=/workspace/django"
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-12284",
        "django__django-12497"
      ]
    },
    {
      "name": "Creating a Minimal Reproduction Script with Django Setup",
      "description": "Build a standalone script to reproduce an issue and inspect behavior (e.g., serialization, ordering, display).",
      "steps": [
        {
          "reasoning": "Configure Django settings in-process to allow model definitions and operations",
          "action": "python -c \"from django.conf import settings; settings.configure(INSTALLED_APPS=['django.contrib.contenttypes'], DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}}); import django; django.setup(); print('OK')\""
        },
        {
          "reasoning": "Define minimal models that trigger the problem and print relevant outputs (SQL, serialized paths, display values)",
          "action": "Create {script_path} containing model definitions and calls to .objects.all().query or serializer_factory; run: python {script_path}"
        },
        {
          "reasoning": "If the script needs to import local Django source, ensure the path is on sys.path",
          "action": "Run the script with: PYTHONPATH=/workspace/django python {script_path}"
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-12284",
        "django__django-12470"
      ]
    },
    {
      "name": "Inspecting and Adjusting Migration Serialization Logic",
      "description": "Trace how Django migrations serialize classes and fields, and implement qualified name fixes.",
      "steps": [
        {
          "reasoning": "Find where Django serializes deconstructible objects and types used in migrations",
          "action": "grep -n \"serializer\" /workspace/django/django/db/migrations/serializer.py"
        },
        {
          "reasoning": "Verify if nested classes are serialized using __name__ instead of __qualname__",
          "action": "grep -n \"__qualname__\\|__name__\" /workspace/django/django/db/migrations/serializer.py"
        },
        {
          "reasoning": "Open TypeSerializer and DeconstructableSerializer to implement the fix",
          "action": "Open /workspace/django/django/db/migrations/serializer.py in your editor and update TypeSerializer to use __qualname__ with a '<locals>' fallback; adjust _serialize_path to detect module boundary via importlib"
        },
        {
          "reasoning": "Validate changes using migration writer tests for serialization outputs",
          "action": "cd /workspace/django && PYTHONPATH=/workspace/django python tests/runtests.py migrations.test_writer --verbosity=2"
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12125"
      ]
    },
    {
      "name": "Tracing and Fixing SQL ORDER BY Resolution in Compiler",
      "description": "Identify how ORDER BY is resolved across relations and implement a targeted fix without regressions.",
      "steps": [
        {
          "reasoning": "Locate the function that resolves ordering names across relations",
          "action": "grep -n \"find_ordering_name\" /workspace/django/django/db/models/sql/compiler.py"
        },
        {
          "reasoning": "Inspect get_order_dir handling of '-' prefixes and default orders",
          "action": "grep -n \"def get_order_dir\" /workspace/django/django/db/models/sql/query.py && sed -n '{start_line},{end_line}p' /workspace/django/django/db/models/sql/query.py"
        },
        {
          "reasoning": "Apply a precise condition to avoid relation recursion for 'pk' names to preserve descending order",
          "action": "Open /workspace/django/django/db/models/sql/compiler.py and modify the conditional in find_ordering_name to include: and name != 'pk'"
        },
        {
          "reasoning": "Run ordering and queries tests to verify the fix and check for regressions",
          "action": "cd /workspace/django/tests && python runtests.py ordering queries --verbosity=2"
        },
        {
          "reasoning": "Optionally consult upstream commits to align with prior fixes and rationale",
          "action": "cd /workspace/django && git log -p --all -S \"find_ordering_name(\" -- django/db/models/sql/compiler.py"
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12470"
      ]
    },
    {
      "name": "Diagnosing and Fixing Optional Regex Groups in URL Resolver",
      "description": "Investigate Python regex behavior for optional groups, validate Django URL resolution, apply a minimal fix, and run tests.",
      "steps": [
        {
          "reasoning": "Verify whether optional groups produce None values that could be incorrectly propagated.",
          "action": "python -c 'import re; p = re.compile(r\"{pattern}\"); m = p.search(\"{path}\"); print(\"groupdict:\", m.groupdict()); print(\"groups:\", m.groups())'"
        },
        {
          "reasoning": "Compare behavior with and without the optional group present to understand boundary cases.",
          "action": "python -c 'import re; p = re.compile(r\"{pattern}\"); m1 = p.search(\"{path_without_optional}\"); m2 = p.search(\"{path_with_optional}\"); print(\"no optional:\", m1.groupdict(), m1.groups()); print(\"with optional:\", m2.groupdict(), m2.groups())'"
        },
        {
          "reasoning": "Set up a lightweight Django environment that can resolve URLs without a full project.",
          "action": "python -c \"import sys, types; sys.path.insert(0, '{repo_root}/django'); from django.conf import settings; settings.configure(DEBUG=True, ROOT_URLCONF='test_urls', ALLOWED_HOSTS=['*'], INSTALLED_APPS=['django.contrib.contenttypes']); import django; django.setup(); print('OK'); test_urls = types.ModuleType('test_urls'); def {view_name}(request, {param_name}='{default_value}'): return f'{param_name}: {{{param_name}}}'; test_urls.{view_name} = {view_name}; from django.urls import re_path; test_urls.urlpatterns = [re_path(r'{regex_pattern}', {view_name}, name='{url_name}')]; sys.modules['test_urls'] = test_urls; from django.urls import resolve; rm1 = resolve('{path1}'); print('Args1:', rm1.args, 'Kwargs1:', rm1.kwargs); rm2 = resolve('{path2}'); print('Args2:', rm2.args, 'Kwargs2:', rm2.kwargs)\""
        },
        {
          "reasoning": "Fix URL resolver fallback when optional groups are present by ignoring None values.",
          "action": "sed -i \"s/args = () if kwargs else match.groups()/args = () if kwargs else tuple(g for g in match.groups() if g is not None)/\" {repo_root}/django/django/urls/resolvers.py"
        },
        {
          "reasoning": "Verify a fix in a focused area by running only the relevant test suite.",
          "action": "cd {repo_root}/django && python tests/runtests.py {module_name} -v 2"
        }
      ],
      "source_clusters": [
        "HTTP and URL Handling"
      ],
      "source_trajectories": [
        "django__django-12184",
        "django__django-11848"
      ]
    },
    {
      "name": "Adjusting HTTP Date Parsing Logic per RFC and Verifying",
      "description": "Update two-digit year handling in RFC850 date parsing and verify across formats via a script.",
      "steps": [
        {
          "reasoning": "Update century selection logic to use a dynamic comparison against the current year plus 50 years as per RFC 7231.",
          "action": "sed -i \"s/if year < 70:\\n\\s*year += 2000\\n\\s*else:\\n\\s*year += 1900/ current_year = datetime.datetime.utcnow().year\\n            if 2000 + year > current_year + 50:\\n                year += 1900\\n            else:\\n                year += 2000/\" {repo_root}/django/django/utils/http.py"
        },
        {
          "reasoning": "Ensure the fix doesn\u2019t regress other formats and correctly handles two-digit years according to the RFC.",
          "action": "python -c \"import sys; sys.path.insert(0, '{repo_root}/django'); from django.utils.http import parse_http_date; from datetime import datetime; cases = ['Sun, 06 Nov 1994 08:49:37 GMT', 'Sunday, 06-Nov-70 08:49:37 GMT', 'Sun Nov  6 08:49:37 0037']; for c in cases: ts = parse_http_date(c); print(c, '->', datetime.utcfromtimestamp(ts))\""
        }
      ],
      "source_clusters": [
        "HTTP and URL Handling"
      ],
      "source_trajectories": [
        "django__django-11848",
        "django__django-12184"
      ]
    },
    {
      "name": "Validating Translation System Checks and Fallbacks",
      "description": "Locate translation checks (e.g., E004), compare with runtime language fallback behavior, create a reproduction, and run targeted tests.",
      "steps": [
        {
          "reasoning": "Identify translation-related modules to locate system check implementations for language validation.",
          "action": "cd {repo_root}/django && find . -type f -name \"*.py\" | grep -i \"translation\""
        },
        {
          "reasoning": "Pinpoint the specific system check that raises E004 to understand its triggering conditions.",
          "action": "cd {repo_root}/django && grep -r \"translation.E004\" django/core/checks/ --include=\"*.py\""
        },
        {
          "reasoning": "Inspect the code of the translation system check to see how LANGUAGE_CODE is validated.",
          "action": "sed -n '1,200p' {repo_root}/django/django/core/checks/translation.py"
        },
        {
          "reasoning": "Compare system check logic with runtime resolution to ensure the check reflects actual behavior.",
          "action": "sed -n '1,120p' {repo_root}/django/django/utils/translation/trans_real.py"
        },
        {
          "reasoning": "Search for variant fallback code to see how generic language codes are derived and matched.",
          "action": "grep -n \"split('-')\" {repo_root}/django/django/utils/translation/trans_real.py"
        },
        {
          "reasoning": "Inspect sections that derive generic language codes and perform prefix-based matches for variants.",
          "action": "grep -n \"generic_lang_code\" {repo_root}/django/django/utils/translation/trans_real.py || sed -n '400,500p' {repo_root}/django/django/utils/translation/trans_real.py"
        },
        {
          "reasoning": "Confirm the issue by configuring Django with specific LANGUAGE_CODE and LANGUAGES and running the relevant check.",
          "action": "printf \"%s\\n\" \"from django.conf import settings\" \"from django.core.checks.translation import check_language_settings_consistent\" \"settings.configure(LANGUAGE_CODE='de-at', LANGUAGES=[('de','German'),('en','English')], USE_I18N=True, SECRET_KEY='x', INSTALLED_APPS=[])\" \"print(check_language_settings_consistent(None))\" > {repo_root}/django/reproduce_issue.py"
        },
        {
          "reasoning": "Install required dependencies to ensure the reproduction script can run outside a full Django project.",
          "action": "python -m pip install asgiref pytz sqlparse"
        },
        {
          "reasoning": "Execute the reproduction script to observe the current behavior pre- or post-fix.",
          "action": "cd {repo_root}/django && python reproduce_issue.py"
        },
        {
          "reasoning": "Make local code changes importable by Django\u2019s tests.",
          "action": "cd {repo_root}/django && python -m pip install -e ."
        },
        {
          "reasoning": "Run the specific check_framework translation tests to validate the system check behavior.",
          "action": "cd {repo_root}/django && python tests/runtests.py check_framework.test_translation -v 2"
        },
        {
          "reasoning": "Run broader translation and i18n test subsets to ensure there are no regressions across related areas.",
          "action": "cd {repo_root}/django && python tests/runtests.py check_framework i18n --verbosity=1"
        }
      ],
      "source_clusters": [
        "Internationalization and Translation Validation"
      ],
      "source_trajectories": [
        "django__django-12286"
      ]
    },
    {
      "name": "Implementing Transactional Wrapper in Deserialization and Validating Rollback",
      "description": "Find deserialization paths used by test rollback, align with loaddata\u2019s transactional pattern, patch, and validate via targeted tests and reproductions.",
      "steps": [
        {
          "reasoning": "Need to identify where the deserialization logic used by test database creation/rollback is implemented.",
          "action": "grep -r \"deserialize_db_from_string\" django --include=\"*.py\""
        },
        {
          "reasoning": "Confirm the call site and related test infrastructure using TransactionTestCase.",
          "action": "grep -n \"deserialize_db_from_string\" django/test/testcases.py"
        },
        {
          "reasoning": "Open the backend creation code to inspect the current implementation.",
          "action": "sed -n '1,160p' django/db/backends/base/creation.py"
        },
        {
          "reasoning": "Search for tests referencing serialized rollback to understand coverage.",
          "action": "find tests -name \"*.py\" -type f | xargs grep -l \"serialized_rollback\""
        },
        {
          "reasoning": "Identify the loaddata implementation that handles transactional deserialization.",
          "action": "grep -n \"def handle\" django/core/management/commands/loaddata.py | head -5"
        },
        {
          "reasoning": "Review the transaction.atomic wrapping pattern used in loaddata.",
          "action": "sed -n '60,120p' django/core/management/commands/loaddata.py"
        },
        {
          "reasoning": "Add the transaction import alongside router to enable atomic blocks.",
          "action": "applypatch << 'PATCH'\n*** Begin Patch\n*** Update File: django/db/backends/base/creation.py\n@@\n-from django.db import router\n+from django.db import router, transaction\n*** End Patch\nPATCH"
        },
        {
          "reasoning": "Wrap the object save loop in transaction.atomic to ensure FK consistency and rollback behavior.",
          "action": "applypatch << 'PATCH'\n*** Begin Patch\n*** Update File: django/db/backends/base/creation.py\n@@\n-        data = StringIO(data)\n-        for obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n-            obj.save()\n+        data = StringIO(data)\n+        with transaction.atomic(using=self.connection.alias):\n+            for obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n+                obj.save()\n*** End Patch\nPATCH"
        },
        {
          "reasoning": "Verify the changes are exactly as intended and limited in scope.",
          "action": "git diff django/db/backends/base/creation.py"
        },
        {
          "reasoning": "Double-check the modified function in context to ensure correct placement.",
          "action": "grep -A 12 \"def deserialize_db_from_string\" django/db/backends/base/creation.py"
        },
        {
          "reasoning": "Ensure local changes are used during test runs.",
          "action": "pip install -e ."
        },
        {
          "reasoning": "Run TransactionTestCase tests to directly exercise serialized rollback behavior.",
          "action": "python tests/runtests.py test_utils.test_transactiontestcase --verbosity=2"
        },
        {
          "reasoning": "Run migration persistence tests since they rely on rollback and serialization state.",
          "action": "python tests/runtests.py migration_test_data_persistence --verbosity=2"
        },
        {
          "reasoning": "Reduce parallelism to avoid environment-related flakiness when debugging.",
          "action": "python tests/runtests.py test_utils.test_transactiontestcase migration_test_data_persistence --verbosity=2 --parallel=1"
        },
        {
          "reasoning": "Run adjacent suites to catch regressions in broader test infrastructure.",
          "action": "python tests/runtests.py test_runner --verbosity=1"
        },
        {
          "reasoning": "Run a specific test class to isolate behavior.",
          "action": "python -Wa tests/runtests.py test_utils.test_transactiontestcase.TestSerializedRollbackInhibitsPostMigrate --verbosity=2"
        },
        {
          "reasoning": "Find all tests that reference serialized rollback to understand coverage.",
          "action": "find tests -name \"*.py\" -type f | xargs grep -n \"serialized_rollback\""
        },
        {
          "reasoning": "Locate any direct usage of deserialize_db_from_string in tests.",
          "action": "grep -r \"deserialize_db_from_string\" tests --include=\"*.py\""
        },
        {
          "reasoning": "Generate an ad-hoc script that demonstrates FK integrity errors during deserialization without transaction, and success with transaction.atomic.",
          "action": "cat > {script_path} <<'PY'\nfrom django.db import connection, transaction\nfrom django.core import serializers\nfrom io import StringIO\n# Define models with FK here and create tables via schema_editor\n# Serialize data with FK-dependent object before its reference\n# Without transaction: expect IntegrityError\n# With transaction.atomic: expect success\nPY"
        },
        {
          "reasoning": "Execute the script to observe failure and success paths.",
          "action": "python {script_path}"
        },
        {
          "reasoning": "Create a summary file explaining the issue, fix, and rationale.",
          "action": "cat > FIX_SUMMARY.md << 'MD'\n- Issue: Non-transactional deserialization caused FK integrity errors in TransactionTestCase serialized rollback.\n- Fix: Wrap deserialize loop in transaction.atomic(using=connection.alias) and import transaction.\n- Rationale: Aligns with loaddata transactional pattern.\n- Tests: Targeted suites passed (TransactionTestCase, migration persistence, test_runner).\nMD"
        },
        {
          "reasoning": "Create a verification file recording diffs and test outcomes.",
          "action": "cat > VERIFICATION.md << 'MD'\n- Diff: Verified minimal changes in creation.py (import and atomic wrapper).\n- Tests: Ran targeted and adjacent suites; no regressions observed.\nMD"
        }
      ],
      "source_clusters": [
        "Testing and Transaction Rollback"
      ],
      "source_trajectories": [
        "django__django-12453"
      ]
    },
    {
      "name": "Patching Autoreloader to Handle Invalid Paths and Validating",
      "description": "Defensively handle unexpected path resolution errors in Django\u2019s autoreloader and validate via tests and a reproduction.",
      "steps": [
        {
          "reasoning": "Identify all call sites where Path.resolve() is used to collect files/directories.",
          "action": "cd {repo_root} && grep -rn \"resolve\\(.*\\).*absolute\\(\\)\\|resolve\\(strict\" --include=\"*.py\" django/utils/autoreload.py"
        },
        {
          "reasoning": "Patch exception handling to skip invalid paths (e.g., embedded null bytes) without crashing.",
          "action": "sed -i \"s/except FileNotFoundError:/except (FileNotFoundError, ValueError):/g\" {repo_root}/django/utils/autoreload.py"
        },
        {
          "reasoning": "Create a small reproduction to simulate Path.resolve raising ValueError and ensure the autoreloader does not crash.",
          "action": "cat > {repo_root}/test_embedded_null_byte.py <<'PY'\nfrom unittest import mock\nfrom django.utils import autoreload\nclass M: pass\nmock_module = M(); mock_module.__file__ = '/tmp/x.py'\nwith mock.patch('django.utils.autoreload.Path') as mock_path_class:\n    mock_path_instance = mock_path_class.return_value\n    mock_path_instance.resolve.side_effect = ValueError('embedded null byte')\n    result = autoreload.iter_modules_and_files((mock_module,), frozenset())\n    print(result)\nPY\ncd {repo_root} && python test_embedded_null_byte.py"
        },
        {
          "reasoning": "Run existing autoreload tests to confirm no regressions and that the new behavior is covered.",
          "action": "cd {repo_root} && tests/runtests.py utils_tests.test_autoreload -v 2"
        }
      ],
      "source_clusters": [
        "Developer Tooling and Debugging"
      ],
      "source_trajectories": [
        "django__django-11583"
      ]
    },
    {
      "name": "Extending SafeExceptionReporterFilter to Recurse into Lists/Tuples and Verifying",
      "description": "Update exception reporter filter to cleanse nested iterables and verify via tests and a standalone script.",
      "steps": [
        {
          "reasoning": "Locate the cleanse_setting implementation to determine current recursion behavior.",
          "action": "cd {repo_root} && grep -n \"class SafeExceptionReporterFilter\" django/views/debug.py && grep -n \"def cleanse_setting\" django/views/debug.py"
        },
        {
          "reasoning": "Patch cleanse_setting to handle lists/tuples while preserving container types and avoiding string/bytes recursion.",
          "action": "python - <<'PY'\nimport io, sys\np = '{repo_root}/django/views/debug.py'\ns = open(p).read()\ns = s.replace('elif isinstance(value, dict):', 'elif isinstance(value, dict):')\n# Insert a list/tuple branch if missing\nif '(list, tuple)' not in s:\n    s = s.replace('\\n        elif isinstance(value, dict):', '\\n        elif isinstance(value, dict):\\n            return {k: self.cleanse_setting(k, v) for k, v in value.items()}\\n        elif isinstance(value, (list, tuple)):\\n            return type(value)(self.cleanse_setting(key, item) for item in value)')\nopen(p, 'w').write(s)\nprint('Patched:', p)\nPY"
        },
        {
          "reasoning": "Add tests to ensure cleansing recurses into lists, nested lists, tuples, and mixed structures.",
          "action": "cat >> {repo_root}/tests/view_tests/tests/test_debug.py <<'PY'\nclass ExceptionReporterFilterTests_ListTupleRecursion:\n    def test_cleanse_setting_recurses_in_list(self):\n        from django.views.debug import SafeExceptionReporterFilter\n        rf = SafeExceptionReporterFilter()\n        value = [{'password': 'p'}, {'token': 't'}, {'other': 'x'}]\n        result = rf.cleanse_setting('SETTING', value)\n        assert result[0]['password'] == rf.cleansed_substitute\n        assert result[1]['token'] == rf.cleansed_substitute\n        assert result[2]['other'] == 'x'\n    def test_cleanse_setting_recurses_in_nested_lists(self):\n        from django.views.debug import SafeExceptionReporterFilter\n        rf = SafeExceptionReporterFilter()\n        value = [[{'secret': 's'}], [{'apikey': 'a'}]]\n        result = rf.cleanse_setting('SETTING', value)\n        assert result[0][0]['secret'] == rf.cleansed_substitute\n        assert result[1][0]['apikey'] == rf.cleansed_substitute\n    def test_cleanse_setting_recurses_in_tuple_preserves_type(self):\n        from django.views.debug import SafeExceptionReporterFilter\n        rf = SafeExceptionReporterFilter()\n        value = ({'password': 'p'}, {'token': 't'})\n        result = rf.cleanse_setting('SETTING', value)\n        assert isinstance(result, tuple)\n        assert result[0]['password'] == rf.cleansed_substitute\n        assert result[1]['token'] == rf.cleansed_substitute\nPY"
        },
        {
          "reasoning": "Run the relevant tests via Django\u2019s runner with an appropriate settings module.",
          "action": "cd {repo_root}/tests && python -m django test view_tests.tests.test_debug --settings=test_sqlite -v 2"
        },
        {
          "reasoning": "Optionally verify with a standalone script that mimics production settings nesting.",
          "action": "cat > {repo_root}/verify_sanitize.py <<'PY'\nimport pprint\nfrom django.conf import settings\nfrom django.views.debug import SafeExceptionReporterFilter\nsettings.configure(MY_SETTING={'else': [[{'token': 't'}], [{'secret': 's'}]]})\nrf = SafeExceptionReporterFilter()\nprint(pprint.pformat(rf.get_safe_settings()['MY_SETTING']))\nPY\ncd {repo_root} && python verify_sanitize.py"
        }
      ],
      "source_clusters": [
        "Developer Tooling and Debugging"
      ],
      "source_trajectories": [
        "django__django-12700"
      ]
    }
  ]
}