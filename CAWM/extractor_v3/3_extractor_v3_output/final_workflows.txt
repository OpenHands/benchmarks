================================================================================
TYPE 1 WORKFLOWS - General Strategies
================================================================================

## Diagnosing and Fixing Django HTTP Parsing and URL Resolver Issues with Minimal Reproductions
A general strategy to ensure HTTP utilities adhere to RFC specifications and URL resolver behavior is correct for optional regex groups, using concise, script-based reproductions.
(Sources: 2 trajectories)

Step 1: Review the relevant RFCs (e.g., RFC 7231, RFC 2822) and clarify expected behavior for edge cases such as two-digit years
Step 2: Configure lightweight Django settings programmatically (e.g., ROOT_URLCONF) within a single script to avoid full project overhead
Step 3: Dynamically define a minimal URLConf with patterns (including optional named groups) and a simple view to isolate resolver behavior
Step 4: Verify Python regex behavior with the chosen patterns to understand groupdict/groups outputs, especially None values for unmatched optional groups
Step 5: Locate the implementations in Django (e.g., django/utils/http.py for date parsing and django/urls/resolvers.py for URL resolving) and identify logic that deviates from the spec or expected behavior
Step 6: Design fixes: adhere to RFC parsing (e.g., two-digit year handling based on current UTC year and boundary conditions) and adjust URL resolver to filter out None values or correct args/kwargs precedence for optional groups
Step 7: Implement changes with minimal impact and clear comments, ensuring maintainable code and defensive handling of edge cases
Step 8: Validate using the minimal reproduction scripts and additional edge cases (date formats, named vs. unnamed groups, presence/absence of optional segments)
Step 9: Run Django’s HTTP and URL-related test suites to ensure no regressions introduced
Step 10: Document the root causes, fixes, and outcomes to aid future maintenance

--------------------------------------------------------------------------------


================================================================================
TYPE 2 WORKFLOWS - Specific Action Workflows
================================================================================

## Code Location and Inspection Toolbox
Quickly locate features, functions, errors, and surrounding context in Django’s source, and find related tests.
(Sources: 6 trajectories)

Reasoning: Need to locate where a specific message or feature is implemented to understand or change it
Action: grep -r "{search_phrase}" /workspace/django/django/ --line-number

Reasoning: Once a matching file is found, inspect surrounding context to understand conditions and usage
Action: sed -n '{start_line},{end_line}p' /workspace/django/django/{path_to_file}

Reasoning: Need to locate the exact file and function definition to inspect current logic.
Action: grep -Rn "def {function_name}" {repo_root}/django | head -10

Reasoning: Open the identified file to review the implementation details around the function.
Action: sed -n '{start_line},{end_line}p' {repo_root}/django/{relative_path_to_file}

Reasoning: Quickly jump to the function within the file to focus on its logic.
Action: grep -n "{function_name}" {repo_root}/django/{relative_path_to_file}

Reasoning: Start from the observed error to pinpoint where in the codebase the failure occurs.
Action: cd {repo_root} && grep -R "{error_keyword}" -n django | head -20

Reasoning: If the failing module is known, find the exact file path for inspection.
Action: cd {repo_root} && find django -type f -name "{module_file_name}" | head -5

Reasoning: Locate specific function calls or patterns (e.g., Path.resolve) to narrow down the problematic region.
Action: cd {repo_root} && grep -n "{pattern}" django/{relative_module_path}

Reasoning: Inspect surrounding lines to understand current logic and exception handling.
Action: sed -n '{start_line},{end_line}p' {repo_root}/django/{relative_module_path}

Reasoning: Discover related tests to assess existing coverage and plan new tests.
Action: cd {repo_root} && find tests -name "*{module_or_feature_keyword}*" -type f | xargs grep -l "{class_or_function_name}"

--------------------------------------------------------------------------------

## Running Targeted Django Tests Across Runners
Execute focused Django tests using multiple runners and strategies, with options for specific modules, classes, methods, and settings.
(Sources: 8 trajectories)

Reasoning: Run a specific app's tests to verify behavior related to the change
Action: cd /workspace/django/tests && python runtests.py {module_name} --verbosity=2

Reasoning: Run a specific test class or test method to validate a focused scenario
Action: cd /workspace/django/tests && python runtests.py {module_name}.{TestClassName}.{test_method} --verbosity=2

Reasoning: Run multiple related modules to check for cross-module regressions
Action: cd /workspace/django/tests && python runtests.py {module1} {module2} {module3} --verbosity=1

Reasoning: Verify a fix in a focused area by running only the relevant test suite.
Action: cd {repo_root}/django && python tests/runtests.py {module_name} -v 2

Reasoning: Run a specific test case or class when narrowing down behavior or regressions.
Action: cd {repo_root}/django && python tests/runtests.py {module_name}.{test_class_or_method} --settings={settings_module} -v 2

Reasoning: Optionally install Django in editable mode to simplify imports and environment setup for tests.
Action: cd {repo_root}/django && pip install -e .

Reasoning: Use Django’s custom test runner to run a specific test module with verbose output.
Action: cd {repo_root}/tests && python runtests.py {module_name} --settings={settings_module} -v 2

Reasoning: Run a specific test class or method via django-admin test when the repo is installed or importable.
Action: cd {repo_root}/tests && python -m django test {full_test_path} --settings={settings_module} -v 2

Reasoning: If imports fail due to environment issues, install the repository in editable mode first.
Action: cd {repo_root} && pip install -e .

Reasoning: As a fallback, run tests directly via unittest for simple modules or local checks.
Action: cd {repo_root} && python -m unittest {python_test_module_path}

--------------------------------------------------------------------------------

## Setting Up Local Django Environment for Development and Tests
Install Django in editable mode and ensure required dependencies are present.
(Sources: 3 trajectories)

Reasoning: Use Django from the local source tree and allow modifications to be tested immediately
Action: cd /workspace/django && python -m pip install -e .

Reasoning: Install core Django runtime dependencies needed for test execution
Action: python -m pip install asgiref sqlparse pytz

Reasoning: Ensure Python can import the local Django package during scripts
Action: export PYTHONPATH=/workspace/django

--------------------------------------------------------------------------------

## Creating a Minimal Reproduction Script with Django Setup
Build a standalone script to reproduce an issue and inspect behavior (e.g., serialization, ordering, display).
(Sources: 3 trajectories)

Reasoning: Configure Django settings in-process to allow model definitions and operations
Action: python -c "from django.conf import settings; settings.configure(INSTALLED_APPS=['django.contrib.contenttypes'], DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}}); import django; django.setup(); print('OK')"

Reasoning: Define minimal models that trigger the problem and print relevant outputs (SQL, serialized paths, display values)
Action: Create {script_path} containing model definitions and calls to .objects.all().query or serializer_factory; run: python {script_path}

Reasoning: If the script needs to import local Django source, ensure the path is on sys.path
Action: Run the script with: PYTHONPATH=/workspace/django python {script_path}

--------------------------------------------------------------------------------

## Diagnosing and Fixing Optional Regex Groups in URL Resolver
Investigate Python regex behavior for optional groups, validate Django URL resolution, apply a minimal fix, and run tests.
(Sources: 2 trajectories)

Reasoning: Verify whether optional groups produce None values that could be incorrectly propagated.
Action: python -c 'import re; p = re.compile(r"{pattern}"); m = p.search("{path}"); print("groupdict:", m.groupdict()); print("groups:", m.groups())'

Reasoning: Compare behavior with and without the optional group present to understand boundary cases.
Action: python -c 'import re; p = re.compile(r"{pattern}"); m1 = p.search("{path_without_optional}"); m2 = p.search("{path_with_optional}"); print("no optional:", m1.groupdict(), m1.groups()); print("with optional:", m2.groupdict(), m2.groups())'

Reasoning: Set up a lightweight Django environment that can resolve URLs without a full project.
Action: python -c "import sys, types; sys.path.insert(0, '{repo_root}/django'); from django.conf import settings; settings.configure(DEBUG=True, ROOT_URLCONF='test_urls', ALLOWED_HOSTS=['*'], INSTALLED_APPS=['django.contrib.contenttypes']); import django; django.setup(); print('OK'); test_urls = types.ModuleType('test_urls'); def {view_name}(request, {param_name}='{default_value}'): return f'{param_name}: {{{param_name}}}'; test_urls.{view_name} = {view_name}; from django.urls import re_path; test_urls.urlpatterns = [re_path(r'{regex_pattern}', {view_name}, name='{url_name}')]; sys.modules['test_urls'] = test_urls; from django.urls import resolve; rm1 = resolve('{path1}'); print('Args1:', rm1.args, 'Kwargs1:', rm1.kwargs); rm2 = resolve('{path2}'); print('Args2:', rm2.args, 'Kwargs2:', rm2.kwargs)"

Reasoning: Fix URL resolver fallback when optional groups are present by ignoring None values.
Action: sed -i "s/args = () if kwargs else match.groups()/args = () if kwargs else tuple(g for g in match.groups() if g is not None)/" {repo_root}/django/django/urls/resolvers.py

Reasoning: Verify a fix in a focused area by running only the relevant test suite.
Action: cd {repo_root}/django && python tests/runtests.py {module_name} -v 2

--------------------------------------------------------------------------------

## Adjusting HTTP Date Parsing Logic per RFC and Verifying
Update two-digit year handling in RFC850 date parsing and verify across formats via a script.
(Sources: 2 trajectories)

Reasoning: Update century selection logic to use a dynamic comparison against the current year plus 50 years as per RFC 7231.
Action: sed -i "s/if year < 70:\n\s*year += 2000\n\s*else:\n\s*year += 1900/ current_year = datetime.datetime.utcnow().year\n            if 2000 + year > current_year + 50:\n                year += 1900\n            else:\n                year += 2000/" {repo_root}/django/django/utils/http.py

Reasoning: Ensure the fix doesn’t regress other formats and correctly handles two-digit years according to the RFC.
Action: python -c "import sys; sys.path.insert(0, '{repo_root}/django'); from django.utils.http import parse_http_date; from datetime import datetime; cases = ['Sun, 06 Nov 1994 08:49:37 GMT', 'Sunday, 06-Nov-70 08:49:37 GMT', 'Sun Nov  6 08:49:37 0037']; for c in cases: ts = parse_http_date(c); print(c, '->', datetime.utcfromtimestamp(ts))"

--------------------------------------------------------------------------------
