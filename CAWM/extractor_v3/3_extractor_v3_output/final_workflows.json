{
  "type1_workflows": [
    {
      "name": "Diagnosing and Fixing Django HTTP Parsing and URL Resolver Issues with Minimal Reproductions",
      "description": "A general strategy to ensure HTTP utilities adhere to RFC specifications and URL resolver behavior is correct for optional regex groups, using concise, script-based reproductions.",
      "steps": [
        "Step 1: Review the relevant RFCs (e.g., RFC 7231, RFC 2822) and clarify expected behavior for edge cases such as two-digit years",
        "Step 2: Configure lightweight Django settings programmatically (e.g., ROOT_URLCONF) within a single script to avoid full project overhead",
        "Step 3: Dynamically define a minimal URLConf with patterns (including optional named groups) and a simple view to isolate resolver behavior",
        "Step 4: Verify Python regex behavior with the chosen patterns to understand groupdict/groups outputs, especially None values for unmatched optional groups",
        "Step 5: Locate the implementations in Django (e.g., django/utils/http.py for date parsing and django/urls/resolvers.py for URL resolving) and identify logic that deviates from the spec or expected behavior",
        "Step 6: Design fixes: adhere to RFC parsing (e.g., two-digit year handling based on current UTC year and boundary conditions) and adjust URL resolver to filter out None values or correct args/kwargs precedence for optional groups",
        "Step 7: Implement changes with minimal impact and clear comments, ensuring maintainable code and defensive handling of edge cases",
        "Step 8: Validate using the minimal reproduction scripts and additional edge cases (date formats, named vs. unnamed groups, presence/absence of optional segments)",
        "Step 9: Run Django\u2019s HTTP and URL-related test suites to ensure no regressions introduced",
        "Step 10: Document the root causes, fixes, and outcomes to aid future maintenance"
      ],
      "source_clusters": [
        "HTTP and URL Handling"
      ],
      "source_trajectories": [
        "django__django-11848",
        "django__django-12184"
      ]
    }
  ],
  "type2_workflows": [
    {
      "name": "Code Location and Inspection Toolbox",
      "description": "Quickly locate features, functions, errors, and surrounding context in Django\u2019s source, and find related tests.",
      "steps": [
        {
          "reasoning": "Need to locate where a specific message or feature is implemented to understand or change it",
          "action": "grep -r \"{search_phrase}\" /workspace/django/django/ --line-number"
        },
        {
          "reasoning": "Once a matching file is found, inspect surrounding context to understand conditions and usage",
          "action": "sed -n '{start_line},{end_line}p' /workspace/django/django/{path_to_file}"
        },
        {
          "reasoning": "Need to locate the exact file and function definition to inspect current logic.",
          "action": "grep -Rn \"def {function_name}\" {repo_root}/django | head -10"
        },
        {
          "reasoning": "Open the identified file to review the implementation details around the function.",
          "action": "sed -n '{start_line},{end_line}p' {repo_root}/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Quickly jump to the function within the file to focus on its logic.",
          "action": "grep -n \"{function_name}\" {repo_root}/django/{relative_path_to_file}"
        },
        {
          "reasoning": "Start from the observed error to pinpoint where in the codebase the failure occurs.",
          "action": "cd {repo_root} && grep -R \"{error_keyword}\" -n django | head -20"
        },
        {
          "reasoning": "If the failing module is known, find the exact file path for inspection.",
          "action": "cd {repo_root} && find django -type f -name \"{module_file_name}\" | head -5"
        },
        {
          "reasoning": "Locate specific function calls or patterns (e.g., Path.resolve) to narrow down the problematic region.",
          "action": "cd {repo_root} && grep -n \"{pattern}\" django/{relative_module_path}"
        },
        {
          "reasoning": "Inspect surrounding lines to understand current logic and exception handling.",
          "action": "sed -n '{start_line},{end_line}p' {repo_root}/django/{relative_module_path}"
        },
        {
          "reasoning": "Discover related tests to assess existing coverage and plan new tests.",
          "action": "cd {repo_root} && find tests -name \"*{module_or_feature_keyword}*\" -type f | xargs grep -l \"{class_or_function_name}\""
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs",
        "HTTP and URL Handling",
        "Developer Tooling and Debugging"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-12497",
        "django__django-11848",
        "django__django-12184",
        "django__django-11583",
        "django__django-12700"
      ]
    },
    {
      "name": "Running Targeted Django Tests Across Runners",
      "description": "Execute focused Django tests using multiple runners and strategies, with options for specific modules, classes, methods, and settings.",
      "steps": [
        {
          "reasoning": "Run a specific app's tests to verify behavior related to the change",
          "action": "cd /workspace/django/tests && python runtests.py {module_name} --verbosity=2"
        },
        {
          "reasoning": "Run a specific test class or test method to validate a focused scenario",
          "action": "cd /workspace/django/tests && python runtests.py {module_name}.{TestClassName}.{test_method} --verbosity=2"
        },
        {
          "reasoning": "Run multiple related modules to check for cross-module regressions",
          "action": "cd /workspace/django/tests && python runtests.py {module1} {module2} {module3} --verbosity=1"
        },
        {
          "reasoning": "Verify a fix in a focused area by running only the relevant test suite.",
          "action": "cd {repo_root}/django && python tests/runtests.py {module_name} -v 2"
        },
        {
          "reasoning": "Run a specific test case or class when narrowing down behavior or regressions.",
          "action": "cd {repo_root}/django && python tests/runtests.py {module_name}.{test_class_or_method} --settings={settings_module} -v 2"
        },
        {
          "reasoning": "Optionally install Django in editable mode to simplify imports and environment setup for tests.",
          "action": "cd {repo_root}/django && pip install -e ."
        },
        {
          "reasoning": "Use Django\u2019s custom test runner to run a specific test module with verbose output.",
          "action": "cd {repo_root}/tests && python runtests.py {module_name} --settings={settings_module} -v 2"
        },
        {
          "reasoning": "Run a specific test class or method via django-admin test when the repo is installed or importable.",
          "action": "cd {repo_root}/tests && python -m django test {full_test_path} --settings={settings_module} -v 2"
        },
        {
          "reasoning": "If imports fail due to environment issues, install the repository in editable mode first.",
          "action": "cd {repo_root} && pip install -e ."
        },
        {
          "reasoning": "As a fallback, run tests directly via unittest for simple modules or local checks.",
          "action": "cd {repo_root} && python -m unittest {python_test_module_path}"
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs",
        "HTTP and URL Handling",
        "Developer Tooling and Debugging"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-12284",
        "django__django-12470",
        "django__django-12497",
        "django__django-11848",
        "django__django-12184",
        "django__django-11583",
        "django__django-12700"
      ]
    },
    {
      "name": "Setting Up Local Django Environment for Development and Tests",
      "description": "Install Django in editable mode and ensure required dependencies are present.",
      "steps": [
        {
          "reasoning": "Use Django from the local source tree and allow modifications to be tested immediately",
          "action": "cd /workspace/django && python -m pip install -e ."
        },
        {
          "reasoning": "Install core Django runtime dependencies needed for test execution",
          "action": "python -m pip install asgiref sqlparse pytz"
        },
        {
          "reasoning": "Ensure Python can import the local Django package during scripts",
          "action": "export PYTHONPATH=/workspace/django"
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-12284",
        "django__django-12497"
      ]
    },
    {
      "name": "Creating a Minimal Reproduction Script with Django Setup",
      "description": "Build a standalone script to reproduce an issue and inspect behavior (e.g., serialization, ordering, display).",
      "steps": [
        {
          "reasoning": "Configure Django settings in-process to allow model definitions and operations",
          "action": "python -c \"from django.conf import settings; settings.configure(INSTALLED_APPS=['django.contrib.contenttypes'], DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}}); import django; django.setup(); print('OK')\""
        },
        {
          "reasoning": "Define minimal models that trigger the problem and print relevant outputs (SQL, serialized paths, display values)",
          "action": "Create {script_path} containing model definitions and calls to .objects.all().query or serializer_factory; run: python {script_path}"
        },
        {
          "reasoning": "If the script needs to import local Django source, ensure the path is on sys.path",
          "action": "Run the script with: PYTHONPATH=/workspace/django python {script_path}"
        }
      ],
      "source_clusters": [
        "Django ORM, Migrations, and Model Relations Bugs"
      ],
      "source_trajectories": [
        "django__django-12125",
        "django__django-12284",
        "django__django-12470"
      ]
    },
    {
      "name": "Diagnosing and Fixing Optional Regex Groups in URL Resolver",
      "description": "Investigate Python regex behavior for optional groups, validate Django URL resolution, apply a minimal fix, and run tests.",
      "steps": [
        {
          "reasoning": "Verify whether optional groups produce None values that could be incorrectly propagated.",
          "action": "python -c 'import re; p = re.compile(r\"{pattern}\"); m = p.search(\"{path}\"); print(\"groupdict:\", m.groupdict()); print(\"groups:\", m.groups())'"
        },
        {
          "reasoning": "Compare behavior with and without the optional group present to understand boundary cases.",
          "action": "python -c 'import re; p = re.compile(r\"{pattern}\"); m1 = p.search(\"{path_without_optional}\"); m2 = p.search(\"{path_with_optional}\"); print(\"no optional:\", m1.groupdict(), m1.groups()); print(\"with optional:\", m2.groupdict(), m2.groups())'"
        },
        {
          "reasoning": "Set up a lightweight Django environment that can resolve URLs without a full project.",
          "action": "python -c \"import sys, types; sys.path.insert(0, '{repo_root}/django'); from django.conf import settings; settings.configure(DEBUG=True, ROOT_URLCONF='test_urls', ALLOWED_HOSTS=['*'], INSTALLED_APPS=['django.contrib.contenttypes']); import django; django.setup(); print('OK'); test_urls = types.ModuleType('test_urls'); def {view_name}(request, {param_name}='{default_value}'): return f'{param_name}: {{{param_name}}}'; test_urls.{view_name} = {view_name}; from django.urls import re_path; test_urls.urlpatterns = [re_path(r'{regex_pattern}', {view_name}, name='{url_name}')]; sys.modules['test_urls'] = test_urls; from django.urls import resolve; rm1 = resolve('{path1}'); print('Args1:', rm1.args, 'Kwargs1:', rm1.kwargs); rm2 = resolve('{path2}'); print('Args2:', rm2.args, 'Kwargs2:', rm2.kwargs)\""
        },
        {
          "reasoning": "Fix URL resolver fallback when optional groups are present by ignoring None values.",
          "action": "sed -i \"s/args = () if kwargs else match.groups()/args = () if kwargs else tuple(g for g in match.groups() if g is not None)/\" {repo_root}/django/django/urls/resolvers.py"
        },
        {
          "reasoning": "Verify a fix in a focused area by running only the relevant test suite.",
          "action": "cd {repo_root}/django && python tests/runtests.py {module_name} -v 2"
        }
      ],
      "source_clusters": [
        "HTTP and URL Handling"
      ],
      "source_trajectories": [
        "django__django-12184",
        "django__django-11848"
      ]
    },
    {
      "name": "Adjusting HTTP Date Parsing Logic per RFC and Verifying",
      "description": "Update two-digit year handling in RFC850 date parsing and verify across formats via a script.",
      "steps": [
        {
          "reasoning": "Update century selection logic to use a dynamic comparison against the current year plus 50 years as per RFC 7231.",
          "action": "sed -i \"s/if year < 70:\\n\\s*year += 2000\\n\\s*else:\\n\\s*year += 1900/ current_year = datetime.datetime.utcnow().year\\n            if 2000 + year > current_year + 50:\\n                year += 1900\\n            else:\\n                year += 2000/\" {repo_root}/django/django/utils/http.py"
        },
        {
          "reasoning": "Ensure the fix doesn\u2019t regress other formats and correctly handles two-digit years according to the RFC.",
          "action": "python -c \"import sys; sys.path.insert(0, '{repo_root}/django'); from django.utils.http import parse_http_date; from datetime import datetime; cases = ['Sun, 06 Nov 1994 08:49:37 GMT', 'Sunday, 06-Nov-70 08:49:37 GMT', 'Sun Nov  6 08:49:37 0037']; for c in cases: ts = parse_http_date(c); print(c, '->', datetime.utcfromtimestamp(ts))\""
        }
      ],
      "source_clusters": [
        "HTTP and URL Handling"
      ],
      "source_trajectories": [
        "django__django-11848",
        "django__django-12184"
      ]
    }
  ]
}