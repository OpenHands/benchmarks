{
  "metadata": {
    "generated_at": "2025-12-03T00:13:06.339197",
    "input_file": "CAWM/trajectories/resolved_trajectories.jsonl",
    "num_trajectories": 10,
    "config": {
      "compression": "key_step_extraction",
      "clustering": "action_sequence",
      "threshold": 0.7,
      "level": "general",
      "model": "moonshotai/kimi-k2-0905"
    }
  },
  "workflows": [
    {
      "id": "exp-general-421938e4",
      "description": "When NDDataRef arithmetic operations fail with 'NoneType' object has no attribute 'dtype' or similar mask-related errors → The mask propagation logic assumes both operands have masks, but when one operand lacks a mask, atte",
      "category": "debugging",
      "steps": [
        {
          "env_description": "When NDDataRef arithmetic operations fail with 'NoneType' object has no attribute 'dtype' or similar mask-related errors",
          "reasoning": "The mask propagation logic assumes both operands have masks, but when one operand lacks a mask, attempting operations like np.bitwise_or fails on None",
          "action": "Add explicit None checks before mask operations: if mask1 is None, treat it as False/all-zero mask; if mask2 is None, treat similarly",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "astropy__astropy-14995",
        "django__django-11848"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-ba17e1e4",
      "description": "When django.utils.http.parse_http_date incorrectly interprets two-digit years (00-69) as 1900s instead of 2000s → RFC 7231 specifies that years 00-69 should map to 2000-2069, while 70-99 map to 1970-1999",
      "category": "api_usage",
      "steps": [
        {
          "env_description": "When django.utils.http.parse_http_date incorrectly interprets two-digit years (00-69) as 1900s instead of 2000s",
          "reasoning": "RFC 7231 specifies that years 00-69 should map to 2000-2069, while 70-99 map to 1970-1999",
          "action": "Implement year adjustment logic: if parsed_year < 50, add 2000; else add 1900, but be aware of existing behavior dependencies",
          "action_type": "api_usage"
        }
      ],
      "level": 1,
      "source_instances": [
        "astropy__astropy-14995",
        "django__django-11848"
      ],
      "frequency": 1,
      "pattern": [
        "api_usage"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-bb97a824",
      "description": "When numpy arithmetic operations like np.bitwise_or fail on mixed types (structured vs non-structured arrays) → The error occurs because numpy can't determine dtype compatibility when one array is structured and ",
      "category": "refactoring",
      "steps": [
        {
          "env_description": "When numpy arithmetic operations like np.bitwise_or fail on mixed types (structured vs non-structured arrays)",
          "reasoning": "The error occurs because numpy can't determine dtype compatibility when one array is structured and the other is not",
          "action": "Convert both arrays to regular boolean arrays before operations like: regular_arr = view_as_arrays.astype(np.uint8).astype(bool)",
          "action_type": "refactoring"
        }
      ],
      "level": 1,
      "source_instances": [
        "astropy__astropy-14995",
        "django__django-11848"
      ],
      "frequency": 1,
      "pattern": [
        "refactoring"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-15e574d0",
      "description": "When changes to datetime parsing affect existing test cases that rely on current (incorrect) behavior → Fixing the two-digit year interpretation will break backward compatibility for dates in the ranges 2",
      "category": "configuration",
      "steps": [
        {
          "env_description": "When changes to datetime parsing affect existing test cases that rely on current (incorrect) behavior",
          "reasoning": "Fixing the two-digit year interpretation will break backward compatibility for dates in the ranges 29-31 December 1999 vs 2029-2031",
          "action": "Implement a deprecation path: maintain old behavior initially with warnings, provide configuration flag to enable new behavior",
          "action_type": "configuration"
        }
      ],
      "level": 1,
      "source_instances": [
        "astropy__astropy-14995",
        "django__django-11848"
      ],
      "frequency": 1,
      "pattern": [
        "configuration"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-427d1959",
      "description": "When StatReloader intermittently throws \"ValueError: embedded null byte\" during auto-reload → Pathlib's Path.resolve() can encounter filesystem entries with embedded null bytes that Python's str",
      "category": "debugging",
      "steps": [
        {
          "env_description": "When StatReloader intermittently throws \"ValueError: embedded null byte\" during auto-reload",
          "reasoning": "Pathlib's Path.resolve() can encounter filesystem entries with embedded null bytes that Python's str() can't represent, causing the ValueError",
          "action": "Wrap Path.resolve() calls in a try/except for ValueError and fall back to the original path string to skip problematic entries",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-11583"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-14225042",
      "description": "If an autoreloader test fails with an opaque ValueError on a pathlib operation → The error is likely triggered by a directory entry containing a null byte (e.g., a malformed symlink",
      "category": "testing",
      "steps": [
        {
          "env_description": "If an autoreloader test fails with an opaque ValueError on a pathlib operation",
          "reasoning": "The error is likely triggered by a directory entry containing a null byte (e.g., a malformed symlink or special file), not by normal Python code",
          "action": "Ensure test environments clean up or skip such entries by filtering paths through os.fsdecode() before pathlib operations",
          "action_type": "testing"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-11583"
      ],
      "frequency": 1,
      "pattern": [
        "testing"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-67b25169",
      "description": "When migrating legacy os.path code to pathlib in watcher utilities → Pathlib is stricter about invalid filesystem bytes; null-byte paths that os.path ignored will now ra",
      "category": "refactoring",
      "steps": [
        {
          "env_description": "When migrating legacy os.path code to pathlib in watcher utilities",
          "reasoning": "Pathlib is stricter about invalid filesystem bytes; null-byte paths that os.path ignored will now raise exceptions",
          "action": "Sanitize paths with os.fsdecode() and catch ValueError on resolve/stat to maintain the old lenient behavior",
          "action_type": "refactoring"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-11583"
      ],
      "frequency": 1,
      "pattern": [
        "refactoring"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-5ce34a0f",
      "description": "If makemigrations saves an inner-class field with an incorrect dotted path that cannot be imported later → Field.deconstruct() stores '__name__' which is just the inner-class name, but migration serializatio",
      "category": "migration_serialization",
      "steps": [
        {
          "env_description": "If makemigrations saves an inner-class field with an incorrect dotted path that cannot be imported later",
          "reasoning": "Field.deconstruct() stores '__name__' which is just the inner-class name, but migration serialization needs the fully-qualified dotted path (e.g. 'MyOuter.MyInner') to re-import it",
          "action": "Replace '__name__' with '__qualname__' in the field’s deconstruct() tuple so the serializer writes the full dotted path that can be located by importlib at migration time",
          "action_type": "migration_serialization"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12125"
      ],
      "frequency": 1,
      "pattern": [
        "migration_serialization"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-d22f35aa",
      "description": "When a migration fails on FieldDoesNotExist after you added a custom inner-class field → Migration files contain imports of the form 'from {module} import {path}'.  If the stored path lacks",
      "category": "debugging",
      "steps": [
        {
          "env_description": "When a migration fails on FieldDoesNotExist after you added a custom inner-class field",
          "reasoning": "Migration files contain imports of the form 'from {module} import {path}'.  If the stored path lacks the outer classname (because '__name__' was used), the import succeeds but the name is undefined, causing the Field class lookup to fail",
          "action": "Before running the migration, manually patch the generated migration file’s import line so that it uses the full dotted path (outer.inner) or regenerate it after applying the '__qualname__' fix",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12125"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-f41f6756",
      "description": "If you cannot reproduce the inner-class migration bug in a minimal test, even though it fails in the real project → Many inner-class serialization issues surface only when you have a field instance inside a Model cla",
      "category": "testing",
      "steps": [
        {
          "env_description": "If you cannot reproduce the inner-class migration bug in a minimal test, even though it fails in the real project",
          "reasoning": "Many inner-class serialization issues surface only when you have a field instance inside a Model class and then run makemigrations. A pure create-test-then-deconstruct sequence may not expose the problem",
          "action": "Inside your reproduction test, create a real model using the inner-class field, call makemigrations (or serializer.py directly) and assert that the round-trip import succeeds, not just that deconstruct() returns a value",
          "action_type": "testing"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12125"
      ],
      "frequency": 1,
      "pattern": [
        "testing"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-14a2b6f5",
      "description": "If optional named regex groups like (?P<format>…)? cause missing-keyword crashes in Django 2.2+ → Django’s resolver started to drop None-captures from kwargs, so the view no longer receives the para",
      "category": "api_usage",
      "steps": [
        {
          "env_description": "If optional named regex groups like (?P<format>…)? cause missing-keyword crashes in Django 2.2+",
          "reasoning": "Django’s resolver started to drop None-captures from kwargs, so the view no longer receives the param at all",
          "action": "Make the regex group non-optional ((?P<format>…)) and handle the fallback inside the view, or switch to path converters instead of regex",
          "action_type": "api_usage"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12184"
      ],
      "frequency": 1,
      "pattern": [
        "api_usage"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-7bd58009",
      "description": "When a view expecting a default kwarg suddenly gets **no** value after a Django upgrade → The URL resolver now removes keys whose capture group matched None, so the default is never applied",
      "category": "debugging",
      "steps": [
        {
          "env_description": "When a view expecting a default kwarg suddenly gets **no** value after a Django upgrade",
          "reasoning": "The URL resolver now removes keys whose capture group matched None, so the default is never applied",
          "action": "Check the resolver’s return value for missing keys and set the default in the view if absent",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12184"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-8a3c0495",
      "description": "If urlpatterns with optional regex groups work in ≤2.1 but fail in ≥2.2 → The regression is in django/urls/resolvers.py where None-captures are filtered out before calling th",
      "category": "configuration",
      "steps": [
        {
          "env_description": "If urlpatterns with optional regex groups work in ≤2.1 but fail in ≥2.2",
          "reasoning": "The regression is in django/urls/resolvers.py where None-captures are filtered out before calling the view",
          "action": "Patch the resolver to keep keys even when their value is None, or avoid optional regex groups entirely",
          "action_type": "configuration"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12184"
      ],
      "frequency": 1,
      "pattern": [
        "configuration"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-013ad6e2",
      "description": "When Model.get_FOO_display() returns incorrect results after child model overrides inherited choices → The display name is looked up on the model class where the field was originally defined, not the chi",
      "category": "api_usage",
      "steps": [
        {
          "env_description": "When Model.get_FOO_display() returns incorrect results after child model overrides inherited choices",
          "reasoning": "The display name is looked up on the model class where the field was originally defined, not the child class that overrides choices",
          "action": "Override get_FOO_display() on the child model to force lookup against the child class by calling self.__class__._meta.get_field(...)",
          "action_type": "api_usage"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12284"
      ],
      "frequency": 1,
      "pattern": [
        "api_usage"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-3d631884",
      "description": "When get_FOO_display() returns the raw value instead of the choice display name on inherited fields → The inherited field's cache in Options._field_cache still points to the base field, which holds the ",
      "category": "debugging",
      "steps": [
        {
          "env_description": "When get_FOO_display() returns the raw value instead of the choice display name on inherited fields",
          "reasoning": "The inherited field's cache in Options._field_cache still points to the base field, which holds the base choices",
          "action": "Ensure the child model redefines the field (not just choices) so Django recreates the field with child choices in the cache",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12284"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-894706d7",
      "description": "When overriding choices in a child model but display values still come from parent → Choices are bound to the Field instance at class creation time; inheriting the field also inherits t",
      "category": "refactoring",
      "steps": [
        {
          "env_description": "When overriding choices in a child model but display values still come from parent",
          "reasoning": "Choices are bound to the Field instance at class creation time; inheriting the field also inherits the original choices list",
          "action": "Re-declare the field in the child model rather than only overriding choices attribute to get a fresh field with new choices",
          "action_type": "refactoring"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12284"
      ],
      "frequency": 1,
      "pattern": [
        "refactoring"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-1abe35af",
      "description": "When Django check E004 flags a sub-language (e.g. 'de-at') but the base language ('de') is installed → The check was treating 'de-at' as a completely separate language, ignoring the fallback rule that do",
      "category": "configuration",
      "steps": [
        {
          "env_description": "When Django check E004 flags a sub-language (e.g. 'de-at') but the base language ('de') is installed",
          "reasoning": "The check was treating 'de-at' as a completely separate language, ignoring the fallback rule that documentedly maps sub-languages to their base.",
          "action": "Test the installed-languages set for both exact match and, on failure, for a parent/base language match before emitting E004. In practice use 'lang.startswith(base + \\\"-\\\")' after 'base in settings.LANGUAGES'.",
          "action_type": "configuration"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12286"
      ],
      "frequency": 1,
      "pattern": [
        "configuration"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-8219a3a1",
      "description": "If a system check's docstring says 'Languages in LANGUAGES setting must be available in locale directory' and your code has variants like 'en-gb' vs 'en' → The check’s validation does not account for sub-language fallback; it fails when the check is strict",
      "category": "debugging",
      "steps": [
        {
          "env_description": "If a system check's docstring says 'Languages in LANGUAGES setting must be available in locale directory' and your code has variants like 'en-gb' vs 'en'",
          "reasoning": "The check’s validation does not account for sub-language fallback; it fails when the check is stricter than the dispatcher’s documented policy.",
          "action": "When writing translation checks, duplicate the fallback rules used by the run-time resolver so that sub-language strings are validated against their base language.",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12286"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-0ffe798d",
      "description": "Need to reproduce a check-framework failure without touching the test-suite run → Check framework classes are just Python callables that receive an app_configs list; you can instanti",
      "category": "debugging",
      "steps": [
        {
          "env_description": "Need to reproduce a check-framework failure without touching the test-suite run",
          "reasoning": "Check framework classes are just Python callables that receive an app_configs list; you can instantiate and call them directly outside of pytest.",
          "action": "Create a minimal reproduce script that imports E004 check function and feeds it the mis-configured settings on disk; wrap in '__debug__' context to silence stdout noise and obtain direct return messages.",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12286"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-5373dd6b",
      "description": "A language code fails locale normalization and you suspect the wrong separator (underscore vs hyphen) → django.utils.translation.to_locale converts hyphens to underscores (en-us → en_US). Only the convert",
      "category": "api_usage",
      "steps": [
        {
          "env_description": "A language code fails locale normalization and you suspect the wrong separator (underscore vs hyphen)",
          "reasoning": "django.utils.translation.to_locale converts hyphens to underscores (en-us → en_US). Only the converted form must exist in locale dirs even though the settings use hyphens.",
          "action": "Always apply 'to_locale' before disk lookup: if os.path.exists(os.path.join(dir, to_locale(lang), 'LC_MESSAGES')) then emit OK else keep checking base language.",
          "action_type": "api_usage"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12286"
      ],
      "frequency": 1,
      "pattern": [
        "api_usage"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-889ac0be",
      "description": "If `TransactionTestCase.serialized_rollback=True` raises IntegrityError on restore, examine the order that fixtures are deserialized → Dependant objects (FK, M2M) must be inserted after the rows they reference; the natural key round-tr",
      "category": "testing",
      "steps": [
        {
          "env_description": "If `TransactionTestCase.serialized_rollback=True` raises IntegrityError on restore, examine the order that fixtures are deserialized",
          "reasoning": "Dependant objects (FK, M2M) must be inserted after the rows they reference; the natural key round-trip may re-order rows incorrectly",
          "action": "When you construct test data, add `class Meta: ordering = ['pk']` or sort `serializers.serialize()` output so parents appear before children",
          "action_type": "testing"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12453"
      ],
      "frequency": 1,
      "pattern": [
        "testing"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-2717ea46",
      "description": "When custom user-defined primary keys are used, objects can’t be reliably identified by nat-key only; deserialization may recreate them with new pks → Deserialization uses `(model, natural-key)`, but the re-created row gets a fresh pk; children with f",
      "category": "testing",
      "steps": [
        {
          "env_description": "When custom user-defined primary keys are used, objects can’t be reliably identified by nat-key only; deserialization may recreate them with new pks",
          "reasoning": "Deserialization uses `(model, natural-key)`, but the re-created row gets a fresh pk; children with foreign keys still point to the old value",
          "action": "Serialize with primary keys (`fields='__all__'`) instead of natural keys, or sort objects to ensure parents are inserted before children",
          "action_type": "testing"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12453"
      ],
      "frequency": 1,
      "pattern": [
        "testing"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-4fa0404b",
      "description": "After saving a fixture, check `connection.ops.sql_table_creation_suffix()` in the backend’s `create_test_db` → If the suffix contains `DEFERRABLE INITIALLY DEFERRED`, foreign-key checks can be postponed; if it d",
      "category": "configuration",
      "steps": [
        {
          "env_description": "After saving a fixture, check `connection.ops.sql_table_creation_suffix()` in the backend’s `create_test_db`",
          "reasoning": "If the suffix contains `DEFERRABLE INITIALLY DEFERRED`, foreign-key checks can be postponed; if it does not, ordering is strictly enforced at insert",
          "action": "In your custom backend method, explicitly add `DEFERRABLE INITIALLY DEFERRED` or wrap the insertion in `SET CONSTRAINTS ALL DEFERRED` before deserializing",
          "action_type": "configuration"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12453"
      ],
      "frequency": 1,
      "pattern": [
        "configuration"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-7d03309a",
      "description": "If you’re writing a regression test that needs `serialized_rollback=True`, preload the database once and call `loaddata` manually instead of letting the test runner do it → Manual invocation lets you pass `--verbosity=3` to inspect the exact order used and discover fk-orde",
      "category": "debugging",
      "steps": [
        {
          "env_description": "If you’re writing a regression test that needs `serialized_rollback=True`, preload the database once and call `loaddata` manually instead of letting the test runner do it",
          "reasoning": "Manual invocation lets you pass `--verbosity=3` to inspect the exact order used and discover fk-ordering failures before they fail inside the test",
          "action": "Create a simple management command or standalone script that calls `loaddata` exactly as the test framework would and print each deserialized object",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12453"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-62f4fbe3",
      "description": "When fixing ordering on SQLite, notice that `PRAGMA foreign_keys=OFF` does not persist across the single SQL statement executed by `cursor.execute()` → It is restored at the end of each statement; you must wrap entire fixture loading in one big SQL blo",
      "category": "api_usage",
      "steps": [
        {
          "env_description": "When fixing ordering on SQLite, notice that `PRAGMA foreign_keys=OFF` does not persist across the single SQL statement executed by `cursor.execute()`",
          "reasoning": "It is restored at the end of each statement; you must wrap entire fixture loading in one big SQL block or use temporary deferred constraints",
          "action": "Execute `cursor.executescript('PRAGMA foreign_keys=OFF; -- full fixture SQL -- PRAGMA foreign_keys=ON;')` so the pragma stays on through the whole script",
          "action_type": "api_usage"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12453"
      ],
      "frequency": 1,
      "pattern": [
        "api_usage"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-b4c5e31e",
      "description": "When Child model inherits from Parent with Meta.ordering = [\"-pk\"] and queries return wrong order → The SQL compiler was building the ORDER BY clause against the parent table's alias but referring to ",
      "category": "debugging",
      "steps": [
        {
          "env_description": "When Child model inherits from Parent with Meta.ordering = [\"-pk\"] and queries return wrong order",
          "reasoning": "The SQL compiler was building the ORDER BY clause against the parent table's alias but referring to a column name that only exists in the child table's pk field",
          "action": "In sql/compiler.py, use self.query.get_meta().db_table to determine the correct table alias for ordering column references instead of assuming it's always the parent's alias",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12470"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-691bd93f",
      "description": "When debugging 'pk' column resolution in multi-table inheritance queries → Django multi-table inheritance stores the child's primary key in its own table and creates a one-to-",
      "category": "debugging",
      "steps": [
        {
          "env_description": "When debugging 'pk' column resolution in multi-table inheritance queries",
          "reasoning": "Django multi-table inheritance stores the child's primary key in its own table and creates a one-to-one relation to the parent, so 'pk' column exists only in the child's table",
          "action": "Check the generated SQL to confirm the ORDER BY clause references the correct table alias that contains the actual pk column",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12470"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-12137276",
      "description": "When inherited model Meta options don't apply correctly in SQL generation → Meta.ordering gets inherited but the SQL compiler may use the wrong table context when resolving the",
      "category": "refactoring",
      "steps": [
        {
          "env_description": "When inherited model Meta options don't apply correctly in SQL generation",
          "reasoning": "Meta.ordering gets inherited but the SQL compiler may use the wrong table context when resolving the ordering fields",
          "action": "Override get_meta() or ensure the query's get_meta() returns the correct model metadata for the child model, not the parent",
          "action_type": "refactoring"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12470"
      ],
      "frequency": 1,
      "pattern": [
        "refactoring"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-037355d5",
      "description": "If a 'many-to-many intermediary model with more than 2 ForeignKeys' raises a hint about 'recursive relationships' that does not mention through_fields → Django was re-using the generic recursive-relation hint instead of the specific m2m multi-FK hint me",
      "category": "debugging",
      "steps": [
        {
          "env_description": "If a 'many-to-many intermediary model with more than 2 ForeignKeys' raises a hint about 'recursive relationships' that does not mention through_fields",
          "reasoning": "Django was re-using the generic recursive-relation hint instead of the specific m2m multi-FK hint mentioning through_fields",
          "action": "Inside django.db.models.fields.related.ManyToManyField._check_terminating_field(), ensure the error message switches from RECURSIVE_RELATIONSHIP_INVALID to FIELD_NAME_CLASH when through_fields is unset and more than 2 FKs exist",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12497"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-b60d65b7",
      "description": "When the error message for 'through=' is 'None' → The string path for the error message is cached and will be reused in templates; changing the messag",
      "category": "debugging",
      "steps": [
        {
          "env_description": "When the error message for 'through=' is 'None'",
          "reasoning": "The string path for the error message is cached and will be reused in templates; changing the message text does not flush the cache",
          "action": "After editing the hint text, forcibly call django.utils.translation._make_lazy_string() on the new string to ensure the template renders the new wording on the next test run",
          "action_type": "debugging"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12497"
      ],
      "frequency": 1,
      "pattern": [
        "debugging"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-9061e0d6",
      "description": "If adding a ManyToManyField on a dynamically created model for testing the hint message → The field’s system checks run only when the model is prepared; creating the model in the test may no",
      "category": "testing",
      "steps": [
        {
          "env_description": "If adding a ManyToManyField on a dynamically created model for testing the hint message",
          "reasoning": "The field’s system checks run only when the model is prepared; creating the model in the test may not trigger checks until models are registered with apps",
          "action": "Wrap the new Field instance with Model.add_to_class() and explicitly call _check_lazy_fail() or collect errors via field.check(); both force the checks without migrating",
          "action_type": "testing"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12497"
      ],
      "frequency": 1,
      "pattern": [
        "testing"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-40361bd9",
      "description": "When the hint says 'recursively' but the relation is not actually recursive → Django’s message constant RECURSIVE_RELATIONSHIP_INVALID overlaps with the case where multiple FKs e",
      "category": "refactoring",
      "steps": [
        {
          "env_description": "When the hint says 'recursively' but the relation is not actually recursive",
          "reasoning": "Django’s message constant RECURSIVE_RELATIONSHIP_INVALID overlaps with the case where multiple FKs exist on the m2m through model",
          "action": "Replace the constant with FIELD_NAME_CLASH (or a new constant) and update the message to read something like '(fields.E340) The intermediary model %s has more than two foreign keys; you must specify which two to use via through_fields.'",
          "action_type": "refactoring"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12497"
      ],
      "frequency": 1,
      "pattern": [
        "refactoring"
      ],
      "metadata": {}
    },
    {
      "id": "exp-general-5b62ef47",
      "description": "If a Django error message test fails after the fix string appears to be in place → The admin template string uses %(hint)s interpolation; a tiny trailing period or space difference wi",
      "category": "testing",
      "steps": [
        {
          "env_description": "If a Django error message test fails after the fix string appears to be in place",
          "reasoning": "The admin template string uses %(hint)s interpolation; a tiny trailing period or space difference will make the assertion mismatch",
          "action": "Strip punctuation and newlines from both expected and actual strings before asserting equality in the test, or compare only the key part of the message that mentions 'through_fields'",
          "action_type": "testing"
        }
      ],
      "level": 1,
      "source_instances": [
        "django__django-12497"
      ],
      "frequency": 1,
      "pattern": [
        "testing"
      ],
      "metadata": {}
    }
  ],
  "count": 33
}