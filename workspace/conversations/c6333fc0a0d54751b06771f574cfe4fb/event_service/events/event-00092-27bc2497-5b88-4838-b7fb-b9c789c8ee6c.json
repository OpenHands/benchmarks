{"kind": "ObservationEvent", "id": "27bc2497-5b88-4838-b7fb-b9c789c8ee6c", "timestamp": "2025-09-25T11:26:20.882608", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_01WvVfcSdVLLAZWGgqEnQLDX", "observation": {"kind": "StrReplaceEditorObservation", "command": "create", "output": "File created successfully at: /tmp/tmp_qu0p03y/astropy/comprehensive_test.py", "path": "/tmp/tmp_qu0p03y/astropy/comprehensive_test.py", "prev_exist": false, "new_content": "#!/usr/bin/env python3\n\"\"\"\nComprehensive test of the fix for misleading AttributeError messages in subclassed SkyCoord.\n\"\"\"\n\nprint(\"=== COMPREHENSIVE TEST OF THE FIX ===\")\n\n# Mock the frame_transform_graph and related classes for testing\nclass MockFrameTransformGraph:\n    frame_attributes = {'ra', 'dec', 'distance'}  # Some common attributes\n    \n    def lookup_name(self, name):\n        if name in ['icrs', 'galactic']:\n            return MockFrame\n        return None\n\nclass MockFrame:\n    def __init__(self):\n        self.frame_attributes = {'ra', 'dec'}\n        \n    def is_transformable_to(self, other):\n        return True\n\nframe_transform_graph = MockFrameTransformGraph()\n\nclass TestSkyCoord:\n    \"\"\"Test version of SkyCoord with the fixed __getattr__ method.\"\"\"\n    \n    def __init__(self, *args, **kwargs):\n        self._sky_coord_frame = MockFrame()\n        self.ra = \"mock_ra\"\n        self.dec = \"mock_dec\"\n        \n    def _is_name(self, string):\n        return string in ['icrs', 'galactic']\n        \n    @property\n    def frame(self):\n        return self._sky_coord_frame\n        \n    def transform_to(self, frame):\n        return self\n        \n    def __getattr__(self, attr):\n        \"\"\"\n        Fixed version of the SkyCoord __getattr__ method.\n        \"\"\"\n        if \"_sky_coord_frame\" in self.__dict__:\n            if self._is_name(attr):\n                return self\n\n            # Frame attributes handling\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.frame_attributes:\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, \"_\" + attr, None)\n\n            # Delegate to frame\n            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Frame transformation\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # THE FIX: Check if the attribute exists as a property or descriptor\n        for cls in type(self).__mro__:\n            if attr in cls.__dict__:\n                class_attr = cls.__dict__[attr]\n                if isinstance(class_attr, (property, staticmethod, classmethod)) or hasattr(class_attr, '__get__'):\n                    # Re-access to get the original error message\n                    return super().__getattribute__(attr)\n\n        # Fail with generic message for truly missing attributes\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n\nprint(\"1. Testing the main issue case...\")\n\nclass CustomCoord1(TestSkyCoord):\n    @property\n    def prop(self):\n        return self.random_attr  # Missing attribute\n\nc1 = CustomCoord1()\ntry:\n    result = c1.prop\n    print(\"   \u274c UNEXPECTED: Should have raised AttributeError\")\nexcept AttributeError as e:\n    error_msg = str(e)\n    if \"'random_attr'\" in error_msg:\n        print(f\"   \u2705 CORRECT: {e}\")\n    else:\n        print(f\"   \u274c WRONG: {e}\")\n\nprint(\"\\n2. Testing property that accesses existing attribute...\")\n\nclass CustomCoord2(TestSkyCoord):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.existing_attr = \"I exist!\"\n        \n    @property\n    def working_prop(self):\n        return self.existing_attr\n\nc2 = CustomCoord2()\ntry:\n    result = c2.working_prop\n    print(f\"   \u2705 CORRECT: working_prop = {result}\")\nexcept Exception as e:\n    print(f\"   \u274c UNEXPECTED ERROR: {e}\")\n\nprint(\"\\n3. Testing direct access to non-existent attribute...\")\n\ntry:\n    result = c1.truly_missing\n    print(\"   \u274c UNEXPECTED: Should have raised AttributeError\")\nexcept AttributeError as e:\n    error_msg = str(e)\n    if \"'truly_missing'\" in error_msg:\n        print(f\"   \u2705 CORRECT: {e}\")\n    else:\n        print(f\"   \u274c WRONG: {e}\")\n\nprint(\"\\n4. Testing frame attribute access...\")\n\ntry:\n    result = c1.ra  # This should work via existing attribute\n    print(f\"   \u2705 CORRECT: ra = {result}\")\nexcept Exception as e:\n    print(f\"   \u274c UNEXPECTED ERROR: {e}\")\n\nprint(\"\\n5. Testing frame transformation...\")\n\ntry:\n    result = c1.icrs  # This should work via _is_name\n    print(f\"   \u2705 CORRECT: icrs transformation works\")\nexcept Exception as e:\n    print(f\"   \u274c UNEXPECTED ERROR: {e}\")\n\nprint(\"\\n6. Testing property with nested attribute access...\")\n\nclass CustomCoord3(TestSkyCoord):\n    @property\n    def nested_prop(self):\n        # This will try to access self.level1, which doesn't exist\n        return self.level1.level2.level3\n\nc3 = CustomCoord3()\ntry:\n    result = c3.nested_prop\n    print(\"   \u274c UNEXPECTED: Should have raised AttributeError\")\nexcept AttributeError as e:\n    error_msg = str(e)\n    if \"'level1'\" in error_msg:\n        print(f\"   \u2705 CORRECT: {e}\")\n    else:\n        print(f\"   \u274c WRONG: {e}\")\n\nprint(\"\\n7. Testing staticmethod and classmethod...\")\n\nclass CustomCoord4(TestSkyCoord):\n    @staticmethod\n    def static_method():\n        # This will access a non-existent module-level variable\n        return nonexistent_variable\n        \n    @classmethod  \n    def class_method(cls):\n        # This will access a non-existent class attribute\n        return cls.nonexistent_class_attr\n\nc4 = CustomCoord4()\n\n# Test staticmethod\ntry:\n    result = c4.static_method()\n    print(\"   \u274c UNEXPECTED: Should have raised NameError or AttributeError\")\nexcept (NameError, AttributeError) as e:\n    if \"nonexistent_variable\" in str(e):\n        print(f\"   \u2705 CORRECT: staticmethod error: {e}\")\n    else:\n        print(f\"   \u2753 DIFFERENT: {e}\")\n\n# Test classmethod\ntry:\n    result = c4.class_method()\n    print(\"   \u274c UNEXPECTED: Should have raised AttributeError\")\nexcept AttributeError as e:\n    if \"nonexistent_class_attr\" in str(e):\n        print(f\"   \u2705 CORRECT: classmethod error: {e}\")\n    else:\n        print(f\"   \u2753 DIFFERENT: {e}\")\n\nprint(\"\\n8. Testing multiple inheritance...\")\n\nclass Mixin:\n    @property\n    def mixin_prop(self):\n        return self.mixin_missing_attr\n\nclass CustomCoord5(Mixin, TestSkyCoord):\n    pass\n\nc5 = CustomCoord5()\ntry:\n    result = c5.mixin_prop\n    print(\"   \u274c UNEXPECTED: Should have raised AttributeError\")\nexcept AttributeError as e:\n    error_msg = str(e)\n    if \"'mixin_missing_attr'\" in error_msg:\n        print(f\"   \u2705 CORRECT: {e}\")\n    else:\n        print(f\"   \u274c WRONG: {e}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"SUMMARY:\")\nprint(\"All tests should show '\u2705 CORRECT' for the fix to be working properly.\")\nprint(\"The fix ensures that AttributeError messages from within properties\")\nprint(\"are not masked by the generic SkyCoord.__getattr__ error message.\")"}, "action_id": "28c15e67-f542-4e13-babf-55de7e9a1921"}