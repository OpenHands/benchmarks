{"kind": "ObservationEvent", "id": "e9d5ecd3-876b-4f66-91a6-f851db80dea5", "timestamp": "2025-09-25T11:21:09.276080", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_016BwcYNE72ne6B4xd3cu9yY", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmp3xm1sm4z/astropy/astropy/io/registry/tests/test_registries.py:\n     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\n     3\t\"\"\"\n     4\tTest :mod:`astropy.io.registry`.\n     5\t\n     6\t.. todo::\n     7\t\n     8\t    Don't rely on Table for tests\n     9\t\n    10\t\"\"\"\n    11\t\n    12\timport os\n    13\tfrom collections import Counter\n    14\tfrom copy import deepcopy\n    15\tfrom io import StringIO\n    16\t\n    17\timport numpy as np\n    18\timport pytest\n    19\t\n    20\timport astropy.units as u\n    21\tfrom astropy.io import registry as io_registry\n    22\tfrom astropy.io.registry import (\n    23\t    IORegistryError,\n    24\t    UnifiedInputRegistry,\n    25\t    UnifiedIORegistry,\n    26\t    UnifiedOutputRegistry,\n    27\t    compat,\n    28\t)\n    29\tfrom astropy.io.registry.base import _UnifiedIORegistryBase\n    30\tfrom astropy.io.registry.compat import default_registry\n    31\tfrom astropy.table import Table\n    32\t\n    33\t###############################################################################\n    34\t# pytest setup and fixtures\n    35\t\n    36\t\n    37\tclass UnifiedIORegistryBaseSubClass(_UnifiedIORegistryBase):\n    38\t    \"\"\"Non-abstract subclass of UnifiedIORegistryBase for testing.\"\"\"\n    39\t\n    40\t    def get_formats(self, data_class=None):\n    41\t        return None\n    42\t\n    43\t\n    44\tclass EmptyData:\n    45\t    \"\"\"\n    46\t    Thing that can read and write.\n    47\t    Note that the read/write are the compatibility methods, which allow for the\n    48\t    kwarg ``registry``. This allows us to not subclass ``EmptyData`` for each\n    49\t    of the types of registry (read-only, ...) and use this class everywhere.\n    50\t    \"\"\"\n    51\t\n    52\t    read = classmethod(io_registry.read)\n    53\t    write = io_registry.write\n    54\t\n    55\t\n    56\tclass OtherEmptyData:\n    57\t    \"\"\"A different class with different I/O\"\"\"\n    58\t\n    59\t    read = classmethod(io_registry.read)\n    60\t    write = io_registry.write\n    61\t\n    62\t\n    63\tdef empty_reader(*args, **kwargs):\n    64\t    return EmptyData()\n    65\t\n    66\t\n    67\tdef empty_writer(table, *args, **kwargs):\n    68\t    return \"status: success\"\n    69\t\n    70\t\n    71\tdef empty_identifier(*args, **kwargs):\n    72\t    return True\n    73\t\n    74\t\n    75\t@pytest.fixture\n    76\tdef fmtcls1():\n    77\t    return (\"test1\", EmptyData)\n    78\t\n    79\t\n    80\t@pytest.fixture\n    81\tdef fmtcls2():\n    82\t    return (\"test2\", EmptyData)\n    83\t\n    84\t\n    85\t@pytest.fixture(params=[\"test1\", \"test2\"])\n    86\tdef fmtcls(request):\n    87\t    yield (request.param, EmptyData)\n    88\t\n    89\t\n    90\t@pytest.fixture\n    91\tdef original():\n    92\t    ORIGINAL = {}\n    93\t    ORIGINAL[\"readers\"] = deepcopy(default_registry._readers)\n    94\t    ORIGINAL[\"writers\"] = deepcopy(default_registry._writers)\n    95\t    ORIGINAL[\"identifiers\"] = deepcopy(default_registry._identifiers)\n    96\t    return ORIGINAL\n    97\t\n    98\t\n    99\t###############################################################################\n   100\t\n   101\t\n   102\tdef test_fmcls1_fmtcls2(fmtcls1, fmtcls2):\n   103\t    \"\"\"Just check a fact that we rely on in other tests.\"\"\"\n   104\t    assert fmtcls1[1] is fmtcls2[1]\n   105\t\n   106\t\n   107\tdef test_IORegistryError():\n   108\t    with pytest.raises(IORegistryError, match=\"just checking\"):\n   109\t        raise IORegistryError(\"just checking\")\n   110\t\n   111\t\n   112\tclass TestUnifiedIORegistryBase:\n   113\t    \"\"\"Test :class:`astropy.io.registry.UnifiedIORegistryBase`.\"\"\"\n   114\t\n   115\t    def setup_class(self):\n   116\t        \"\"\"Setup class. This is called 1st by pytest.\"\"\"\n   117\t        self._cls = UnifiedIORegistryBaseSubClass\n   118\t\n   119\t    @pytest.fixture\n   120\t    def registry(self):\n   121\t        \"\"\"I/O registry. Cleaned before and after each function.\"\"\"\n   122\t        registry = self._cls()\n   123\t\n   124\t        HAS_READERS = hasattr(registry, \"_readers\")\n   125\t        HAS_WRITERS = hasattr(registry, \"_writers\")\n   126\t\n   127\t        # copy and clear original registry\n   128\t        ORIGINAL = {}\n   129\t        ORIGINAL[\"identifiers\"] = deepcopy(registry._identifiers)\n   130\t        registry._identifiers.clear()\n   131\t        if HAS_READERS:\n   132\t            ORIGINAL[\"readers\"] = deepcopy(registry._readers)\n   133\t            registry._readers.clear()\n   134\t        if HAS_WRITERS:\n   135\t            ORIGINAL[\"writers\"] = deepcopy(registry._writers)\n   136\t            registry._writers.clear()\n   137\t\n   138\t        yield registry\n   139\t\n   140\t        registry._identifiers.clear()\n   141\t        registry._identifiers.update(ORIGINAL[\"identifiers\"])\n   142\t        if HAS_READERS:\n   143\t            registry._readers.clear()\n   144\t            registry._readers.update(ORIGINAL[\"readers\"])\n   145\t        if HAS_WRITERS:\n   146\t            registry._writers.clear()\n   147\t            registry._writers.update(ORIGINAL[\"writers\"])\n   148\t\n   149\t    # ===========================================\n   150\t\n   151\t    def test_get_formats(self, registry):\n   152\t        \"\"\"Test ``registry.get_formats()``.\"\"\"\n   153\t        # defaults\n   154\t        assert registry.get_formats() is None\n   155\t        # (kw)args don't matter\n   156\t        assert registry.get_formats(data_class=24) is None\n   157\t\n   158\t    def test_delay_doc_updates(self, registry, fmtcls1):\n   159\t        \"\"\"Test ``registry.delay_doc_updates()``.\"\"\"\n   160\t        # TODO! figure out what can be tested\n   161\t        with registry.delay_doc_updates(EmptyData):\n   162\t            registry.register_identifier(*fmtcls1, empty_identifier)\n   163\t\n   164\t    def test_register_identifier(self, registry, fmtcls1, fmtcls2):\n   165\t        \"\"\"Test ``registry.register_identifier()``.\"\"\"\n   166\t        # initial check it's not registered\n   167\t        assert fmtcls1 not in registry._identifiers\n   168\t        assert fmtcls2 not in registry._identifiers\n   169\t\n   170\t        # register\n   171\t        registry.register_identifier(*fmtcls1, empty_identifier)\n   172\t        registry.register_identifier(*fmtcls2, empty_identifier)\n   173\t        assert fmtcls1 in registry._identifiers\n   174\t        assert fmtcls2 in registry._identifiers\n   175\t\n   176\t    def test_register_identifier_invalid(self, registry, fmtcls):\n   177\t        \"\"\"Test calling ``registry.register_identifier()`` twice.\"\"\"\n   178\t        fmt, cls = fmtcls\n   179\t        registry.register_identifier(fmt, cls, empty_identifier)\n   180\t        with pytest.raises(IORegistryError) as exc:\n   181\t            registry.register_identifier(fmt, cls, empty_identifier)\n   182\t        assert (\n   183\t            str(exc.value) == f\"Identifier for format '{fmt}' and class \"\n   184\t            f\"'{cls.__name__}' is already defined\"\n   185\t        )\n   186\t\n   187\t    def test_register_identifier_force(self, registry, fmtcls1):\n   188\t        registry.register_identifier(*fmtcls1, empty_identifier)\n   189\t        registry.register_identifier(*fmtcls1, empty_identifier, force=True)\n   190\t        assert fmtcls1 in registry._identifiers\n   191\t\n   192\t    # -----------------------\n   193\t\n   194\t    def test_unregister_identifier(self, registry, fmtcls1):\n   195\t        \"\"\"Test ``registry.unregister_identifier()``.\"\"\"\n   196\t        registry.register_identifier(*fmtcls1, empty_identifier)\n   197\t        assert fmtcls1 in registry._identifiers\n   198\t\n   199\t        registry.unregister_identifier(*fmtcls1)\n   200\t        assert fmtcls1 not in registry._identifiers\n   201\t\n   202\t    def test_unregister_identifier_invalid(self, registry, fmtcls):\n   203\t        \"\"\"Test ``registry.unregister_identifier()``.\"\"\"\n   204\t        fmt, cls = fmtcls\n   205\t        with pytest.raises(IORegistryError) as exc:\n   206\t            registry.unregister_identifier(fmt, cls)\n   207\t        assert (\n   208\t            str(exc.value)\n   209\t            == f\"No identifier defined for format '{fmt}' and class '{cls.__name__}'\"\n   210\t        )\n   211\t\n   212\t    def test_identify_format(self, registry, fmtcls1):\n   213\t        \"\"\"Test ``registry.identify_format()``.\"\"\"\n   214\t        fmt, cls = fmtcls1\n   215\t        args = (None, cls, None, None, (None,), {})\n   216\t\n   217\t        # test no formats to identify\n   218\t        formats = registry.identify_format(*args)\n   219\t        assert formats == []\n   220\t\n   221\t        # test there is a format to identify\n   222\t        registry.register_identifier(fmt, cls, empty_identifier)\n   223\t        formats = registry.identify_format(*args)\n   224\t        assert fmt in formats\n   225\t\n   226\t    # ===========================================\n   227\t    # Compat tests\n   228\t\n   229\t    def test_compat_register_identifier(self, registry, fmtcls1):\n   230\t        # with registry specified\n   231\t        assert fmtcls1 not in registry._identifiers\n   232\t        compat.register_identifier(*fmtcls1, empty_identifier, registry=registry)\n   233\t        assert fmtcls1 in registry._identifiers\n   234\t\n   235\t        # without registry specified it becomes default_registry\n   236\t        if registry is not default_registry:\n   237\t            assert fmtcls1 not in default_registry._identifiers\n   238\t            try:\n   239\t                compat.register_identifier(*fmtcls1, empty_identifier)\n   240\t            except Exception:\n   241\t                pass\n   242\t            else:\n   243\t                assert fmtcls1 in default_registry._identifiers\n   244\t            finally:\n   245\t                default_registry._identifiers.pop(fmtcls1)\n   246\t\n   247\t    def test_compat_unregister_identifier(self, registry, fmtcls1):\n   248\t        # with registry specified\n   249\t        registry.register_identifier(*fmt<response clipped><NOTE>Due to the max output limit, only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE>ls1):\n   250\t        \"\"\"Most writers will return None, but other values are not forbidden.\"\"\"\n   251\t        fmt, cls = fmtcls1\n   252\t        registry.register_writer(fmt, cls, empty_writer)\n   253\t        res = cls.write(cls(), format=fmt, registry=registry)\n   254\t        assert res == \"status: success\"\n   255\t\n   256\t    # ===========================================\n   257\t    # Compat tests\n   258\t\n   259\t    def test_compat_register_writer(self, registry, fmtcls1):\n   260\t        # with registry specified\n   261\t        assert fmtcls1 not in registry._writers\n   262\t        compat.register_writer(*fmtcls1, empty_writer, registry=registry)\n   263\t        assert fmtcls1 in registry._writers\n   264\t        registry.unregister_writer(*fmtcls1)\n   265\t\n   266\t        # without registry specified it becomes default_registry\n   267\t        if registry is not default_registry:\n   268\t            assert fmtcls1 not in default_registry._writers\n   269\t            try:\n   270\t                compat.register_writer(*fmtcls1, empty_writer)\n   271\t            except Exception:\n   272\t                pass\n   273\t            else:\n   274\t                assert fmtcls1 in default_registry._writers\n   275\t            finally:\n   276\t                default_registry._writers.pop(fmtcls1)\n   277\t\n   278\t    def test_compat_unregister_writer(self, registry, fmtcls1):\n   279\t        # with registry specified\n   280\t        registry.register_writer(*fmtcls1, empty_writer)\n   281\t        assert fmtcls1 in registry._writers\n   282\t        compat.unregister_writer(*fmtcls1, registry=registry)\n   283\t        assert fmtcls1 not in registry._writers\n   284\t\n   285\t        # without registry specified it becomes default_registry\n   286\t        if registry is not default_registry:\n   287\t            assert fmtcls1 not in default_registry._writers\n   288\t            default_registry.register_writer(*fmtcls1, empty_writer)\n   289\t            assert fmtcls1 in default_registry._writers\n   290\t            compat.unregister_writer(*fmtcls1)\n   291\t            assert fmtcls1 not in default_registry._writers\n   292\t\n   293\t    def test_compat_get_writer(self, registry, fmtcls1):\n   294\t        # with registry specified\n   295\t        registry.register_writer(*fmtcls1, empty_writer)\n   296\t        writer = compat.get_writer(*fmtcls1, registry=registry)\n   297\t        assert writer is empty_writer\n   298\t\n   299\t        # without registry specified it becomes default_registry\n   300\t        if registry is not default_registry:\n   301\t            assert fmtcls1 not in default_registry._writers\n   302\t            default_registry.register_writer(*fmtcls1, empty_writer)\n   303\t            assert fmtcls1 in default_registry._writers\n   304\t            writer = compat.get_writer(*fmtcls1)\n   305\t            assert writer is empty_writer\n   306\t            default_registry.unregister_writer(*fmtcls1)\n   307\t            assert fmtcls1 not in default_registry._writers\n   308\t\n   309\t    def test_compat_write(self, registry, fmtcls1):\n   310\t        fmt, cls = fmtcls1\n   311\t\n   312\t        # with registry specified\n   313\t        registry.register_writer(*fmtcls1, empty_writer)\n   314\t        res = compat.write(cls(), format=fmt, registry=registry)\n   315\t        assert res == \"status: success\"\n   316\t\n   317\t        # without registry specified it becomes default_registry\n   318\t        if registry is not default_registry:\n   319\t            assert fmtcls1 not in default_registry._writers\n   320\t            default_registry.register_writer(*fmtcls1, empty_writer)\n   321\t            assert fmtcls1 in default_registry._writers\n   322\t            res = compat.write(cls(), format=fmt)\n   323\t            assert res == \"status: success\"\n   324\t            default_registry.unregister_writer(*fmtcls1)\n   325\t            assert fmtcls1 not in default_registry._writers\n   326\t\n   327\t\n   328\tclass TestUnifiedIORegistry(TestUnifiedInputRegistry, TestUnifiedOutputRegistry):\n   329\t    def setup_class(self):\n   330\t        \"\"\"Setup class. This is called 1st by pytest.\"\"\"\n   331\t        self._cls = UnifiedIORegistry\n   332\t\n   333\t    # ===========================================\n   334\t\n   335\t    @pytest.mark.skip(\"TODO!\")\n   336\t    def test_get_formats(self, registry):\n   337\t        \"\"\"Test ``registry.get_formats()``.\"\"\"\n   338\t        assert False\n   339\t\n   340\t    def test_delay_doc_updates(self, registry, fmtcls1):\n   341\t        \"\"\"Test ``registry.delay_doc_updates()``.\"\"\"\n   342\t        super().test_delay_doc_updates(registry, fmtcls1)\n   343\t\n   344\t    # -----------------------\n   345\t\n   346\t    def test_identifier_origin(self, registry, fmtcls1, fmtcls2):\n   347\t        fmt1, cls = fmtcls1\n   348\t        fmt2, _ = fmtcls2\n   349\t\n   350\t        registry.register_identifier(fmt1, cls, lambda o, *x, **y: o == \"read\")\n   351\t        registry.register_identifier(fmt2, cls, lambda o, *x, **y: o == \"write\")\n   352\t        registry.register_reader(fmt1, cls, empty_reader)\n   353\t        registry.register_writer(fmt2, cls, empty_writer)\n   354\t\n   355\t        # There should not be too many formats defined\n   356\t        cls.read(registry=registry)\n   357\t        cls().write(registry=registry)\n   358\t\n   359\t        with pytest.raises(IORegistryError) as exc:\n   360\t            cls.read(format=fmt2, registry=registry)\n   361\t        assert str(exc.value).startswith(\n   362\t            f\"No reader defined for format '{fmt2}' and class '{cls.__name__}'\"\n   363\t        )\n   364\t\n   365\t        with pytest.raises(IORegistryError) as exc:\n   366\t            cls().write(format=fmt1, registry=registry)\n   367\t        assert str(exc.value).startswith(\n   368\t            f\"No writer defined for format '{fmt1}' and class '{cls.__name__}'\"\n   369\t        )\n   370\t\n   371\t\n   372\tclass TestDefaultRegistry(TestUnifiedIORegistry):\n   373\t    def setup_class(self):\n   374\t        \"\"\"Setup class. This is called 1st by pytest.\"\"\"\n   375\t        self._cls = lambda *args: default_registry\n   376\t\n   377\t\n   378\t# =============================================================================\n   379\t# Test compat\n   380\t# much of this is already tested above since EmptyData uses io_registry.X(),\n   381\t# which are the compat methods.\n   382\t\n   383\t\n   384\tdef test_dir():\n   385\t    \"\"\"Test all the compat methods are in the directory\"\"\"\n   386\t    dc = dir(compat)\n   387\t    for n in compat.__all__:\n   388\t        assert n in dc\n   389\t\n   390\t\n   391\tdef test_getattr():\n   392\t    for n in compat.__all__:\n   393\t        assert hasattr(compat, n)\n   394\t\n   395\t    with pytest.raises(AttributeError, match=\"module 'astropy.io.registry.compat'\"):\n   396\t        compat.this_is_definitely_not_in_this_module\n   397\t\n   398\t\n   399\t# =============================================================================\n   400\t# Table tests\n   401\t\n   402\t\n   403\tdef test_read_basic_table():\n   404\t    registry = Table.read._registry\n   405\t    data = np.array(\n   406\t        list(zip([1, 2, 3], [\"a\", \"b\", \"c\"])), dtype=[(\"A\", int), (\"B\", \"|U1\")]\n   407\t    )\n   408\t    try:\n   409\t        registry.register_reader(\"test\", Table, lambda x: Table(x))\n   410\t    except Exception:\n   411\t        pass\n   412\t    else:\n   413\t        t = Table.read(data, format=\"test\")\n   414\t        assert t.keys() == [\"A\", \"B\"]\n   415\t        for i in range(3):\n   416\t            assert t[\"A\"][i] == data[\"A\"][i]\n   417\t            assert t[\"B\"][i] == data[\"B\"][i]\n   418\t    finally:\n   419\t        registry._readers.pop(\"test\", None)\n   420\t\n   421\t\n   422\tclass TestSubclass:\n   423\t    \"\"\"\n   424\t    Test using registry with a Table sub-class\n   425\t    \"\"\"\n   426\t\n   427\t    @pytest.fixture(autouse=True)\n   428\t    def registry(self):\n   429\t        \"\"\"I/O registry. Not cleaned.\"\"\"\n   430\t        yield\n   431\t\n   432\t    def test_read_table_subclass(self):\n   433\t        class MyTable(Table):\n   434\t            pass\n   435\t\n   436\t        data = [\"a b\", \"1 2\"]\n   437\t        mt = MyTable.read(data, format=\"ascii\")\n   438\t        t = Table.read(data, format=\"ascii\")\n   439\t        assert np.all(mt == t)\n   440\t        assert mt.colnames == t.colnames\n   441\t        assert type(mt) is MyTable\n   442\t\n   443\t    def test_write_table_subclass(self):\n   444\t        buffer = StringIO()\n   445\t\n   446\t        class MyTable(Table):\n   447\t            pass\n   448\t\n   449\t        mt = MyTable([[1], [2]], names=[\"a\", \"b\"])\n   450\t        mt.write(buffer, format=\"ascii\")\n   451\t        assert buffer.getvalue() == os.linesep.join([\"a b\", \"1 2\", \"\"])\n   452\t\n   453\t    def test_read_table_subclass_with_columns_attributes(self, tmp_path):\n   454\t        \"\"\"Regression test for https://github.com/astropy/astropy/issues/7181\"\"\"\n   455\t\n   456\t        class MTable(Table):\n   457\t            pass\n   458\t\n   459\t        mt = MTable([[1, 2.5]], names=[\"a\"])\n   460\t        mt[\"a\"].unit = u.m\n   461\t        mt[\"a\"].format = \".4f\"\n   462\t        mt[\"a\"].description = \"hello\"\n   463\t\n   464\t        testfile = tmp_path / \"junk.fits\"\n   465\t        mt.write(testfile, overwrite=True)\n   466\t\n   467\t        t = MTable.read(testfile)\n   468\t        assert np.all(mt == t)\n   469\t        assert mt.colnames == t.colnames\n   470\t        assert type(t) is MTable\n   471\t        assert t[\"a\"].unit == u.m\n   472\t        assert t[\"a\"].format == \"{:13.4f}\"\n   473\t        assert t[\"a\"].description == \"hello\"\n   474\t\n", "path": "/tmp/tmp3xm1sm4z/astropy/astropy/io/registry/tests/test_registries.py", "prev_exist": true}, "action_id": "f5f9362d-3ecc-4661-a4a6-8dbc187fd34e"}