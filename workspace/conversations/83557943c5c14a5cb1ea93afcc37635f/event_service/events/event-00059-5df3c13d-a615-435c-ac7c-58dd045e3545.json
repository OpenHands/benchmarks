{"kind": "ObservationEvent", "id": "5df3c13d-a615-435c-ac7c-58dd045e3545", "timestamp": "2025-09-25T20:06:41.618495", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_017m3kTJKey9ZMJz2HWGZpSs", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmpkelcrhj5/astropy/astropy/io/fits/diff.py:\n     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\"\"\"\n     3\tFacilities for diffing two FITS files.  Includes objects for diffing entire\n     4\tFITS files, individual HDUs, FITS headers, or just FITS data.\n     5\t\n     6\tUsed to implement the fitsdiff program.\n     7\t\"\"\"\n     8\timport fnmatch\n     9\timport glob\n    10\timport io\n    11\timport operator\n    12\timport os\n    13\timport os.path\n    14\timport textwrap\n    15\tfrom collections import defaultdict\n    16\tfrom inspect import signature\n    17\tfrom itertools import islice\n    18\t\n    19\timport numpy as np\n    20\t\n    21\tfrom astropy import __version__\n    22\tfrom astropy.utils.diff import (\n    23\t    diff_values,\n    24\t    fixed_width_indent,\n    25\t    report_diff_values,\n    26\t    where_not_allclose,\n    27\t)\n    28\tfrom astropy.utils.misc import NOT_OVERWRITING_MSG\n    29\t\n    30\tfrom .card import BLANK_CARD, Card\n    31\t\n    32\t# HDUList is used in one of the doctests\n    33\tfrom .hdu.hdulist import HDUList, fitsopen  # pylint: disable=W0611\n    34\tfrom .hdu.table import _TableLikeHDU\n    35\tfrom .header import Header\n    36\tfrom .util import path_like\n    37\t\n    38\t__all__ = [\n    39\t    \"FITSDiff\",\n    40\t    \"HDUDiff\",\n    41\t    \"HeaderDiff\",\n    42\t    \"ImageDataDiff\",\n    43\t    \"RawDataDiff\",\n    44\t    \"TableDataDiff\",\n    45\t]\n    46\t\n    47\t# Column attributes of interest for comparison\n    48\t_COL_ATTRS = [\n    49\t    (\"unit\", \"units\"),\n    50\t    (\"null\", \"null values\"),\n    51\t    (\"bscale\", \"bscales\"),\n    52\t    (\"bzero\", \"bzeros\"),\n    53\t    (\"disp\", \"display formats\"),\n    54\t    (\"dim\", \"dimensions\"),\n    55\t]\n    56\t\n    57\t\n    58\tclass _BaseDiff:\n    59\t    \"\"\"\n    60\t    Base class for all FITS diff objects.\n    61\t\n    62\t    When instantiating a FITS diff object, the first two arguments are always\n    63\t    the two objects to diff (two FITS files, two FITS headers, etc.).\n    64\t    Instantiating a ``_BaseDiff`` also causes the diff itself to be executed.\n    65\t    The returned ``_BaseDiff`` instance has a number of attribute that describe\n    66\t    the results of the diff operation.\n    67\t\n    68\t    The most basic attribute, present on all ``_BaseDiff`` instances, is\n    69\t    ``.identical`` which is `True` if the two objects being compared are\n    70\t    identical according to the diff method for objects of that type.\n    71\t    \"\"\"\n    72\t\n    73\t    def __init__(self, a, b):\n    74\t        \"\"\"\n    75\t        The ``_BaseDiff`` class does not implement a ``_diff`` method and\n    76\t        should not be instantiated directly. Instead instantiate the\n    77\t        appropriate subclass of ``_BaseDiff`` for the objects being compared\n    78\t        (for example, use `HeaderDiff` to compare two `Header` objects.\n    79\t        \"\"\"\n    80\t        self.a = a\n    81\t        self.b = b\n    82\t\n    83\t        # For internal use in report output\n    84\t        self._fileobj = None\n    85\t        self._indent = 0\n    86\t\n    87\t        self._diff()\n    88\t\n    89\t    def __bool__(self):\n    90\t        \"\"\"\n    91\t        A ``_BaseDiff`` object acts as `True` in a boolean context if the two\n    92\t        objects compared are different.  Otherwise it acts as `False`.\n    93\t        \"\"\"\n    94\t        return not self.identical\n    95\t\n    96\t    @classmethod\n    97\t    def fromdiff(cls, other, a, b):\n    98\t        \"\"\"\n    99\t        Returns a new Diff object of a specific subclass from an existing diff\n   100\t        object, passing on the values for any arguments they share in common\n   101\t        (such as ignore_keywords).\n   102\t\n   103\t        For example::\n   104\t\n   105\t            >>> from astropy.io import fits\n   106\t            >>> hdul1, hdul2 = fits.HDUList(), fits.HDUList()\n   107\t            >>> headera, headerb = fits.Header(), fits.Header()\n   108\t            >>> fd = fits.FITSDiff(hdul1, hdul2, ignore_keywords=['*'])\n   109\t            >>> hd = fits.HeaderDiff.fromdiff(fd, headera, headerb)\n   110\t            >>> list(hd.ignore_keywords)\n   111\t            ['*']\n   112\t        \"\"\"\n   113\t        sig = signature(cls.__init__)\n   114\t        # The first 3 arguments of any Diff initializer are self, a, and b.\n   115\t        kwargs = {}\n   116\t        for arg in list(sig.parameters.keys())[3:]:\n   117\t            if hasattr(other, arg):\n   118\t                kwargs[arg] = getattr(other, arg)\n   119\t\n   120\t        return cls(a, b, **kwargs)\n   121\t\n   122\t    @property\n   123\t    def identical(self):\n   124\t        \"\"\"\n   125\t        `True` if all the ``.diff_*`` attributes on this diff instance are\n   126\t        empty, implying that no differences were found.\n   127\t\n   128\t        Any subclass of ``_BaseDiff`` must have at least one ``.diff_*``\n   129\t        attribute, which contains a non-empty value if and only if some\n   130\t        difference was found between the two objects being compared.\n   131\t        \"\"\"\n   132\t        return not any(\n   133\t            getattr(self, attr) for attr in self.__dict__ if attr.startswith(\"diff_\")\n   134\t        )\n   135\t\n   136\t    def report(self, fileobj=None, indent=0, overwrite=False):\n   137\t        \"\"\"\n   138\t        Generates a text report on the differences (if any) between two\n   139\t        objects, and either returns it as a string or writes it to a file-like\n   140\t        object.\n   141\t\n   142\t        Parameters\n   143\t        ----------\n   144\t        fileobj : file-like, string, or None, optional\n   145\t            If `None`, this method returns the report as a string. Otherwise it\n   146\t            returns `None` and writes the report to the given file-like object\n   147\t            (which must have a ``.write()`` method at a minimum), or to a new\n   148\t            file at the path specified.\n   149\t\n   150\t        indent : int\n   151\t            The number of 4 space tabs to indent the report.\n   152\t\n   153\t        overwrite : bool, optional\n   154\t            If ``True``, overwrite the output file if it exists. Raises an\n   155\t            ``OSError`` if ``False`` and the output file exists. Default is\n   156\t            ``False``.\n   157\t\n   158\t        Returns\n   159\t        -------\n   160\t        report : str or None\n   161\t        \"\"\"\n   162\t        return_string = False\n   163\t        filepath = None\n   164\t\n   165\t        if isinstance(fileobj, path_like):\n   166\t            fileobj = os.path.expanduser(fileobj)\n   167\t            if os.path.exists(fileobj) and not overwrite:\n   168\t                raise OSError(NOT_OVERWRITING_MSG.format(fileobj))\n   169\t            else:\n   170\t                filepath = fileobj\n   171\t                fileobj = open(filepath, \"w\")\n   172\t        elif fileobj is None:\n   173\t            fileobj = io.StringIO()\n   174\t            return_string = True\n   175\t\n   176\t        self._fileobj = fileobj\n   177\t        self._indent = indent  # This is used internally by _writeln\n   178\t\n   179\t        try:\n   180\t            self._report()\n   181\t        finally:\n   182\t            if filepath:\n   183\t                fileobj.close()\n   184\t\n   185\t        if return_string:\n   186\t            return fileobj.getvalue()\n   187\t\n   188\t    def _writeln(self, text):\n   189\t        self._fileobj.write(fixed_width_indent(text, self._indent) + \"\\n\")\n   190\t\n   191\t    def _diff(self):\n   192\t        raise NotImplementedError\n   193\t\n   194\t    def _report(self):\n   195\t        raise NotImplementedError\n   196\t\n   197\t\n   198\tclass FITSDiff(_BaseDiff):\n   199\t    \"\"\"Diff two FITS files by filename, or two `HDUList` objects.\n   200\t\n   201\t    `FITSDiff` objects have the following diff attributes:\n   202\t\n   203\t    - ``diff_hdu_count``: If the FITS files being compared have different\n   204\t      numbers of HDUs, this contains a 2-tuple of the number of HDUs in each\n   205\t      file.\n   206\t\n   207\t    - ``diff_hdus``: If any HDUs with the same index are different, this\n   208\t      contains a list of 2-tuples of the HDU index and the `HDUDiff` object\n   209\t      representing the differences between the two HDUs.\n   210\t    \"\"\"\n   211\t\n   212\t    def __init__(\n   213\t        self,\n   214\t        a,\n   215\t        b,\n   216\t        ignore_hdus=[],\n   217\t        ignore_keywords=[],\n   218\t        ignore_comments=[],\n   219\t        ignore_fields=[],\n   220\t        numdiffs=10,\n   221\t        rtol=0.0,\n   222\t        atol=0.0,\n   223\t        ignore_blanks=True,\n   224\t        ignore_blank_cards=True,\n   225\t    ):\n   226\t        \"\"\"\n   227\t        Parameters\n   228\t        ----------\n   229\t        a : str or `HDUList`\n   230\t            The filename of a FITS file on disk, or an `HDUList` object.\n   231\t\n   232\t        b : str or `HDUList`\n   233\t            The filename of a FITS file on disk, or an `HDUList` object to\n   234\t            compare to the first file.\n   235\t\n   236\t        ignore_hdus : sequence, optional\n   237\t            HDU names to ignore when comparing two FITS files or HDU lists; the\n   238\t            presence of these HDUs and their contents are ignored.  Wildcard\n   239\t            strings may also be included in the list.\n   240\t\n   241\t        ignore_keywords : sequence, optional\n   242\t            Header keywords to ignore when comparing two headers; the presence\n   243\t            of these keywords and their values are ignored.  Wildcard strings\n   244\t            may also be included in the list.\n   245\t\n   246\t        ignore_comments : sequence, optional\n   247\t            A list of header keywords whose comments should be ignored in the\n   248\t            comparison.  May contain wildc<response clipped><NOTE>Due to the max output limit, only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE>rsection(colsb_set), key=operator.attrgetter(\"name\")\n   249\t        )\n   250\t\n   251\t        self.common_column_names = {col.name.lower() for col in self.common_columns}\n   252\t\n   253\t        left_only_columns = {\n   254\t            col.name.lower(): col for col in colsa_set.difference(colsb_set)\n   255\t        }\n   256\t        right_only_columns = {\n   257\t            col.name.lower(): col for col in colsb_set.difference(colsa_set)\n   258\t        }\n   259\t\n   260\t        if left_only_columns or right_only_columns:\n   261\t            self.diff_columns = (left_only_columns, right_only_columns)\n   262\t            self.diff_column_names = ([], [])\n   263\t\n   264\t        if left_only_columns:\n   265\t            for col in self.a.columns:\n   266\t                if col.name.lower() in left_only_columns:\n   267\t                    self.diff_column_names[0].append(col.name)\n   268\t\n   269\t        if right_only_columns:\n   270\t            for col in self.b.columns:\n   271\t                if col.name.lower() in right_only_columns:\n   272\t                    self.diff_column_names[1].append(col.name)\n   273\t\n   274\t        # If the tables have a different number of rows, we don't compare the\n   275\t        # columns right now.\n   276\t        # TODO: It might be nice to optionally compare the first n rows where n\n   277\t        # is the minimum of the row counts between the two tables.\n   278\t        if len(self.a) != len(self.b):\n   279\t            self.diff_rows = (len(self.a), len(self.b))\n   280\t            return\n   281\t\n   282\t        # If the tables contain no rows there's no data to compare, so we're\n   283\t        # done at this point. (See ticket #178)\n   284\t        if len(self.a) == len(self.b) == 0:\n   285\t            return\n   286\t\n   287\t        # Like in the old fitsdiff, compare tables on a column by column basis\n   288\t        # The difficulty here is that, while FITS column names are meant to be\n   289\t        # case-insensitive, Astropy still allows, for the sake of flexibility,\n   290\t        # two columns with the same name but different case.  When columns are\n   291\t        # accessed in FITS tables, a case-sensitive is tried first, and failing\n   292\t        # that a case-insensitive match is made.\n   293\t        # It's conceivable that the same column could appear in both tables\n   294\t        # being compared, but with different case.\n   295\t        # Though it *may* lead to inconsistencies in these rare cases, this\n   296\t        # just assumes that there are no duplicated column names in either\n   297\t        # table, and that the column names can be treated case-insensitively.\n   298\t        for col in self.common_columns:\n   299\t            name_lower = col.name.lower()\n   300\t            if name_lower in ignore_fields:\n   301\t                continue\n   302\t\n   303\t            cola = colsa[name_lower]\n   304\t            colb = colsb[name_lower]\n   305\t\n   306\t            for attr, _ in _COL_ATTRS:\n   307\t                vala = getattr(cola, attr, None)\n   308\t                valb = getattr(colb, attr, None)\n   309\t                if diff_values(vala, valb):\n   310\t                    self.diff_column_attributes.append(\n   311\t                        ((col.name.upper(), attr), (vala, valb))\n   312\t                    )\n   313\t\n   314\t            arra = self.a[col.name]\n   315\t            arrb = self.b[col.name]\n   316\t\n   317\t            if np.issubdtype(arra.dtype, np.floating) and np.issubdtype(\n   318\t                arrb.dtype, np.floating\n   319\t            ):\n   320\t                diffs = where_not_allclose(arra, arrb, rtol=self.rtol, atol=self.atol)\n   321\t            elif \"P\" in col.format:\n   322\t                diffs = (\n   323\t                    [\n   324\t                        idx\n   325\t                        for idx in range(len(arra))\n   326\t                        if not np.allclose(\n   327\t                            arra[idx], arrb[idx], rtol=self.rtol, atol=self.atol\n   328\t                        )\n   329\t                    ],\n   330\t                )\n   331\t            else:\n   332\t                diffs = np.where(arra != arrb)\n   333\t\n   334\t            self.diff_total += len(set(diffs[0]))\n   335\t\n   336\t            if self.numdiffs >= 0:\n   337\t                if len(self.diff_values) >= self.numdiffs:\n   338\t                    # Don't save any more diff values\n   339\t                    continue\n   340\t\n   341\t                # Add no more diff'd values than this\n   342\t                max_diffs = self.numdiffs - len(self.diff_values)\n   343\t            else:\n   344\t                max_diffs = len(diffs[0])\n   345\t\n   346\t            last_seen_idx = None\n   347\t            for idx in islice(diffs[0], 0, max_diffs):\n   348\t                if idx == last_seen_idx:\n   349\t                    # Skip duplicate indices, which my occur when the column\n   350\t                    # data contains multi-dimensional values; we're only\n   351\t                    # interested in storing row-by-row differences\n   352\t                    continue\n   353\t                last_seen_idx = idx\n   354\t                self.diff_values.append(((col.name, idx), (arra[idx], arrb[idx])))\n   355\t\n   356\t        total_values = len(self.a) * len(self.a.dtype.fields)\n   357\t        self.diff_ratio = float(self.diff_total) / float(total_values)\n   358\t\n   359\t    def _report(self):\n   360\t        if self.diff_column_count:\n   361\t            self._writeln(\" Tables have different number of columns:\")\n   362\t            self._writeln(f\"  a: {self.diff_column_count[0]}\")\n   363\t            self._writeln(f\"  b: {self.diff_column_count[1]}\")\n   364\t\n   365\t        if self.diff_column_names:\n   366\t            # Show columns with names unique to either table\n   367\t            for name in self.diff_column_names[0]:\n   368\t                format = self.diff_columns[0][name.lower()].format\n   369\t                self._writeln(f\" Extra column {name} of format {format} in a\")\n   370\t            for name in self.diff_column_names[1]:\n   371\t                format = self.diff_columns[1][name.lower()].format\n   372\t                self._writeln(f\" Extra column {name} of format {format} in b\")\n   373\t\n   374\t        col_attrs = dict(_COL_ATTRS)\n   375\t        # Now go through each table again and show columns with common\n   376\t        # names but other property differences...\n   377\t        for col_attr, vals in self.diff_column_attributes:\n   378\t            name, attr = col_attr\n   379\t            self._writeln(f\" Column {name} has different {col_attrs[attr]}:\")\n   380\t            report_diff_values(\n   381\t                vals[0],\n   382\t                vals[1],\n   383\t                fileobj=self._fileobj,\n   384\t                indent_width=self._indent + 1,\n   385\t                rtol=self.rtol,\n   386\t                atol=self.atol,\n   387\t            )\n   388\t\n   389\t        if self.diff_rows:\n   390\t            self._writeln(\" Table rows differ:\")\n   391\t            self._writeln(f\"  a: {self.diff_rows[0]}\")\n   392\t            self._writeln(f\"  b: {self.diff_rows[1]}\")\n   393\t            self._writeln(\" No further data comparison performed.\")\n   394\t            return\n   395\t\n   396\t        if not self.diff_values:\n   397\t            return\n   398\t\n   399\t        # Finally, let's go through and report column data differences:\n   400\t        for indx, values in self.diff_values:\n   401\t            self._writeln(\" Column {} data differs in row {}:\".format(*indx))\n   402\t            report_diff_values(\n   403\t                values[0],\n   404\t                values[1],\n   405\t                fileobj=self._fileobj,\n   406\t                indent_width=self._indent + 1,\n   407\t                rtol=self.rtol,\n   408\t                atol=self.atol,\n   409\t            )\n   410\t\n   411\t        if self.diff_values and self.numdiffs < self.diff_total:\n   412\t            self._writeln(\n   413\t                f\" ...{self.diff_total - self.numdiffs} additional difference(s) found.\"\n   414\t            )\n   415\t\n   416\t        if self.diff_total > self.numdiffs:\n   417\t            self._writeln(\" ...\")\n   418\t\n   419\t        self._writeln(\n   420\t            \" {} different table data element(s) found ({:.2%} different).\".format(\n   421\t                self.diff_total, self.diff_ratio\n   422\t            )\n   423\t        )\n   424\t\n   425\t\n   426\tdef report_diff_keyword_attr(fileobj, attr, diffs, keyword, ind=0):\n   427\t    \"\"\"\n   428\t    Write a diff between two header keyword values or comments to the specified\n   429\t    file-like object.\n   430\t    \"\"\"\n   431\t    if keyword in diffs:\n   432\t        vals = diffs[keyword]\n   433\t        for idx, val in enumerate(vals):\n   434\t            if val is None:\n   435\t                continue\n   436\t            if idx == 0:\n   437\t                dup = \"\"\n   438\t            else:\n   439\t                dup = f\"[{idx + 1}]\"\n   440\t            fileobj.write(\n   441\t                fixed_width_indent(\n   442\t                    f\" Keyword {keyword:8}{dup} has different {attr}:\\n\",\n   443\t                    ind,\n   444\t                )\n   445\t            )\n   446\t            report_diff_values(val[0], val[1], fileobj=fileobj, indent_width=ind + 1)\n   447\t\n", "path": "/tmp/tmpkelcrhj5/astropy/astropy/io/fits/diff.py", "prev_exist": true}, "action_id": "40ff1492-2378-4c4a-bbc5-e7b26e7096c3"}