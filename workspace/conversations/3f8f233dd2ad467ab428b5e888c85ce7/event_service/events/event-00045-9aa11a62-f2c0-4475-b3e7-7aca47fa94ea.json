{"kind": "ObservationEvent", "id": "9aa11a62-f2c0-4475-b3e7-7aca47fa94ea", "timestamp": "2025-09-25T11:21:35.105865", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_01TbEHFWBMBR4QAa1DHiMvkM", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmp2_wxitqd/astropy/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py:\n     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\"\"\"\n     3\tContains the transformation functions for getting to/from ITRS, TEME, GCRS, and CIRS.\n     4\tThese are distinct from the ICRS and AltAz functions because they are just\n     5\trotations without aberration corrections or offsets.\n     6\t\"\"\"\n     7\t\n     8\timport numpy as np\n     9\timport erfa\n    10\t\n    11\tfrom astropy.coordinates.baseframe import frame_transform_graph\n    12\tfrom astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n    13\tfrom astropy.coordinates.matrix_utilities import matrix_transpose\n    14\t\n    15\tfrom .icrs import ICRS\n    16\tfrom .gcrs import GCRS, PrecessedGeocentric\n    17\tfrom .cirs import CIRS\n    18\tfrom .itrs import ITRS\n    19\tfrom .equatorial import TEME, TETE\n    20\tfrom .utils import get_polar_motion, get_jd12, EARTH_CENTER\n    21\t\n    22\t# # first define helper functions\n    23\t\n    24\t\n    25\tdef teme_to_itrs_mat(time):\n    26\t    # Sidereal time, rotates from ITRS to mean equinox\n    27\t    # Use 1982 model for consistency with Vallado et al (2006)\n    28\t    # http://www.celestrak.com/publications/aiaa/2006-6753/AIAA-2006-6753.pdf\n    29\t    gst = erfa.gmst82(*get_jd12(time, 'ut1'))\n    30\t\n    31\t    # Polar Motion\n    32\t    # Do not include TIO locator s' because it is not used in Vallado 2006\n    33\t    xp, yp = get_polar_motion(time)\n    34\t    pmmat = erfa.pom00(xp, yp, 0)\n    35\t\n    36\t    # rotation matrix\n    37\t    # c2tcio expects a GCRS->CIRS matrix as it's first argument.\n    38\t    # Here, we just set that to an I-matrix, because we're already\n    39\t    # in TEME and the difference between TEME and CIRS is just the\n    40\t    # rotation by the sidereal time rather than the Earth Rotation Angle\n    41\t    return erfa.c2tcio(np.eye(3), gst, pmmat)\n    42\t\n    43\t\n    44\tdef gcrs_to_cirs_mat(time):\n    45\t    # celestial-to-intermediate matrix\n    46\t    return erfa.c2i06a(*get_jd12(time, 'tt'))\n    47\t\n    48\t\n    49\tdef cirs_to_itrs_mat(time):\n    50\t    # compute the polar motion p-matrix\n    51\t    xp, yp = get_polar_motion(time)\n    52\t    sp = erfa.sp00(*get_jd12(time, 'tt'))\n    53\t    pmmat = erfa.pom00(xp, yp, sp)\n    54\t\n    55\t    # now determine the Earth Rotation Angle for the input obstime\n    56\t    # era00 accepts UT1, so we convert if need be\n    57\t    era = erfa.era00(*get_jd12(time, 'ut1'))\n    58\t\n    59\t    # c2tcio expects a GCRS->CIRS matrix, but we just set that to an I-matrix\n    60\t    # because we're already in CIRS\n    61\t    return erfa.c2tcio(np.eye(3), era, pmmat)\n    62\t\n    63\t\n    64\tdef tete_to_itrs_mat(time, rbpn=None):\n    65\t    \"\"\"Compute the polar motion p-matrix at the given time.\n    66\t\n    67\t    If the nutation-precession matrix is already known, it should be passed in,\n    68\t    as this is by far the most expensive calculation.\n    69\t    \"\"\"\n    70\t    xp, yp = get_polar_motion(time)\n    71\t    sp = erfa.sp00(*get_jd12(time, 'tt'))\n    72\t    pmmat = erfa.pom00(xp, yp, sp)\n    73\t\n    74\t    # now determine the greenwich apparent siderial time for the input obstime\n    75\t    # we use the 2006A model for consistency with RBPN matrix use in GCRS <-> TETE\n    76\t    ujd1, ujd2 = get_jd12(time, 'ut1')\n    77\t    jd1, jd2 = get_jd12(time, 'tt')\n    78\t    if rbpn is None:\n    79\t        # erfa.gst06a calls pnm06a to calculate rbpn and then gst06. Use it in\n    80\t        # favour of getting rbpn with erfa.pnm06a to avoid a possibly large array.\n    81\t        gast = erfa.gst06a(ujd1, ujd2, jd1, jd2)\n    82\t    else:\n    83\t        gast = erfa.gst06(ujd1, ujd2, jd1, jd2, rbpn)\n    84\t\n    85\t    # c2tcio expects a GCRS->CIRS matrix, but we just set that to an I-matrix\n    86\t    # because we're already in CIRS equivalent frame\n    87\t    return erfa.c2tcio(np.eye(3), gast, pmmat)\n    88\t\n    89\t\n    90\tdef gcrs_precession_mat(equinox):\n    91\t    gamb, phib, psib, epsa = erfa.pfw06(*get_jd12(equinox, 'tt'))\n    92\t    return erfa.fw2m(gamb, phib, psib, epsa)\n    93\t\n    94\t\n    95\tdef get_location_gcrs(location, obstime, ref_to_itrs, gcrs_to_ref):\n    96\t    \"\"\"Create a GCRS frame at the location and obstime.\n    97\t\n    98\t    The reference frame z axis must point to the Celestial Intermediate Pole\n    99\t    (as is the case for CIRS and TETE).\n   100\t\n   101\t    This function is here to avoid location.get_gcrs(obstime), which would\n   102\t    recalculate matrices that are already available below (and return a GCRS\n   103\t    coordinate, rather than a frame with obsgeoloc and obsgeovel).  Instead,\n   104\t    it uses the private method that allows passing in the matrices.\n   105\t\n   106\t    \"\"\"\n   107\t    obsgeoloc, obsgeovel = location._get_gcrs_posvel(obstime,\n   108\t                                                     ref_to_itrs, gcrs_to_ref)\n   109\t    return GCRS(obstime=obstime, obsgeoloc=obsgeoloc, obsgeovel=obsgeovel)\n   110\t\n   111\t\n   112\t# now the actual transforms\n   113\t\n   114\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, TETE)\n   115\tdef gcrs_to_tete(gcrs_coo, tete_frame):\n   116\t    # Classical NPB matrix, IAU 2006/2000A\n   117\t    # (same as in builtin_frames.utils.get_cip).\n   118\t    rbpn = erfa.pnm06a(*get_jd12(tete_frame.obstime, 'tt'))\n   119\t    # Get GCRS coordinates for the target observer location and time.\n   120\t    loc_gcrs = get_location_gcrs(tete_frame.location, tete_frame.obstime,\n   121\t                                 tete_to_itrs_mat(tete_frame.obstime, rbpn=rbpn),\n   122\t                                 rbpn)\n   123\t    gcrs_coo2 = gcrs_coo.transform_to(loc_gcrs)\n   124\t    # Now we are relative to the correct observer, do the transform to TETE.\n   125\t    # These rotations are defined at the geocenter, but can be applied to\n   126\t    # topocentric positions as well, assuming rigid Earth. See p57 of\n   127\t    # https://www.usno.navy.mil/USNO/astronomical-applications/publications/Circular_179.pdf\n   128\t    crepr = gcrs_coo2.cartesian.transform(rbpn)\n   129\t    return tete_frame.realize_frame(crepr)\n   130\t\n   131\t\n   132\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, TETE, GCRS)\n   133\tdef tete_to_gcrs(tete_coo, gcrs_frame):\n   134\t    # Compute the pn matrix, and then multiply by its transpose.\n   135\t    rbpn = erfa.pnm06a(*get_jd12(tete_coo.obstime, 'tt'))\n   136\t    newrepr = tete_coo.cartesian.transform(matrix_transpose(rbpn))\n   137\t    # We now have a GCRS vector for the input location and obstime.\n   138\t    # Turn it into a GCRS frame instance.\n   139\t    loc_gcrs = get_location_gcrs(tete_coo.location, tete_coo.obstime,\n   140\t                                 tete_to_itrs_mat(tete_coo.obstime, rbpn=rbpn),\n   141\t                                 rbpn)\n   142\t    gcrs = loc_gcrs.realize_frame(newrepr)\n   143\t    # Finally, do any needed offsets (no-op if same obstime and location)\n   144\t    return gcrs.transform_to(gcrs_frame)\n   145\t\n   146\t\n   147\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, TETE, ITRS)\n   148\tdef tete_to_itrs(tete_coo, itrs_frame):\n   149\t    # first get us to TETE at the target obstime, and geocentric position\n   150\t    tete_coo2 = tete_coo.transform_to(TETE(obstime=itrs_frame.obstime,\n   151\t                                           location=EARTH_CENTER))\n   152\t\n   153\t    # now get the pmatrix\n   154\t    pmat = tete_to_itrs_mat(itrs_frame.obstime)\n   155\t    crepr = tete_coo2.cartesian.transform(pmat)\n   156\t    return itrs_frame.realize_frame(crepr)\n   157\t\n   158\t\n   159\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, TETE)\n   160\tdef itrs_to_tete(itrs_coo, tete_frame):\n   161\t    # compute the pmatrix, and then multiply by its transpose\n   162\t    pmat = tete_to_itrs_mat(itrs_coo.obstime)\n   163\t    newrepr = itrs_coo.cartesian.transform(matrix_transpose(pmat))\n   164\t    tete = TETE(newrepr, obstime=itrs_coo.obstime)\n   165\t\n   166\t    # now do any needed offsets (no-op if same obstime)\n   167\t    return tete.transform_to(tete_frame)\n   168\t\n   169\t\n   170\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, CIRS)\n   171\tdef gcrs_to_cirs(gcrs_coo, cirs_frame):\n   172\t    # first get the pmatrix\n   173\t    pmat = gcrs_to_cirs_mat(cirs_frame.obstime)\n   174\t    # Get GCRS coordinates for the target observer location and time.\n   175\t    loc_gcrs = get_location_gcrs(cirs_frame.location, cirs_frame.obstime,\n   176\t                                 cirs_to_itrs_mat(cirs_frame.obstime), pmat)\n   177\t    gcrs_coo2 = gcrs_coo.transform_to(loc_gcrs)\n   178\t    # Now we are relative to the correct observer, do the transform to CIRS.\n   179\t    crepr = gcrs_coo2.cartesian.transform(pmat)\n   180\t    return cirs_frame.realize_frame(crepr)\n   181\t\n   182\t\n   183\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, GCRS)\n   184\tdef cirs_to_gcrs(cirs_coo, gcrs_frame):\n   185\t    # Compute the pmatrix, and then multiply by its transpose,\n   186\t    pmat = gcrs_to_cirs_mat(cirs_coo.obstime)\n   187\t    newrepr = cirs_coo.cartesian.transform(matrix_transpose(pmat))\n   188\t    # We now have a GCRS vector for the input location and obstime.\n   189\t    # Turn it into a GCRS frame instance.\n   190\t    loc_gcrs = get_location_gcrs(cirs_coo.location, cirs_coo.obstime,\n   191\t                                 cirs_to_itrs_mat(cirs_coo.obstime), pmat)\n   192\t    gcrs = loc_gcrs.realize_frame(newrepr)\n   193\t    # Finally, do any needed offsets (no-op if same obstime and location)\n   194\t    return gcrs.transform_to(gcrs_frame)\n   195\t\n   196\t\n   197\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, ITRS)\n   198\tdef cirs_to_itrs(cirs_coo, itrs_frame):\n   199\t    # first get us to geocentric CIRS at the target obstime\n   200\t    cirs_coo2 = cirs_coo.transform_to(CIRS(obstime=itrs_frame.obstime,\n   201\t                                           location=EARTH_CENTER))\n   202\t\n   203\t    # now get the pmatrix\n   204\t    pmat = cirs_to_itrs_mat(itrs_frame.obstime)\n   205\t    crepr = cirs_coo2.cartesian.transform(pmat)\n   206\t    return itrs_frame.realize_frame(crepr)\n   207\t\n   208\t\n   209\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, CIRS)\n   210\tdef itrs_to_cirs(itrs_coo, cirs_frame):\n   211\t    # compute the pmatrix, and then multiply by its transpose\n   212\t    pmat = cirs_to_itrs_mat(itrs_coo.obstime)\n   213\t    newrepr = itrs_coo.cartesian.transform(matrix_transpose(pmat))\n   214\t    cirs = CIRS(newrepr, obstime=itrs_coo.obstime)\n   215\t\n   216\t    # now do any needed offsets (no-op if same obstime)\n   217\t    return cirs.transform_to(cirs_frame)\n   218\t\n   219\t\n   220\t# TODO: implement GCRS<->CIRS if there's call for it.  The thing that's awkward\n   221\t# is that they both have obstimes, so an extra set of transformations are necessary.\n   222\t# so unless there's a specific need for that, better to just have it go through the above\n   223\t# two steps anyway\n   224\t\n   225\t\n   226\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, PrecessedGeocentric)\n   227\tdef gcrs_to_precessedgeo(from_coo, to_frame):\n   228\t    # first get us to GCRS with the right attributes (might be a no-op)\n   229\t    gcrs_coo = from_coo.transform_to(GCRS(obstime=to_frame.obstime,\n   230\t                                          obsgeoloc=to_frame.obsgeoloc,\n   231\t                                          obsgeovel=to_frame.obsgeovel))\n   232\t\n   233\t    # now precess to the requested equinox\n   234\t    pmat = gcrs_precession_mat(to_frame.equinox)\n   235\t    crepr = gcrs_coo.cartesian.transform(pmat)\n   236\t    return to_frame.realize_frame(crepr)\n   237\t\n   238\t\n   239\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, PrecessedGeocentric, GCRS)\n   240\tdef precessedgeo_to_gcrs(from_coo, to_frame):\n   241\t    # first un-precess\n   242\t    pmat = gcrs_precession_mat(from_coo.equinox)\n   243\t    crepr = from_coo.cartesian.transform(matrix_transpose(pmat))\n   244\t    gcrs_coo = GCRS(crepr,\n   245\t                    obstime=from_coo.obstime,\n   246\t                    obsgeoloc=from_coo.obsgeoloc,\n   247\t                    obsgeovel=from_coo.obsgeovel)\n   248\t\n   249\t    # then move to the GCRS that's actually desired\n   250\t    return gcrs_coo.transform_to(to_frame)\n   251\t\n   252\t\n   253\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, TEME, ITRS)\n   254\tdef teme_to_itrs(teme_coo, itrs_frame):\n   255\t    # use the pmatrix to transform to ITRS in the source obstime\n   256\t    pmat = teme_to_itrs_mat(teme_coo.obstime)\n   257\t    crepr = teme_coo.cartesian.transform(pmat)\n   258\t    itrs = ITRS(crepr, obstime=teme_coo.obstime)\n   259\t\n   260\t    # transform the ITRS coordinate to the target obstime\n   261\t    return itrs.transform_to(itrs_frame)\n   262\t\n   263\t\n   264\t@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, TEME)\n   265\tdef itrs_to_teme(itrs_coo, teme_frame):\n   266\t    # transform the ITRS coordinate to the target obstime\n   267\t    itrs_coo2 = itrs_coo.transform_to(ITRS(obstime=teme_frame.obstime))\n   268\t\n   269\t    # compute the pmatrix, and then multiply by its transpose\n   270\t    pmat = teme_to_itrs_mat(teme_frame.obstime)\n   271\t    newrepr = itrs_coo2.cartesian.transform(matrix_transpose(pmat))\n   272\t    return teme_frame.realize_frame(newrepr)\n   273\t\n   274\t\n   275\t# Create loopback transformations\n   276\tframe_transform_graph._add_merged_transform(ITRS, CIRS, ITRS)\n   277\tframe_transform_graph._add_merged_transform(PrecessedGeocentric, GCRS, PrecessedGeocentric)\n   278\tframe_transform_graph._add_merged_transform(TEME, ITRS, TEME)\n   279\tframe_transform_graph._add_merged_transform(TETE, ICRS, TETE)\n   280\t\n", "path": "/tmp/tmp2_wxitqd/astropy/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py", "prev_exist": true}, "action_id": "2d20be34-5294-4c19-9693-3e431f1ca0bd"}