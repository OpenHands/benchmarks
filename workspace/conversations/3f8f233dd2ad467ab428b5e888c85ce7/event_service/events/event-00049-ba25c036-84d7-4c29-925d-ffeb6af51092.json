{"kind": "ObservationEvent", "id": "ba25c036-84d7-4c29-925d-ffeb6af51092", "timestamp": "2025-09-25T11:21:44.614489", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_01VUfiBjC33XK5oSy9JcCKjQ", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmp2_wxitqd/astropy/astropy/coordinates/builtin_frames/utils.py:\n     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\"\"\"\n     3\tThis module contains functions/values used repeatedly in different modules of\n     4\tthe ``builtin_frames`` package.\n     5\t\"\"\"\n     6\t\n     7\timport warnings\n     8\t\n     9\timport erfa\n    10\timport numpy as np\n    11\t\n    12\tfrom astropy import units as u\n    13\tfrom astropy.time import Time\n    14\tfrom astropy.coordinates.earth import EarthLocation\n    15\tfrom astropy.utils import iers\n    16\tfrom astropy.utils.exceptions import AstropyWarning\n    17\tfrom ..representation import CartesianDifferential\n    18\t\n    19\t\n    20\t# We use tt as the time scale for this equinoxes, primarily because it is the\n    21\t# convention for J2000 (it is unclear if there is any \"right answer\" for B1950)\n    22\t# while #8600 makes this the default behavior, we show it here to ensure it's\n    23\t# clear which is used here\n    24\tEQUINOX_J2000 = Time('J2000', scale='tt')\n    25\tEQUINOX_B1950 = Time('B1950', scale='tt')\n    26\t\n    27\t# This is a time object that is the default \"obstime\" when such an attribute is\n    28\t# necessary.  Currently, we use J2000.\n    29\tDEFAULT_OBSTIME = Time('J2000', scale='tt')\n    30\t\n    31\t# This is an EarthLocation that is the default \"location\" when such an attribute is\n    32\t# necessary. It is the centre of the Earth.\n    33\tEARTH_CENTER = EarthLocation(0*u.km, 0*u.km, 0*u.km)\n    34\t\n    35\tPIOVER2 = np.pi / 2.\n    36\t\n    37\t# comes from the mean of the 1962-2014 IERS B data\n    38\t_DEFAULT_PM = (0.035, 0.29)*u.arcsec\n    39\t\n    40\t\n    41\tdef get_polar_motion(time):\n    42\t    \"\"\"\n    43\t    gets the two polar motion components in radians for use with apio\n    44\t    \"\"\"\n    45\t    # Get the polar motion from the IERS table\n    46\t    iers_table = iers.earth_orientation_table.get()\n    47\t    xp, yp, status = iers_table.pm_xy(time, return_status=True)\n    48\t\n    49\t    wmsg = (\n    50\t        'Tried to get polar motions for times {} IERS data is '\n    51\t        'valid. Defaulting to polar motion from the 50-yr mean for those. '\n    52\t        'This may affect precision at the arcsec level. Please check your '\n    53\t        'astropy.utils.iers.conf.iers_auto_url and point it to a newer '\n    54\t        'version if necessary.'\n    55\t    )\n    56\t    if np.any(status == iers.TIME_BEFORE_IERS_RANGE):\n    57\t        xp[status == iers.TIME_BEFORE_IERS_RANGE] = _DEFAULT_PM[0]\n    58\t        yp[status == iers.TIME_BEFORE_IERS_RANGE] = _DEFAULT_PM[1]\n    59\t\n    60\t        warnings.warn(wmsg.format('before'), AstropyWarning)\n    61\t\n    62\t    if np.any(status == iers.TIME_BEYOND_IERS_RANGE):\n    63\t\n    64\t        xp[status == iers.TIME_BEYOND_IERS_RANGE] = _DEFAULT_PM[0]\n    65\t        yp[status == iers.TIME_BEYOND_IERS_RANGE] = _DEFAULT_PM[1]\n    66\t\n    67\t        warnings.warn(wmsg.format('after'), AstropyWarning)\n    68\t\n    69\t    return xp.to_value(u.radian), yp.to_value(u.radian)\n    70\t\n    71\t\n    72\tdef _warn_iers(ierserr):\n    73\t    \"\"\"\n    74\t    Generate a warning for an IERSRangeerror\n    75\t\n    76\t    Parameters\n    77\t    ----------\n    78\t    ierserr : An `~astropy.utils.iers.IERSRangeError`\n    79\t    \"\"\"\n    80\t    msg = '{0} Assuming UT1-UTC=0 for coordinate transformations.'\n    81\t    warnings.warn(msg.format(ierserr.args[0]), AstropyWarning)\n    82\t\n    83\t\n    84\tdef get_dut1utc(time):\n    85\t    \"\"\"\n    86\t    This function is used to get UT1-UTC in coordinates because normally it\n    87\t    gives an error outside the IERS range, but in coordinates we want to allow\n    88\t    it to go through but with a warning.\n    89\t    \"\"\"\n    90\t    try:\n    91\t        return time.delta_ut1_utc\n    92\t    except iers.IERSRangeError as e:\n    93\t        _warn_iers(e)\n    94\t        return np.zeros(time.shape)\n    95\t\n    96\t\n    97\tdef get_jd12(time, scale):\n    98\t    \"\"\"\n    99\t    Gets ``jd1`` and ``jd2`` from a time object in a particular scale.\n   100\t\n   101\t    Parameters\n   102\t    ----------\n   103\t    time : `~astropy.time.Time`\n   104\t        The time to get the jds for\n   105\t    scale : str\n   106\t        The time scale to get the jds for\n   107\t\n   108\t    Returns\n   109\t    -------\n   110\t    jd1 : float\n   111\t    jd2 : float\n   112\t    \"\"\"\n   113\t    if time.scale == scale:\n   114\t        newtime = time\n   115\t    else:\n   116\t        try:\n   117\t            newtime = getattr(time, scale)\n   118\t        except iers.IERSRangeError as e:\n   119\t            _warn_iers(e)\n   120\t            newtime = time\n   121\t\n   122\t    return newtime.jd1, newtime.jd2\n   123\t\n   124\t\n   125\tdef norm(p):\n   126\t    \"\"\"\n   127\t    Normalise a p-vector.\n   128\t    \"\"\"\n   129\t    return p / np.sqrt(np.einsum('...i,...i', p, p))[..., np.newaxis]\n   130\t\n   131\t\n   132\tdef pav2pv(p, v):\n   133\t    \"\"\"\n   134\t    Combine p- and v- vectors into a pv-vector.\n   135\t    \"\"\"\n   136\t    pv = np.empty(np.broadcast(p, v).shape[:-1], erfa.dt_pv)\n   137\t    pv['p'] = p\n   138\t    pv['v'] = v\n   139\t    return pv\n   140\t\n   141\t\n   142\tdef get_cip(jd1, jd2):\n   143\t    \"\"\"\n   144\t    Find the X, Y coordinates of the CIP and the CIO locator, s.\n   145\t\n   146\t    Parameters\n   147\t    ----------\n   148\t    jd1 : float or `np.ndarray`\n   149\t        First part of two part Julian date (TDB)\n   150\t    jd2 : float or `np.ndarray`\n   151\t        Second part of two part Julian date (TDB)\n   152\t\n   153\t    Returns\n   154\t    -------\n   155\t    x : float or `np.ndarray`\n   156\t        x coordinate of the CIP\n   157\t    y : float or `np.ndarray`\n   158\t        y coordinate of the CIP\n   159\t    s : float or `np.ndarray`\n   160\t        CIO locator, s\n   161\t    \"\"\"\n   162\t    # classical NPB matrix, IAU 2006/2000A\n   163\t    rpnb = erfa.pnm06a(jd1, jd2)\n   164\t    # CIP X, Y coordinates from array\n   165\t    x, y = erfa.bpn2xy(rpnb)\n   166\t    # CIO locator, s\n   167\t    s = erfa.s06(jd1, jd2, x, y)\n   168\t    return x, y, s\n   169\t\n   170\t\n   171\tdef aticq(srepr, astrom):\n   172\t    \"\"\"\n   173\t    A slightly modified version of the ERFA function ``eraAticq``.\n   174\t\n   175\t    ``eraAticq`` performs the transformations between two coordinate systems,\n   176\t    with the details of the transformation being encoded into the ``astrom`` array.\n   177\t\n   178\t    There are two issues with the version of aticq in ERFA. Both are associated\n   179\t    with the handling of light deflection.\n   180\t\n   181\t    The companion function ``eraAtciqz`` is meant to be its inverse. However, this\n   182\t    is not true for directions close to the Solar centre, since the light deflection\n   183\t    calculations are numerically unstable and therefore not reversible.\n   184\t\n   185\t    This version sidesteps that problem by artificially reducing the light deflection\n   186\t    for directions which are within 90 arcseconds of the Sun's position. This is the\n   187\t    same approach used by the ERFA functions above, except that they use a threshold of\n   188\t    9 arcseconds.\n   189\t\n   190\t    In addition, ERFA's aticq assumes a distant source, so there is no difference between\n   191\t    the object-Sun vector and the observer-Sun vector. This can lead to errors of up to a\n   192\t    few arcseconds in the worst case (e.g a Venus transit).\n   193\t\n   194\t    Parameters\n   195\t    ----------\n   196\t    srepr : `~astropy.coordinates.SphericalRepresentation`\n   197\t        Astrometric GCRS or CIRS position of object from observer\n   198\t    astrom : eraASTROM array\n   199\t        ERFA astrometry context, as produced by, e.g. ``eraApci13`` or ``eraApcs13``\n   200\t\n   201\t    Returns\n   202\t    -------\n   203\t    rc : float or `~numpy.ndarray`\n   204\t        Right Ascension in radians\n   205\t    dc : float or `~numpy.ndarray`\n   206\t        Declination in radians\n   207\t    \"\"\"\n   208\t    # ignore parallax effects if no distance, or far away\n   209\t    srepr_distance = srepr.distance\n   210\t    ignore_distance = srepr_distance.unit == u.one\n   211\t\n   212\t    # RA, Dec to cartesian unit vectors\n   213\t    pos = erfa.s2c(srepr.lon.radian, srepr.lat.radian)\n   214\t\n   215\t    # Bias-precession-nutation, giving GCRS proper direction.\n   216\t    ppr = erfa.trxp(astrom['bpn'], pos)\n   217\t\n   218\t    # Aberration, giving GCRS natural direction\n   219\t    d = np.zeros_like(ppr)\n   220\t    for j in range(2):\n   221\t        before = norm(ppr-d)\n   222\t        after = erfa.ab(before, astrom['v'], astrom['em'], astrom['bm1'])\n   223\t        d = after - before\n   224\t    pnat = norm(ppr-d)\n   225\t\n   226\t    # Light deflection by the Sun, giving BCRS coordinate direction\n   227\t    d = np.zeros_like(pnat)\n   228\t    for j in range(5):\n   229\t        before = norm(pnat-d)\n   230\t        if ignore_distance:\n   231\t            # No distance to object, assume a long way away\n   232\t            q = before\n   233\t        else:\n   234\t            # Find BCRS direction of Sun to object.\n   235\t            # astrom['eh'] and astrom['em'] contain Sun to observer unit vector,\n   236\t            # and distance, respectively.\n   237\t            eh = astrom['em'][..., np.newaxis] * astrom['eh']\n   238\t            # unit vector from Sun to object\n   239\t            q = eh + srepr_distance[..., np.newaxis].to_value(u.au) * before\n   240\t            sundist, q = erfa.pn(q)\n   241\t            sundist = sundist[..., np.newaxis]\n   242\t            # calculation above is extremely unstable very close to the sun\n   243\t            # in these situations, default back to ldsun-style behaviour,\n   244\t            # since this is reversible and drops to zero within stellar limb\n   245\t            q = np.where(sundist > 1.0e-10, q, before)\n   246\t\n   247\t        after = erfa.ld(1.0, before, q, astrom['eh'], astrom['em'], 1e-6)\n   248\t        d = after - before\n   249\t    pco = norm(pnat-d)\n   250\t\n   251\t    # ICRS astrometric RA, Dec\n   252\t    rc, dc = erfa.c2s(pco)\n   253\t    return erfa.anp(rc), dc\n   254\t\n   255\t\n   256\tdef atciqz(srepr, astrom):\n   257\t    \"\"\"\n   258\t    A slightly modified version of the ERFA function ``eraAtciqz``.\n   259\t\n   260\t    ``eraAtciqz`` performs the transformations between two coordinate systems,\n   261\t    with the details of the transformation being encoded into the ``astrom`` array.\n   262\t\n   263\t    There are two issues with the version of atciqz in ERFA. Both are associated\n   264\t    with the handling of light deflection.\n   265\t\n   266\t    The companion function ``eraAticq`` is meant to be its inverse. However, this\n   267\t    is not true for directions close to the Solar centre, since the light deflection\n   268\t    calculations are numerically unstable and therefore not reversible.\n   269\t\n   270\t    This version sidesteps that problem by artificially reducing the light deflection\n   271\t    for directions which are within 90 arcseconds of the Sun's position. This is the\n   272\t    same approach used by the ERFA functions above, except that they use a threshold of\n   273\t    9 arcseconds.\n   274\t\n   275\t    In addition, ERFA's atciqz assumes a distant source, so there is no difference between\n   276\t    the object-Sun vector and the observer-Sun vector. This can lead to errors of up to a\n   277\t    few arcseconds in the worst case (e.g a Venus transit).\n   278\t\n   279\t    Parameters\n   280\t    ----------\n   281\t    srepr : `~astropy.coordinates.SphericalRepresentation`\n   282\t        Astrometric ICRS position of object from observer\n   283\t    astrom : eraASTROM array\n   284\t        ERFA astrometry context, as produced by, e.g. ``eraApci13`` or ``eraApcs13``\n   285\t\n   286\t    Returns\n   287\t    -------\n   288\t    ri : float or `~numpy.ndarray`\n   289\t        Right Ascension in radians\n   290\t    di : float or `~numpy.ndarray`\n   291\t        Declination in radians\n   292\t    \"\"\"\n   293\t    # ignore parallax effects if no distance, or far away\n   294\t    srepr_distance = srepr.distance\n   295\t    ignore_distance = srepr_distance.unit == u.one\n   296\t\n   297\t    # BCRS coordinate direction (unit vector).\n   298\t    pco = erfa.s2c(srepr.lon.radian, srepr.lat.radian)\n   299\t\n   300\t    # Find BCRS direction of Sun to object\n   301\t    if ignore_distance:\n   302\t        # No distance to object, assume a long way away\n   303\t        q = pco\n   304\t    else:\n   305\t        # Find BCRS direction of Sun to object.\n   306\t        # astrom['eh'] and astrom['em'] contain Sun to observer unit vector,\n   307\t        # and distance, respectively.\n   308\t        eh = astrom['em'][..., np.newaxis] * astrom['eh']\n   309\t        # unit vector from Sun to object\n   310\t        q = eh + srepr_distance[..., np.newaxis].to_value(u.au) * pco\n   311\t        sundist, q = erfa.pn(q)\n   312\t        sundist = sundist[..., np.newaxis]\n   313\t        # calculation above is extremely unstable very close to the sun\n   314\t        # in these situations, default back to ldsun-style behaviour,\n   315\t        # since this is reversible and drops to zero within stellar limb\n   316\t        q = np.where(sundist > 1.0e-10, q, pco)\n   317\t\n   318\t    # Light deflection by the Sun, giving BCRS natural direction.\n   319\t    pnat = erfa.ld(1.0, pco, q, astrom['eh'], astrom['em'], 1e-6)\n   320\t\n   321\t    # Aberration, giving GCRS proper direction.\n   322\t    ppr = erfa.ab(pnat, astrom['v'], astrom['em'], astrom['bm1'])\n   323\t\n   324\t    # Bias-precession-nutation, giving CIRS proper direction.\n   325\t    # Has no effect if matrix is identity matrix, in which case gives GCRS ppr.\n   326\t    pi = erfa.rxp(astrom['bpn'], ppr)\n   327\t\n   328\t    # CIRS (GCRS) RA, Dec\n   329\t    ri, di = erfa.c2s(pi)\n   330\t    return erfa.anp(ri), di\n   331\t\n   332\t\n   333\tdef prepare_earth_position_vel(time):\n   334\t    \"\"\"\n   335\t    Get barycentric position and velocity, and heliocentric position of Earth\n   336\t\n   337\t    Parameters\n   338\t    ----------\n   339\t    time : `~astropy.time.Time`\n   340\t        time at which to calculate position and velocity of Earth\n   341\t\n   342\t    Returns\n   343\t    -------\n   344\t    earth_pv : `np.ndarray`\n   345\t        Barycentric position and velocity of Earth, in au and au/day\n   346\t    earth_helio : `np.ndarray`\n   347\t        Heliocentric position of Earth in au\n   348\t    \"\"\"\n   349\t    # this goes here to avoid circular import errors\n   350\t    from astropy.coordinates.solar_system import (\n   351\t        get_body_barycentric,\n   352\t        get_body_barycentric_posvel,\n   353\t        solar_system_ephemeris,\n   354\t    )\n   355\t    # get barycentric position and velocity of earth\n   356\t\n   357\t    ephemeris = solar_system_ephemeris.get()\n   358\t\n   359\t    # if we are using the builtin erfa based ephemeris,\n   360\t    # we can use the fact that epv00 already provides all we need.\n   361\t    # This avoids calling epv00 twice, once\n   362\t    # in get_body_barycentric_posvel('earth') and once in\n   363\t    # get_body_barycentric('sun')\n   364\t    if ephemeris == 'builtin':\n   365\t        jd1, jd2 = get_jd12(time, 'tdb')\n   366\t        earth_pv_heliocentric, earth_pv = erfa.epv00(jd1, jd2)\n   367\t        earth_heliocentric = earth_pv_heliocentric['p']\n   368\t\n   369\t    # all other ephemeris providers probably don't have a shortcut like this\n   370\t    else:\n   371\t        earth_p, earth_v = get_body_barycentric_posvel('earth', time)\n   372\t\n   373\t        # get heliocentric position of earth, preparing it for passing to erfa.\n   374\t        sun = get_body_barycentric('sun', time)\n   375\t        earth_heliocentric = (earth_p - sun).get_xyz(xyz_axis=-1).to_value(u.au)\n   376\t\n   377\t        # Also prepare earth_pv for passing to erfa, which wants it as\n   378\t        # a structured dtype.\n   379\t        earth_pv = pav2pv(\n   380\t            earth_p.get_xyz(xyz_axis=-1).to_value(u.au),\n   381\t            earth_v.get_xyz(xyz_axis=-1).to_value(u.au / u.d)\n   382\t        )\n   383\t\n   384\t    return earth_pv, earth_heliocentric\n   385\t\n   386\t\n   387\tdef get_offset_sun_from_barycenter(time, include_velocity=False, reverse=False):\n   388\t    \"\"\"\n   389\t    Returns the offset of the Sun center from the solar-system barycenter (SSB).\n   390\t\n   391\t    Parameters\n   392\t    ----------\n   393\t    time : `~astropy.time.Time`\n   394\t        Time at which to calculate the offset\n   395\t    include_velocity : `bool`\n   396\t        If ``True``, attach the velocity as a differential.  Defaults to ``False``.\n   397\t    reverse : `bool`\n   398\t        If ``True``, return the offset of the barycenter from the Sun.  Defaults to ``False``.\n   399\t\n   400\t    Returns\n   401\t    -------\n   402\t    `~astropy.coordinates.CartesianRepresentation`\n   403\t        The offset\n   404\t    \"\"\"\n   405\t    if include_velocity:\n   406\t        # Import here to avoid a circular import\n   407\t        from astropy.coordinates.solar_system import get_body_barycentric_posvel\n   408\t        offset_pos, offset_vel = get_body_barycentric_posvel('sun', time)\n   409\t        if reverse:\n   410\t            offset_pos, offset_vel = -offset_pos, -offset_vel\n   411\t        offset_vel = offset_vel.represent_as(CartesianDifferential)\n   412\t        offset_pos = offset_pos.with_differentials(offset_vel)\n   413\t\n   414\t    else:\n   415\t        # Import here to avoid a circular import\n   416\t        from astropy.coordinates.solar_system import get_body_barycentric\n   417\t        offset_pos = get_body_barycentric('sun', time)\n   418\t        if reverse:\n   419\t            offset_pos = -offset_pos\n   420\t\n   421\t    return offset_pos\n   422\t\n", "path": "/tmp/tmp2_wxitqd/astropy/astropy/coordinates/builtin_frames/utils.py", "prev_exist": true}, "action_id": "58792141-4099-4b46-aa1c-90ae24abef02"}