{"kind": "ObservationEvent", "id": "fd621371-6800-4005-bf17-bbe367f18fbc", "timestamp": "2025-09-25T19:04:33.948540", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_01GAtahrfzR378gNsDGhHmEL", "observation": {"kind": "StrReplaceEditorObservation", "command": "create", "output": "File created successfully at: /tmp/tmpl5smzkye/pytest/verify_fix.py", "path": "/tmp/tmpl5smzkye/pytest/verify_fix.py", "prev_exist": false, "new_content": "#!/usr/bin/env python3\n\"\"\"\nDirect unit test to verify the caplog handler level restoration fix.\nThis bypasses pytest's test runner and directly tests the LogCaptureFixture class.\n\"\"\"\n\nimport sys\nimport os\nimport logging\n\n# Add the src directory to the path so we can import pytest modules\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))\n\nfrom _pytest.logging import LogCaptureFixture, LogCaptureHandler, caplog_handler_key, caplog_records_key\n\n\nclass MockItem:\n    \"\"\"Mock item for testing purposes.\"\"\"\n    def __init__(self, name=\"test_item\"):\n        self.name = name\n        self._store = {}\n\n\ndef test_original_issue():\n    \"\"\"Test the exact scenario from the GitHub issue.\"\"\"\n    \n    print(\"=== Testing Original Issue Scenario ===\")\n    \n    # Create a shared handler (simulating pytest's behavior)\n    item = MockItem(\"test_item\")\n    handler = LogCaptureHandler()\n    \n    # Store handler in the item\n    item._store[caplog_handler_key] = handler\n    item._store[caplog_records_key] = {}\n    \n    original_level = handler.level\n    print(f\"Original handler level: {original_level}\")\n    \n    # Simulate test_foo\n    print(\"\\n--- test_foo ---\")\n    caplog_foo = LogCaptureFixture(item)\n    caplog_foo.set_level(42)\n    print(f\"After caplog.set_level(42): {caplog_foo.handler.level}\")\n    \n    # End of test_foo - fixture should be finalized\n    caplog_foo._finalize()\n    print(f\"After test_foo finalization: {handler.level}\")\n    \n    # Simulate test_bar\n    print(\"\\n--- test_bar ---\")\n    caplog_bar = LogCaptureFixture(item)\n    bar_level = caplog_bar.handler.level\n    print(f\"caplog.handler.level in test_bar: {bar_level}\")\n    \n    # Verify the fix\n    if bar_level == original_level:\n        print(f\"\\n\u2705 SUCCESS: Handler level correctly restored to {original_level}\")\n        return True\n    else:\n        print(f\"\\n\u274c FAILURE: Expected {original_level}, got {bar_level}\")\n        return False\n\n\ndef test_multiple_set_level_calls():\n    \"\"\"Test multiple calls to set_level.\"\"\"\n    \n    print(\"\\n=== Testing Multiple set_level Calls ===\")\n    \n    item = MockItem(\"test_item\")\n    handler = LogCaptureHandler()\n    \n    # Store handler in the item\n    item._store[caplog_handler_key] = handler\n    item._store[caplog_records_key] = {}\n    \n    original_level = handler.level\n    print(f\"Original handler level: {original_level}\")\n    \n    caplog = LogCaptureFixture(item)\n    \n    # Multiple set_level calls\n    caplog.set_level(10)\n    print(f\"After set_level(10): {caplog.handler.level}\")\n    \n    caplog.set_level(20)\n    print(f\"After set_level(20): {caplog.handler.level}\")\n    \n    caplog.set_level(30)\n    print(f\"After set_level(30): {caplog.handler.level}\")\n    \n    # Finalize\n    caplog._finalize()\n    final_level = caplog.handler.level\n    print(f\"After finalization: {final_level}\")\n    \n    if final_level == original_level:\n        print(f\"\\n\u2705 SUCCESS: Handler level correctly restored to {original_level}\")\n        return True\n    else:\n        print(f\"\\n\u274c FAILURE: Expected {original_level}, got {final_level}\")\n        return False\n\n\ndef test_no_set_level_call():\n    \"\"\"Test that finalization works when set_level is never called.\"\"\"\n    \n    print(\"\\n=== Testing No set_level Call ===\")\n    \n    item = MockItem(\"test_item\")\n    handler = LogCaptureHandler()\n    \n    # Store handler in the item\n    item._store[caplog_handler_key] = handler\n    item._store[caplog_records_key] = {}\n    \n    original_level = handler.level\n    print(f\"Original handler level: {original_level}\")\n    \n    caplog = LogCaptureFixture(item)\n    \n    # Finalize without calling set_level\n    caplog._finalize()\n    final_level = caplog.handler.level\n    print(f\"After finalization (no set_level called): {final_level}\")\n    \n    if final_level == original_level:\n        print(f\"\\n\u2705 SUCCESS: Handler level unchanged at {original_level}\")\n        return True\n    else:\n        print(f\"\\n\u274c FAILURE: Expected {original_level}, got {final_level}\")\n        return False\n\n\ndef test_logger_level_restoration():\n    \"\"\"Test that logger level restoration still works.\"\"\"\n    \n    print(\"\\n=== Testing Logger Level Restoration ===\")\n    \n    item = MockItem(\"test_item\")\n    handler = LogCaptureHandler()\n    \n    # Store handler in the item\n    item._store[caplog_handler_key] = handler\n    item._store[caplog_records_key] = {}\n    \n    # Get a test logger\n    test_logger = logging.getLogger(\"test_logger\")\n    original_logger_level = test_logger.level\n    print(f\"Original logger level: {original_logger_level}\")\n    \n    caplog = LogCaptureFixture(item)\n    \n    # Set level for specific logger\n    caplog.set_level(logging.ERROR, logger=\"test_logger\")\n    print(f\"After set_level(ERROR, 'test_logger'): {test_logger.level}\")\n    \n    # Finalize\n    caplog._finalize()\n    final_logger_level = test_logger.level\n    print(f\"After finalization: {final_logger_level}\")\n    \n    if final_logger_level == original_logger_level:\n        print(f\"\\n\u2705 SUCCESS: Logger level correctly restored to {original_logger_level}\")\n        return True\n    else:\n        print(f\"\\n\u274c FAILURE: Expected {original_logger_level}, got {final_logger_level}\")\n        return False\n\n\nif __name__ == \"__main__\":\n    print(\"Verifying caplog handler level restoration fix...\")\n    print(\"=\" * 60)\n    \n    tests = [\n        test_original_issue,\n        test_multiple_set_level_calls,\n        test_no_set_level_call,\n        test_logger_level_restoration\n    ]\n    \n    results = []\n    for test in tests:\n        try:\n            result = test()\n            results.append(result)\n        except Exception as e:\n            print(f\"\\n\u274c ERROR in {test.__name__}: {e}\")\n            results.append(False)\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"SUMMARY:\")\n    \n    passed = sum(results)\n    total = len(results)\n    \n    for i, (test, result) in enumerate(zip(tests, results)):\n        status = \"\u2705 PASS\" if result else \"\u274c FAIL\"\n        print(f\"{i+1}. {test.__name__}: {status}\")\n    \n    print(f\"\\nTotal: {passed}/{total} tests passed\")\n    \n    if passed == total:\n        print(\"\\n\ud83c\udf89 ALL TESTS PASSED! The fix is working correctly.\")\n        sys.exit(0)\n    else:\n        print(f\"\\n\ud83d\udca5 {total - passed} tests failed. The fix needs more work.\")\n        sys.exit(1)"}, "action_id": "54be6dca-6813-4e19-b4b6-251f6529a36d"}