{"kind": "ObservationEvent", "id": "0ce28825-a332-4b43-ba07-2cbb240dd2b9", "timestamp": "2025-09-25T11:20:24.005723", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_01DFZUAsvmEf4PfGYkyVX8bd", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmpqkw8olt_/astropy/astropy/io/ascii/fixedwidth.py:\n     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\"\"\"An extensible ASCII table reader and writer.\n     3\t\n     4\tfixedwidth.py:\n     5\t  Read or write a table with fixed width columns.\n     6\t\n     7\t:Copyright: Smithsonian Astrophysical Observatory (2011)\n     8\t:Author: Tom Aldcroft (aldcroft@head.cfa.harvard.edu)\n     9\t\"\"\"\n    10\t\n    11\t\n    12\tfrom . import basic, core\n    13\tfrom .core import DefaultSplitter, InconsistentTableError\n    14\t\n    15\t\n    16\tclass FixedWidthSplitter(core.BaseSplitter):\n    17\t    \"\"\"\n    18\t    Split line based on fixed start and end positions for each ``col`` in\n    19\t    ``self.cols``.\n    20\t\n    21\t    This class requires that the Header class will have defined ``col.start``\n    22\t    and ``col.end`` for each column.  The reference to the ``header.cols`` gets\n    23\t    put in the splitter object by the base Reader.read() function just in time\n    24\t    for splitting data lines by a ``data`` object.\n    25\t\n    26\t    Note that the ``start`` and ``end`` positions are defined in the pythonic\n    27\t    style so line[start:end] is the desired substring for a column.  This splitter\n    28\t    class does not have a hook for ``process_lines`` since that is generally not\n    29\t    useful for fixed-width input.\n    30\t\n    31\t    \"\"\"\n    32\t\n    33\t    delimiter_pad = \"\"\n    34\t    bookend = False\n    35\t    delimiter = \"|\"\n    36\t\n    37\t    def __call__(self, lines):\n    38\t        for line in lines:\n    39\t            vals = [line[x.start : x.end] for x in self.cols]\n    40\t            if self.process_val:\n    41\t                yield [self.process_val(x) for x in vals]\n    42\t            else:\n    43\t                yield vals\n    44\t\n    45\t    def join(self, vals, widths):\n    46\t        pad = self.delimiter_pad or \"\"\n    47\t        delimiter = self.delimiter or \"\"\n    48\t        padded_delim = pad + delimiter + pad\n    49\t        if self.bookend:\n    50\t            bookend_left = delimiter + pad\n    51\t            bookend_right = pad + delimiter\n    52\t        else:\n    53\t            bookend_left = \"\"\n    54\t            bookend_right = \"\"\n    55\t        vals = [\" \" * (width - len(val)) + val for val, width in zip(vals, widths)]\n    56\t        return bookend_left + padded_delim.join(vals) + bookend_right\n    57\t\n    58\t\n    59\tclass FixedWidthHeaderSplitter(DefaultSplitter):\n    60\t    \"\"\"Splitter class that splits on ``|``.\"\"\"\n    61\t\n    62\t    delimiter = \"|\"\n    63\t\n    64\t\n    65\tclass FixedWidthHeader(basic.BasicHeader):\n    66\t    \"\"\"\n    67\t    Fixed width table header reader.\n    68\t    \"\"\"\n    69\t\n    70\t    splitter_class = FixedWidthHeaderSplitter\n    71\t    \"\"\" Splitter class for splitting data lines into columns \"\"\"\n    72\t    position_line = None  # secondary header line position\n    73\t    \"\"\" row index of line that specifies position (default = 1) \"\"\"\n    74\t    set_of_position_line_characters = set(r'`~!#$%^&*-_+=\\|\":' + \"'\")\n    75\t\n    76\t    def get_line(self, lines, index):\n    77\t        for i, line in enumerate(self.process_lines(lines)):\n    78\t            if i == index:\n    79\t                break\n    80\t        else:  # No header line matching\n    81\t            raise InconsistentTableError(\"No header line found in table\")\n    82\t        return line\n    83\t\n    84\t    def get_cols(self, lines):\n    85\t        \"\"\"\n    86\t        Initialize the header Column objects from the table ``lines``.\n    87\t\n    88\t        Based on the previously set Header attributes find or create the column names.\n    89\t        Sets ``self.cols`` with the list of Columns.\n    90\t\n    91\t        Parameters\n    92\t        ----------\n    93\t        lines : list\n    94\t            List of table lines\n    95\t\n    96\t        \"\"\"\n    97\t        header_rows = getattr(self, \"header_rows\", [\"name\"])\n    98\t\n    99\t        # See \"else\" clause below for explanation of start_line and position_line\n   100\t        start_line = core._get_line_index(self.start_line, self.process_lines(lines))\n   101\t        position_line = core._get_line_index(\n   102\t            self.position_line, self.process_lines(lines)\n   103\t        )\n   104\t\n   105\t        # If start_line is none then there is no header line.  Column positions are\n   106\t        # determined from first data line and column names are either supplied by user\n   107\t        # or auto-generated.\n   108\t        if start_line is None:\n   109\t            if position_line is not None:\n   110\t                raise ValueError(\n   111\t                    \"Cannot set position_line without also setting header_start\"\n   112\t                )\n   113\t\n   114\t            # data.data_lines attribute already set via self.data.get_data_lines(lines)\n   115\t            # in BaseReader.read().  This includes slicing for data_start / data_end.\n   116\t            data_lines = self.data.data_lines\n   117\t\n   118\t            if not data_lines:\n   119\t                raise InconsistentTableError(\n   120\t                    \"No data lines found so cannot autogenerate column names\"\n   121\t                )\n   122\t            vals, starts, ends = self.get_fixedwidth_params(data_lines[0])\n   123\t\n   124\t            self.names = [self.auto_format.format(i) for i in range(1, len(vals) + 1)]\n   125\t\n   126\t        else:\n   127\t            # This bit of code handles two cases:\n   128\t            # start_line = <index> and position_line = None\n   129\t            #    Single header line where that line is used to determine both the\n   130\t            #    column positions and names.\n   131\t            # start_line = <index> and position_line = <index2>\n   132\t            #    Two header lines where the first line defines the column names and\n   133\t            #    the second line defines the column positions\n   134\t\n   135\t            if position_line is not None:\n   136\t                # Define self.col_starts and self.col_ends so that the call to\n   137\t                # get_fixedwidth_params below will use those to find the header\n   138\t                # column names.  Note that get_fixedwidth_params returns Python\n   139\t                # slice col_ends but expects inclusive col_ends on input (for\n   140\t                # more intuitive user interface).\n   141\t                line = self.get_line(lines, position_line)\n   142\t                if len(set(line) - {self.splitter.delimiter, \" \"}) != 1:\n   143\t                    raise InconsistentTableError(\n   144\t                        \"Position line should only contain delimiters and \"\n   145\t                        'one other character, e.g. \"--- ------- ---\".'\n   146\t                    )\n   147\t                    # The line above lies. It accepts white space as well.\n   148\t                    # We don't want to encourage using three different\n   149\t                    # characters, because that can cause ambiguities, but white\n   150\t                    # spaces are so common everywhere that practicality beats\n   151\t                    # purity here.\n   152\t                charset = self.set_of_position_line_characters.union(\n   153\t                    {self.splitter.delimiter, \" \"}\n   154\t                )\n   155\t                if not set(line).issubset(charset):\n   156\t                    raise InconsistentTableError(\n   157\t                        f\"Characters in position line must be part of {charset}\"\n   158\t                    )\n   159\t                vals, self.col_starts, col_ends = self.get_fixedwidth_params(line)\n   160\t                self.col_ends = [x - 1 if x is not None else None for x in col_ends]\n   161\t\n   162\t            # Get the column names from the header line\n   163\t            line = self.get_line(lines, start_line + header_rows.index(\"name\"))\n   164\t            self.names, starts, ends = self.get_fixedwidth_params(line)\n   165\t\n   166\t        self._set_cols_from_names()\n   167\t\n   168\t        for ii, attr in enumerate(header_rows):\n   169\t            if attr != \"name\":\n   170\t                line = self.get_line(lines, start_line + ii)\n   171\t                vals = self.get_fixedwidth_params(line)[0]\n   172\t                for col, val in zip(self.cols, vals):\n   173\t                    if val:\n   174\t                        setattr(col, attr, val)\n   175\t\n   176\t        # Set column start and end positions.\n   177\t        for i, col in enumerate(self.cols):\n   178\t            col.start = starts[i]\n   179\t            col.end = ends[i]\n   180\t\n   181\t    def get_fixedwidth_params(self, line):\n   182\t        \"\"\"\n   183\t        Split ``line`` on the delimiter and determine column values and\n   184\t        column start and end positions.  This might include null columns with\n   185\t        zero length (e.g. for ``header row = \"| col1 || col2 | col3 |\"`` or\n   186\t        ``header2_row = \"----- ------- -----\"``).  The null columns are\n   187\t        stripped out.  Returns the values between delimiters and the\n   188\t        corresponding start and end positions.\n   189\t\n   190\t        Parameters\n   191\t        ----------\n   192\t        line : str\n   193\t            Input line\n   194\t\n   195\t        Returns\n   196\t        -------\n   197\t        vals : list\n   198\t            List of values.\n   199\t        starts : list\n   200\t           <response clipped><NOTE>Due to the max output limit, only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE> of col_starts or col_ends is given...\n   201\t            if self.col_starts is not None:\n   202\t                starts = list(self.col_starts)\n   203\t                ends = starts[1:] + [None]  # Assume each col ends where the next starts\n   204\t            else:  # self.col_ends is not None\n   205\t                ends = [x + 1 for x in self.col_ends]\n   206\t                starts = [0] + ends[:-1]  # Assume each col starts where the last ended\n   207\t            vals = [line[start:end].strip() for start, end in zip(starts, ends)]\n   208\t\n   209\t        return vals, starts, ends\n   210\t\n   211\t    def write(self, lines):\n   212\t        # Header line not written until data are formatted.  Until then it is\n   213\t        # not known how wide each column will be for fixed width.\n   214\t        pass\n   215\t\n   216\t\n   217\tclass FixedWidthData(basic.BasicData):\n   218\t    \"\"\"\n   219\t    Base table data reader.\n   220\t    \"\"\"\n   221\t\n   222\t    splitter_class = FixedWidthSplitter\n   223\t    \"\"\" Splitter class for splitting data lines into columns \"\"\"\n   224\t    start_line = None\n   225\t\n   226\t    def write(self, lines):\n   227\t        default_header_rows = [] if self.header.start_line is None else [\"name\"]\n   228\t        header_rows = getattr(self, \"header_rows\", default_header_rows)\n   229\t        # First part is getting the widths of each column.\n   230\t        # List (rows) of list (column values) for data lines\n   231\t        vals_list = []\n   232\t        col_str_iters = self.str_vals()\n   233\t        for vals in zip(*col_str_iters):\n   234\t            vals_list.append(vals)\n   235\t\n   236\t        # List (rows) of list (columns values) for header lines.\n   237\t        hdrs_list = []\n   238\t        for col_attr in header_rows:\n   239\t            vals = [\n   240\t                \"\" if (val := getattr(col.info, col_attr)) is None else str(val)\n   241\t                for col in self.cols\n   242\t            ]\n   243\t            hdrs_list.append(vals)\n   244\t\n   245\t        # Widths for data columns\n   246\t        widths = [\n   247\t            max(len(vals[i_col]) for vals in vals_list)\n   248\t            for i_col in range(len(self.cols))\n   249\t        ]\n   250\t        # Incorporate widths for header columns (if there are any)\n   251\t        if hdrs_list:\n   252\t            for i_col in range(len(self.cols)):\n   253\t                widths[i_col] = max(\n   254\t                    widths[i_col], max(len(vals[i_col]) for vals in hdrs_list)\n   255\t                )\n   256\t\n   257\t        # Now collect formatted header and data lines into the output lines\n   258\t        for vals in hdrs_list:\n   259\t            lines.append(self.splitter.join(vals, widths))\n   260\t\n   261\t        if self.header.position_line is not None:\n   262\t            vals = [self.header.position_char * width for width in widths]\n   263\t            lines.append(self.splitter.join(vals, widths))\n   264\t\n   265\t        for vals in vals_list:\n   266\t            lines.append(self.splitter.join(vals, widths))\n   267\t\n   268\t        return lines\n   269\t\n   270\t\n   271\tclass FixedWidth(basic.Basic):\n   272\t    \"\"\"Fixed width table with single header line defining column names and positions.\n   273\t\n   274\t    Examples::\n   275\t\n   276\t      # Bar delimiter in header and data\n   277\t\n   278\t      |  Col1 |   Col2      |  Col3 |\n   279\t      |  1.2  | hello there |     3 |\n   280\t      |  2.4  | many words  |     7 |\n   281\t\n   282\t      # Bar delimiter in header only\n   283\t\n   284\t      Col1 |   Col2      | Col3\n   285\t      1.2    hello there    3\n   286\t      2.4    many words     7\n   287\t\n   288\t      # No delimiter with column positions specified as input\n   289\t\n   290\t      Col1       Col2Col3\n   291\t       1.2hello there   3\n   292\t       2.4many words    7\n   293\t\n   294\t    See the :ref:`astropy:fixed_width_gallery` for specific usage examples.\n   295\t\n   296\t    \"\"\"\n   297\t\n   298\t    _format_name = \"fixed_width\"\n   299\t    _description = \"Fixed width\"\n   300\t\n   301\t    header_class = FixedWidthHeader\n   302\t    data_class = FixedWidthData\n   303\t\n   304\t    def __init__(\n   305\t        self,\n   306\t        col_starts=None,\n   307\t        col_ends=None,\n   308\t        delimiter_pad=\" \",\n   309\t        bookend=True,\n   310\t        header_rows=None,\n   311\t    ):\n   312\t        if header_rows is None:\n   313\t            header_rows = [\"name\"]\n   314\t        super().__init__()\n   315\t        self.data.splitter.delimiter_pad = delimiter_pad\n   316\t        self.data.splitter.bookend = bookend\n   317\t        self.header.col_starts = col_starts\n   318\t        self.header.col_ends = col_ends\n   319\t        self.header.header_rows = header_rows\n   320\t        self.data.header_rows = header_rows\n   321\t        if self.data.start_line is None:\n   322\t            self.data.start_line = len(header_rows)\n   323\t\n   324\t\n   325\tclass FixedWidthNoHeaderHeader(FixedWidthHeader):\n   326\t    \"\"\"Header reader for fixed with tables with no header line\"\"\"\n   327\t\n   328\t    start_line = None\n   329\t\n   330\t\n   331\tclass FixedWidthNoHeaderData(FixedWidthData):\n   332\t    \"\"\"Data reader for fixed width tables with no header line\"\"\"\n   333\t\n   334\t    start_line = 0\n   335\t\n   336\t\n   337\tclass FixedWidthNoHeader(FixedWidth):\n   338\t    \"\"\"Fixed width table which has no header line.\n   339\t\n   340\t    When reading, column names are either input (``names`` keyword) or\n   341\t    auto-generated.  Column positions are determined either by input\n   342\t    (``col_starts`` and ``col_stops`` keywords) or by splitting the first data\n   343\t    line.  In the latter case a ``delimiter`` is required to split the data\n   344\t    line.\n   345\t\n   346\t    Examples::\n   347\t\n   348\t      # Bar delimiter in header and data\n   349\t\n   350\t      |  1.2  | hello there |     3 |\n   351\t      |  2.4  | many words  |     7 |\n   352\t\n   353\t      # Compact table having no delimiter and column positions specified as input\n   354\t\n   355\t      1.2hello there3\n   356\t      2.4many words 7\n   357\t\n   358\t    This class is just a convenience wrapper around the ``FixedWidth`` reader\n   359\t    but with ``header_start=None`` and ``data_start=0``.\n   360\t\n   361\t    See the :ref:`astropy:fixed_width_gallery` for specific usage examples.\n   362\t\n   363\t    \"\"\"\n   364\t\n   365\t    _format_name = \"fixed_width_no_header\"\n   366\t    _description = \"Fixed width with no header\"\n   367\t    header_class = FixedWidthNoHeaderHeader\n   368\t    data_class = FixedWidthNoHeaderData\n   369\t\n   370\t    def __init__(self, col_starts=None, col_ends=None, delimiter_pad=\" \", bookend=True):\n   371\t        super().__init__(\n   372\t            col_starts,\n   373\t            col_ends,\n   374\t            delimiter_pad=delimiter_pad,\n   375\t            bookend=bookend,\n   376\t            header_rows=[],\n   377\t        )\n   378\t\n   379\t\n   380\tclass FixedWidthTwoLineHeader(FixedWidthHeader):\n   381\t    \"\"\"Header reader for fixed width tables splitting on whitespace.\n   382\t\n   383\t    For fixed width tables with several header lines, there is typically\n   384\t    a white-space delimited format line, so splitting on white space is\n   385\t    needed.\n   386\t    \"\"\"\n   387\t\n   388\t    splitter_class = DefaultSplitter\n   389\t\n   390\t\n   391\tclass FixedWidthTwoLineDataSplitter(FixedWidthSplitter):\n   392\t    \"\"\"Splitter for fixed width tables splitting on ``' '``.\"\"\"\n   393\t\n   394\t    delimiter = \" \"\n   395\t\n   396\t\n   397\tclass FixedWidthTwoLineData(FixedWidthData):\n   398\t    \"\"\"Data reader for fixed with tables with two header lines.\"\"\"\n   399\t\n   400\t    splitter_class = FixedWidthTwoLineDataSplitter\n   401\t\n   402\t\n   403\tclass FixedWidthTwoLine(FixedWidth):\n   404\t    \"\"\"Fixed width table which has two header lines.\n   405\t\n   406\t    The first header line defines the column names and the second implicitly\n   407\t    defines the column positions.\n   408\t\n   409\t    Examples::\n   410\t\n   411\t      # Typical case with column extent defined by ---- under column names.\n   412\t\n   413\t       col1    col2         <== header_start = 0\n   414\t      -----  ------------   <== position_line = 1, position_char = \"-\"\n   415\t        1     bee flies     <== data_start = 2\n   416\t        2     fish swims\n   417\t\n   418\t      # Pretty-printed table\n   419\t\n   420\t      +------+------------+\n   421\t      | Col1 |   Col2     |\n   422\t      +------+------------+\n   423\t      |  1.2 | \"hello\"    |\n   424\t      |  2.4 | there world|\n   425\t      +------+------------+\n   426\t\n   427\t    See the :ref:`astropy:fixed_width_gallery` for specific usage examples.\n   428\t\n   429\t    \"\"\"\n   430\t\n   431\t    _format_name = \"fixed_width_two_line\"\n   432\t    _description = \"Fixed width with second header line\"\n   433\t    data_class = FixedWidthTwoLineData\n   434\t    header_class = FixedWidthTwoLineHeader\n   435\t\n   436\t    def __init__(\n   437\t        self,\n   438\t        position_line=None,\n   439\t        position_char=\"-\",\n   440\t        delimiter_pad=None,\n   441\t        bookend=False,\n   442\t        header_rows=None,\n   443\t    ):\n   444\t        if len(position_char) != 1:\n   445\t            raise ValueError(\n   446\t                f'Position_char=\"{position_char}\" must be a single character'\n   447\t            )\n   448\t        super().__init__(\n   449\t            delimiter_pad=delimiter_pad, bookend=bookend, header_rows=header_rows\n   450\t        )\n   451\t        if position_line is None:\n   452\t            position_line = len(self.header.header_rows)\n   453\t        self.header.position_line = position_line\n   454\t        self.header.position_char = position_char\n   455\t        self.data.start_line = position_line + 1\n   456\t\n", "path": "/tmp/tmpqkw8olt_/astropy/astropy/io/ascii/fixedwidth.py", "prev_exist": true}, "action_id": "5c282dc1-b2f0-477e-aa32-daf60c8af895"}