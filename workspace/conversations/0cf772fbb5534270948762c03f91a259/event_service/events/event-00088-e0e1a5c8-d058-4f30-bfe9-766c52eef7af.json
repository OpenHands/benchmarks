{"kind": "ObservationEvent", "id": "e0e1a5c8-d058-4f30-bfe9-766c52eef7af", "timestamp": "2025-09-25T11:32:51.459126", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_0157rvWLNXyPZAQmgayVkMue", "observation": {"kind": "StrReplaceEditorObservation", "command": "create", "output": "File created successfully at: /tmp/tmp4ui7_uuu/astropy/test_fix_verification.py", "path": "/tmp/tmp4ui7_uuu/astropy/test_fix_verification.py", "prev_exist": false, "new_content": "#!/usr/bin/env python3\n\"\"\"\nTest to verify the fix for nested CompoundModel separability and ensure\nexisting functionality still works.\n\"\"\"\n\nimport numpy as np\nfrom numpy.testing import assert_allclose\n\n# Mock the core classes we need\nclass Model:\n    \"\"\"Mock base model class.\"\"\"\n    def __init__(self, n_inputs, n_outputs, separable=True, name=None):\n        self.n_inputs = n_inputs\n        self.n_outputs = n_outputs\n        self.separable = separable\n        self.name = name or f\"Model({n_inputs}\u2192{n_outputs})\"\n        self.inputs = tuple(f'x{i}' for i in range(n_inputs))\n        self.outputs = tuple(f'y{i}' for i in range(n_outputs))\n    \n    def _calculate_separability_matrix(self):\n        return NotImplemented\n    \n    def __and__(self, other):\n        return CompoundModel('&', self, other)\n    \n    def __or__(self, other):\n        return CompoundModel('|', self, other)\n\nclass CompoundModel(Model):\n    \"\"\"Mock compound model class.\"\"\"\n    def __init__(self, op, left, right):\n        self.op = op\n        self.left = left\n        self.right = right\n        \n        if op == '&':\n            self.n_inputs = left.n_inputs + right.n_inputs\n            self.n_outputs = left.n_outputs + right.n_outputs\n        elif op == '|':\n            self.n_inputs = left.n_inputs\n            self.n_outputs = right.n_outputs\n        \n        self.inputs = tuple(f'x{i}' for i in range(self.n_inputs))\n        self.outputs = tuple(f'y{i}' for i in range(self.n_outputs))\n        self.separable = True  # This doesn't matter for compound models\n        self.name = f\"({left.name} {op} {right.name})\"\n    \n    def _calculate_separability_matrix(self):\n        return NotImplemented\n\nclass Mapping:\n    \"\"\"Mock mapping class.\"\"\"\n    def __init__(self, mapping, name=None):\n        self.mapping = mapping\n        self.n_inputs = max(mapping) + 1\n        self.n_outputs = len(mapping)\n        self.name = name or f\"Mapping{mapping}\"\n\n# Copy the separability functions from the actual file (with the fix)\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat\n\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right  # FIXED: was = 1\n\n    return np.hstack([cleft, cright])\n\ndef _cdot(left, right):\n    \"\"\"\n    Function corresponding to \"|\" operation.\n    \"\"\"\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', left.n_outputs)\n    else:\n        cleft = left\n\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'left', right.n_outputs)\n    else:\n        cright = right\n    return np.dot(cright, cleft)\n\ndef _separable(transform):\n    \"\"\"\n    Calculate the separability of outputs.\n    \"\"\"\n    if (transform_matrix := transform._calculate_separability_matrix()) is not NotImplemented:\n        return transform_matrix\n    elif isinstance(transform, CompoundModel):\n        sepleft = _separable(transform.left)\n        sepright = _separable(transform.right)\n        return _operators[transform.op](sepleft, sepright)\n    elif isinstance(transform, Model):\n        return _coord_matrix(transform, 'left', transform.n_outputs)\n\ndef separability_matrix(transform):\n    \"\"\"\n    Compute the correlation between outputs and inputs.\n    \"\"\"\n    if transform.n_inputs == 1 and transform.n_outputs > 1:\n        return np.ones((transform.n_outputs, transform.n_inputs),\n                       dtype=np.bool_)\n    separable_matrix = _separable(transform)\n    separable_matrix = np.where(separable_matrix != 0, True, False)\n    return separable_matrix\n\n# Maps modeling operators to a function computing and represents the\n# relationship of axes as an array of 0-es and 1-s\n_operators = {'&': _cstack, '|': _cdot}\n\ndef test_coord_matrix():\n    \"\"\"Test _coord_matrix function (existing functionality).\"\"\"\n    print(\"Testing _coord_matrix...\")\n    \n    # Test separable model\n    sh1 = Model(1, 1, separable=True, name='shift1')\n    result = _coord_matrix(sh1, 'left', 1)\n    expected = np.array([[1]])\n    assert_allclose(result, expected)\n    \n    # Test non-separable model\n    rot = Model(2, 2, separable=False, name='rotation')\n    result = _coord_matrix(rot, 'left', 2)\n    expected = np.array([[1, 1], [1, 1]])\n    assert_allclose(result, expected)\n    \n    print(\"\u2713 _coord_matrix tests passed\")\n\ndef test_cstack():\n    \"\"\"Test _cstack function (existing functionality).\"\"\"\n    print(\"Testing _cstack...\")\n    \n    # Create test models\n    sh1 = Model(1, 1, separable=True, name='shift1')\n    sh2 = Model(1, 1, separable=True, name='shift2')\n    rot = Model(2, 2, separable=False, name='rotation')\n    \n    # Test simple case\n    result = _cstack(sh1, sh2)\n    expected = np.array([[1, 0], [0, 1]])\n    assert_allclose(result, expected)\n    \n    # Test mixed case\n    result = _cstack(sh1, rot)\n    expected = np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1]])\n    assert_allclose(result, expected)\n    \n    result = _cstack(rot, sh1)\n    expected = np.array([[1, 1, 0], [1, 1, 0], [0, 0, 1]])\n    assert_allclose(result, expected)\n    \n    print(\"\u2713 _cstack tests passed\")\n\ndef test_nested_compound_fix():\n    \"\"\"Test the specific fix for nested compound models.\"\"\"\n    print(\"Testing nested compound model fix...\")\n    \n    # Create models\n    linear1 = Model(1, 1, separable=True, name='Linear1D(10)')\n    linear2 = Model(1, 1, separable=True, name='Linear1D(5)')\n    pix2sky = Model(2, 2, separable=False, name='Pix2Sky_TAN')\n    \n    # Create simple compound model\n    cm = linear1 & linear2\n    \n    # Create nested compound model\n    nested_cm = pix2sky & cm\n    \n    # Test separability matrix\n    result = separability_matrix(nested_cm)\n    expected = np.array([\n        [True, True, False, False],\n        [True, True, False, False],\n        [False, False, True, False],\n        [False, False, False, True]\n    ])\n    \n    assert_allclose(result, expected)\n    print(\"\u2713 Nested compound model fix verified\")\n\ndef test_existing_compound_models():\n    \"\"\"Test some existing compound model patterns to ensure no regression.\"\"\"\n    print(\"Testing existing compound model patterns...\")\n    \n    # Create models similar to those in the original test file\n    sh1 = Model(1, 1, separable=True, name='shift1')\n    sh2 = Model(1, 1, separable=True, name='shift2')\n    scl1 = Model(1, 1, separable=True, name='scale1')\n    scl2 = Model(1, 1, separable=True, name='scale2')\n    rot = Model(2, 2, separable=False, name='rotation')\n    map3 = Mapping((0, 0), name='map3')\n    \n    # Test case: map3 & sh1 | rot & sh1 | sh1 & sh2 & sh1\n    # This is a complex compound model from the original tests\n    cm1_part1 = map3 & sh1\n    cm1_part2 = rot & sh1\n    cm1_part3 = sh1 & sh2 & sh1\n    cm1_temp = cm1_part1 | cm1_part2\n    cm1 = cm1_temp | cm1_part3\n    \n    # Just verify it doesn't crash and produces reasonable output\n    result = separability_matrix(cm1)\n    assert result.shape == (3, 2)  # Expected dimensions\n    \n    print(\"\u2713 Existing compound model patterns work\")\n\ndef run_all_tests():\n    \"\"\"Run all tests.\"\"\"\n    print(\"Running Fix Verification Tests\")\n    print(\"=\" * 50)\n    \n    try:\n        test_coord_matrix()\n        test_cstack()\n        test_nested_compound_fix()\n        test_existing_compound_models()\n        \n        print(\"\\n\" + \"=\" * 50)\n        print(\"\ud83c\udf89 ALL TESTS PASSED!\")\n        print(\"The fix works correctly and doesn't break existing functionality.\")\n        print(\"=\" * 50)\n        \n    except Exception as e:\n        print(f\"\\n\u274c TEST FAILED: {e}\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == \"__main__\":\n    run_all_tests()"}, "action_id": "21c25d5f-564d-4baa-add8-a98ab3b861ec"}