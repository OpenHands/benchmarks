{"kind": "ObservationEvent", "id": "1697fd2a-8e2b-4a73-9177-423906b467ef", "timestamp": "2025-09-25T11:27:24.861623", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_018JSLpngPPvfGxME7ZrckFE", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmp4ui7_uuu/astropy/astropy/modeling/tests/test_separable.py:\n     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\"\"\"\n     3\tTest separability of models.\n     4\t\n     5\t\"\"\"\n     6\t# pylint: disable=invalid-name\n     7\timport pytest\n     8\timport numpy as np\n     9\tfrom numpy.testing import assert_allclose\n    10\t\n    11\tfrom astropy.modeling import custom_model, models\n    12\tfrom astropy.modeling.models import Mapping\n    13\tfrom astropy.modeling.separable import (_coord_matrix, is_separable, _cdot,\n    14\t                                        _cstack, _arith_oper, separability_matrix)\n    15\tfrom astropy.modeling.core import ModelDefinitionError\n    16\t\n    17\t\n    18\tsh1 = models.Shift(1, name='shift1')\n    19\tsh2 = models.Shift(2, name='sh2')\n    20\tscl1 = models.Scale(1, name='scl1')\n    21\tscl2 = models.Scale(2, name='scl2')\n    22\tmap1 = Mapping((0, 1, 0, 1), name='map1')\n    23\tmap2 = Mapping((0, 0, 1), name='map2')\n    24\tmap3 = Mapping((0, 0), name='map3')\n    25\trot = models.Rotation2D(2, name='rotation')\n    26\tp2 = models.Polynomial2D(1, name='p2')\n    27\tp22 = models.Polynomial2D(2, name='p22')\n    28\tp1 = models.Polynomial1D(1, name='p1')\n    29\t\n    30\t\n    31\tcompound_models = {\n    32\t    'cm1': (map3 & sh1 | rot & sh1 | sh1 & sh2 & sh1,\n    33\t            (np.array([False, False, True]),\n    34\t             np.array([[True, False], [True, False], [False, True]]))\n    35\t            ),\n    36\t    'cm2': (sh1 & sh2 | rot | map1 | p2 & p22,\n    37\t            (np.array([False, False]),\n    38\t             np.array([[True, True], [True, True]]))\n    39\t            ),\n    40\t    'cm3': (map2 | rot & scl1,\n    41\t            (np.array([False, False, True]),\n    42\t             np.array([[True, False], [True, False], [False, True]]))\n    43\t            ),\n    44\t    'cm4': (sh1 & sh2 | map2 | rot & scl1,\n    45\t            (np.array([False, False, True]),\n    46\t             np.array([[True, False], [True, False], [False, True]]))\n    47\t            ),\n    48\t    'cm5': (map3 | sh1 & sh2 | scl1 & scl2,\n    49\t            (np.array([False, False]),\n    50\t             np.array([[True], [True]]))\n    51\t            ),\n    52\t    'cm7': (map2 | p2 & sh1,\n    53\t            (np.array([False, True]),\n    54\t             np.array([[True, False], [False, True]]))\n    55\t            )\n    56\t}\n    57\t\n    58\t\n    59\tdef test_coord_matrix():\n    60\t    c = _coord_matrix(p2, 'left', 2)\n    61\t    assert_allclose(np.array([[1, 1], [0, 0]]), c)\n    62\t    c = _coord_matrix(p2, 'right', 2)\n    63\t    assert_allclose(np.array([[0, 0], [1, 1]]), c)\n    64\t    c = _coord_matrix(p1, 'left', 2)\n    65\t    assert_allclose(np.array([[1], [0]]), c)\n    66\t    c = _coord_matrix(p1, 'left', 1)\n    67\t    assert_allclose(np.array([[1]]), c)\n    68\t    c = _coord_matrix(sh1, 'left', 2)\n    69\t    assert_allclose(np.array([[1], [0]]), c)\n    70\t    c = _coord_matrix(sh1, 'right', 2)\n    71\t    assert_allclose(np.array([[0], [1]]), c)\n    72\t    c = _coord_matrix(sh1, 'right', 3)\n    73\t    assert_allclose(np.array([[0], [0], [1]]), c)\n    74\t    c = _coord_matrix(map3, 'left', 2)\n    75\t    assert_allclose(np.array([[1], [1]]), c)\n    76\t    c = _coord_matrix(map3, 'left', 3)\n    77\t    assert_allclose(np.array([[1], [1], [0]]), c)\n    78\t\n    79\t\n    80\tdef test_cdot():\n    81\t    result = _cdot(sh1, scl1)\n    82\t    assert_allclose(result, np.array([[1]]))\n    83\t\n    84\t    result = _cdot(rot, p2)\n    85\t    assert_allclose(result, np.array([[2, 2]]))\n    86\t\n    87\t    result = _cdot(rot, rot)\n    88\t    assert_allclose(result, np.array([[2, 2], [2, 2]]))\n    89\t\n    90\t    result = _cdot(Mapping((0, 0)), rot)\n    91\t    assert_allclose(result, np.array([[2], [2]]))\n    92\t\n    93\t    with pytest.raises(ModelDefinitionError,\n    94\t                       match=r\"Models cannot be combined with the \\\"|\\\" operator; .*\"):\n    95\t        _cdot(sh1, map1)\n    96\t\n    97\t\n    98\tdef test_cstack():\n    99\t    result = _cstack(sh1, scl1)\n   100\t    assert_allclose(result, np.array([[1, 0], [0, 1]]))\n   101\t\n   102\t    result = _cstack(sh1, rot)\n   103\t    assert_allclose(result,\n   104\t                    np.array([[1, 0, 0],\n   105\t                              [0, 1, 1],\n   106\t                              [0, 1, 1]])\n   107\t                    )\n   108\t    result = _cstack(rot, sh1)\n   109\t    assert_allclose(result,\n   110\t                    np.array([[1, 1, 0],\n   111\t                              [1, 1, 0],\n   112\t                              [0, 0, 1]])\n   113\t                    )\n   114\t\n   115\t\n   116\tdef test_arith_oper():\n   117\t    # Models as inputs\n   118\t    result = _arith_oper(sh1, scl1)\n   119\t    assert_allclose(result, np.array([[1]]))\n   120\t    result = _arith_oper(rot, rot)\n   121\t    assert_allclose(result, np.array([[1, 1], [1, 1]]))\n   122\t\n   123\t    # ndarray\n   124\t    result = _arith_oper(np.array([[1, 2], [3, 4]]), np.array([[1, 2], [3, 4]]))\n   125\t    assert_allclose(result, np.array([[1, 1], [1, 1]]))\n   126\t\n   127\t    # Error\n   128\t    with pytest.raises(ModelDefinitionError, match=r\"Unsupported operands for arithmetic operator: .*\"):\n   129\t        _arith_oper(sh1, map1)\n   130\t\n   131\t\n   132\t@pytest.mark.parametrize(('compound_model', 'result'), compound_models.values())\n   133\tdef test_separable(compound_model, result):\n   134\t    assert_allclose(is_separable(compound_model), result[0])\n   135\t    assert_allclose(separability_matrix(compound_model), result[1])\n   136\t\n   137\t\n   138\tdef test_custom_model_separable():\n   139\t    @custom_model\n   140\t    def model_a(x):\n   141\t        return x\n   142\t\n   143\t    assert model_a().separable\n   144\t\n   145\t    @custom_model\n   146\t    def model_c(x, y):\n   147\t        return x + y\n   148\t\n   149\t    assert not model_c().separable\n   150\t    assert np.all(separability_matrix(model_c()) == [True, True])\n   151\t\n", "path": "/tmp/tmp4ui7_uuu/astropy/astropy/modeling/tests/test_separable.py", "prev_exist": true}, "action_id": "81c1c598-7341-4307-8ff6-3627f4534aa9"}