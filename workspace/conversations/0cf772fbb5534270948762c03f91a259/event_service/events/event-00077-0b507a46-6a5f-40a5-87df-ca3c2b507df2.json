{"kind": "ObservationEvent", "id": "0b507a46-6a5f-40a5-87df-ca3c2b507df2", "timestamp": "2025-09-25T11:31:25.017556", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_014uHSK45teEY6NTtEyMPmBB", "observation": {"kind": "StrReplaceEditorObservation", "command": "create", "output": "File created successfully at: /tmp/tmp4ui7_uuu/astropy/test_comprehensive.py", "path": "/tmp/tmp4ui7_uuu/astropy/test_comprehensive.py", "prev_exist": false, "new_content": "#!/usr/bin/env python3\n\"\"\"\nComprehensive test for the separability matrix fix.\nTests various combinations of nested and non-nested compound models.\n\"\"\"\n\nimport numpy as np\n\n# Mock the core classes we need\nclass Model:\n    \"\"\"Mock base model class.\"\"\"\n    def __init__(self, n_inputs, n_outputs, separable=True):\n        self.n_inputs = n_inputs\n        self.n_outputs = n_outputs\n        self.separable = separable\n        self.inputs = tuple(f'x{i}' for i in range(n_inputs))\n        self.outputs = tuple(f'y{i}' for i in range(n_outputs))\n    \n    def _calculate_separability_matrix(self):\n        return NotImplemented\n    \n    def __and__(self, other):\n        return CompoundModel('&', self, other)\n\nclass CompoundModel(Model):\n    \"\"\"Mock compound model class.\"\"\"\n    def __init__(self, op, left, right):\n        self.op = op\n        self.left = left\n        self.right = right\n        \n        if op == '&':\n            self.n_inputs = left.n_inputs + right.n_inputs\n            self.n_outputs = left.n_outputs + right.n_outputs\n        \n        self.inputs = tuple(f'x{i}' for i in range(self.n_inputs))\n        self.outputs = tuple(f'y{i}' for i in range(self.n_outputs))\n        self.separable = True  # This doesn't matter for compound models\n    \n    def _calculate_separability_matrix(self):\n        return NotImplemented\n\nclass Mapping:\n    \"\"\"Mock mapping class.\"\"\"\n    def __init__(self, mapping):\n        self.mapping = mapping\n        self.n_inputs = max(mapping) + 1\n        self.n_outputs = len(mapping)\n\n# Copy the separability functions from the actual file (with the fix)\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat\n\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right  # FIXED: was = 1\n\n    return np.hstack([cleft, cright])\n\ndef _separable(transform):\n    \"\"\"\n    Calculate the separability of outputs.\n    \"\"\"\n    if (transform_matrix := transform._calculate_separability_matrix()) is not NotImplemented:\n        return transform_matrix\n    elif isinstance(transform, CompoundModel):\n        sepleft = _separable(transform.left)\n        sepright = _separable(transform.right)\n        return _operators[transform.op](sepleft, sepright)\n    elif isinstance(transform, Model):\n        return _coord_matrix(transform, 'left', transform.n_outputs)\n\ndef separability_matrix(transform):\n    \"\"\"\n    Compute the correlation between outputs and inputs.\n    \"\"\"\n    if transform.n_inputs == 1 and transform.n_outputs > 1:\n        return np.ones((transform.n_outputs, transform.n_inputs),\n                       dtype=np.bool_)\n    separable_matrix = _separable(transform)\n    separable_matrix = np.where(separable_matrix != 0, True, False)\n    return separable_matrix\n\n# Maps modeling operators to a function computing and represents the\n# relationship of axes as an array of 0-es and 1-s\n_operators = {'&': _cstack}\n\ndef test_comprehensive():\n    \"\"\"Comprehensive test for separability matrix with various nesting scenarios.\"\"\"\n    \n    print(\"Comprehensive Separability Matrix Test\")\n    print(\"=\" * 60)\n    \n    # Create basic models\n    linear1 = Model(1, 1, separable=True)   # Linear1D(10)\n    linear2 = Model(1, 1, separable=True)   # Linear1D(5)\n    linear3 = Model(1, 1, separable=True)   # Linear1D(3)\n    pix2sky = Model(2, 2, separable=False)  # Pix2Sky_TAN()\n    \n    tests = []\n    \n    # Test 1: Simple separable models\n    print(\"Test 1: Simple separable models\")\n    cm1 = linear1 & linear2\n    expected1 = np.array([[True, False], [False, True]])\n    result1 = separability_matrix(cm1)\n    tests.append((\"linear1 & linear2\", result1, expected1))\n    \n    # Test 2: Simple non-separable + separable\n    print(\"Test 2: Non-separable + separable models\")\n    cm2 = pix2sky & linear1\n    expected2 = np.array([\n        [True, True, False],\n        [True, True, False],\n        [False, False, True]\n    ])\n    result2 = separability_matrix(cm2)\n    tests.append((\"pix2sky & linear1\", result2, expected2))\n    \n    # Test 3: Three separable models (non-nested)\n    print(\"Test 3: Three separable models (non-nested)\")\n    cm3 = linear1 & linear2 & linear3\n    expected3 = np.array([\n        [True, False, False],\n        [False, True, False],\n        [False, False, True]\n    ])\n    result3 = separability_matrix(cm3)\n    tests.append((\"linear1 & linear2 & linear3\", result3, expected3))\n    \n    # Test 4: Nested compound model (the original bug case)\n    print(\"Test 4: Nested compound model (original bug case)\")\n    cm4 = pix2sky & cm1  # cm1 is linear1 & linear2\n    expected4 = np.array([\n        [True, True, False, False],\n        [True, True, False, False],\n        [False, False, True, False],\n        [False, False, False, True]\n    ])\n    result4 = separability_matrix(cm4)\n    tests.append((\"pix2sky & (linear1 & linear2)\", result4, expected4))\n    \n    # Test 5: Double nested compound model\n    print(\"Test 5: Double nested compound model\")\n    cm5_inner = linear2 & linear3  # Inner compound\n    cm5 = linear1 & cm5_inner      # Outer compound\n    expected5 = np.array([\n        [True, False, False],\n        [False, True, False],\n        [False, False, True]\n    ])\n    result5 = separability_matrix(cm5)\n    tests.append((\"linear1 & (linear2 & linear3)\", result5, expected5))\n    \n    # Test 6: Complex nested with non-separable\n    print(\"Test 6: Complex nested with non-separable\")\n    cm6 = cm1 & pix2sky  # (linear1 & linear2) & pix2sky\n    expected6 = np.array([\n        [True, False, False, False],\n        [False, True, False, False],\n        [False, False, True, True],\n        [False, False, True, True]\n    ])\n    result6 = separability_matrix(cm6)\n    tests.append((\"(linear1 & linear2) & pix2sky\", result6, expected6))\n    \n    # Test 7: Triple nesting\n    print(\"Test 7: Triple nesting\")\n    cm7_inner = linear2 & linear3\n    cm7_middle = linear1 & cm7_inner\n    cm7 = pix2sky & cm7_middle\n    expected7 = np.array([\n        [True, True, False, False, False],\n        [True, True, False, False, False],\n        [False, False, True, False, False],\n        [False, False, False, True, False],\n        [False, False, False, False, True]\n    ])\n    result7 = separability_matrix(cm7)\n    tests.append((\"pix2sky & (linear1 & (linear2 & linear3))\", result7, expected7))\n    \n    # Run all tests and report results\n    print(\"\\n\" + \"=\" * 60)\n    print(\"TEST RESULTS:\")\n    print(\"=\" * 60)\n    \n    all_passed = True\n    for i, (description, result, expected) in enumerate(tests, 1):\n        if np.array_equal(result, expected):\n            print(f\"Test {i}: \u2713 PASS - {description}\")\n        else:\n            print(f\"Test {i}: \u2717 FAIL - {description}\")\n            print(f\"  Expected:\\n{expected}\")\n            print(f\"  Got:\\n{result}\")\n            all_passed = False\n    \n    print(\"\\n\" + \"=\" * 60)\n    if all_passed:\n        print(\"\ud83c\udf89 ALL TESTS PASSED! The fix is working correctly.\")\n    else:\n        print(\"\u274c SOME TESTS FAILED! The fix needs more work.\")\n    print(\"=\" * 60)\n\nif __name__ == \"__main__\":\n    test_comprehensive()"}, "action_id": "64995f3f-f106-419a-8c37-53f2ff51e849"}