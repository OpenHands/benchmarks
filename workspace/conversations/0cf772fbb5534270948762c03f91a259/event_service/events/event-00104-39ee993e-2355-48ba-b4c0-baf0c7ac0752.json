{"kind": "ObservationEvent", "id": "39ee993e-2355-48ba-b4c0-baf0c7ac0752", "timestamp": "2025-09-25T11:34:14.711173", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_015jcmvNVCNjv2Mb3miDMRyK", "observation": {"kind": "StrReplaceEditorObservation", "command": "create", "output": "File created successfully at: /tmp/tmp4ui7_uuu/astropy/test_original_issue.py", "path": "/tmp/tmp4ui7_uuu/astropy/test_original_issue.py", "prev_exist": false, "new_content": "#!/usr/bin/env python3\n\"\"\"\nTest that exactly reproduces the original issue from the problem description.\nThis test uses the exact same pattern as described in the issue.\n\"\"\"\n\nimport numpy as np\n\n# Mock the core classes we need\nclass Model:\n    \"\"\"Mock base model class.\"\"\"\n    def __init__(self, n_inputs, n_outputs, separable=True, name=None):\n        self.n_inputs = n_inputs\n        self.n_outputs = n_outputs\n        self.separable = separable\n        self.name = name or f\"Model({n_inputs}\u2192{n_outputs})\"\n        self.inputs = tuple(f'x{i}' for i in range(n_inputs))\n        self.outputs = tuple(f'y{i}' for i in range(n_outputs))\n    \n    def _calculate_separability_matrix(self):\n        return NotImplemented\n    \n    def __and__(self, other):\n        return CompoundModel('&', self, other)\n\nclass CompoundModel(Model):\n    \"\"\"Mock compound model class.\"\"\"\n    def __init__(self, op, left, right):\n        self.op = op\n        self.left = left\n        self.right = right\n        \n        if op == '&':\n            self.n_inputs = left.n_inputs + right.n_inputs\n            self.n_outputs = left.n_outputs + right.n_outputs\n        \n        self.inputs = tuple(f'x{i}' for i in range(self.n_inputs))\n        self.outputs = tuple(f'y{i}' for i in range(self.n_outputs))\n        self.separable = True\n        self.name = f\"({left.name} {op} {right.name})\"\n    \n    def _calculate_separability_matrix(self):\n        return NotImplemented\n\n# Copy the separability functions from the actual file (with the fix)\ndef _compute_n_outputs(left, right):\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n\ndef _coord_matrix(model, pos, noutp):\n    if not model.separable:\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat\n\ndef _cstack(left, right):\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right  # FIXED: was = 1\n\n    return np.hstack([cleft, cright])\n\ndef _separable(transform):\n    if (transform_matrix := transform._calculate_separability_matrix()) is not NotImplemented:\n        return transform_matrix\n    elif isinstance(transform, CompoundModel):\n        sepleft = _separable(transform.left)\n        sepright = _separable(transform.right)\n        return _operators[transform.op](sepleft, sepright)\n    elif isinstance(transform, Model):\n        return _coord_matrix(transform, 'left', transform.n_outputs)\n\ndef separability_matrix(transform):\n    if transform.n_inputs == 1 and transform.n_outputs > 1:\n        return np.ones((transform.n_outputs, transform.n_inputs),\n                       dtype=np.bool_)\n    separable_matrix = _separable(transform)\n    separable_matrix = np.where(separable_matrix != 0, True, False)\n    return separable_matrix\n\n_operators = {'&': _cstack}\n\n# Mock the models from the original issue\ndef Linear1D(slope):\n    return Model(1, 1, separable=True, name=f'Linear1D({slope})')\n\ndef Pix2Sky_TAN():\n    return Model(2, 2, separable=False, name='Pix2Sky_TAN()')\n\ndef test_original_issue():\n    \"\"\"Test the exact scenario from the original issue description.\"\"\"\n    \n    print(\"Testing Original Issue Scenario\")\n    print(\"=\" * 50)\n    \n    # Step 1: Create the simple compound model as in the issue\n    print(\"Step 1: cm = Linear1D(10) & Linear1D(5)\")\n    cm = Linear1D(10) & Linear1D(5)\n    \n    # Test its separability matrix\n    sep_matrix_cm = separability_matrix(cm)\n    print(\"separability_matrix(cm) =\")\n    print(sep_matrix_cm)\n    \n    expected_cm = np.array([[True, False], [False, True]])\n    print(\"Expected:\")\n    print(expected_cm)\n    \n    assert np.array_equal(sep_matrix_cm, expected_cm), \"Simple compound model failed\"\n    print(\"\u2713 Simple compound model is correct\\n\")\n    \n    # Step 2: Create the complex compound model (non-nested)\n    print(\"Step 2: Pix2Sky_TAN() & Linear1D(10) & Linear1D(5)\")\n    complex_model = Pix2Sky_TAN() & Linear1D(10) & Linear1D(5)\n    \n    sep_matrix_complex = separability_matrix(complex_model)\n    print(\"separability_matrix(complex_model) =\")\n    print(sep_matrix_complex)\n    \n    expected_complex = np.array([\n        [True, True, False, False],\n        [True, True, False, False],\n        [False, False, True, False],\n        [False, False, False, True]\n    ])\n    print(\"Expected:\")\n    print(expected_complex)\n    \n    assert np.array_equal(sep_matrix_complex, expected_complex), \"Complex compound model failed\"\n    print(\"\u2713 Complex compound model is correct\\n\")\n    \n    # Step 3: Create the nested compound model (the problematic case)\n    print(\"Step 3: Pix2Sky_TAN() & cm (nested compound model)\")\n    nested_model = Pix2Sky_TAN() & cm\n    \n    sep_matrix_nested = separability_matrix(nested_model)\n    print(\"separability_matrix(nested_model) =\")\n    print(sep_matrix_nested)\n    \n    # This should be the same as the complex model\n    expected_nested = expected_complex\n    print(\"Expected (should be same as complex model):\")\n    print(expected_nested)\n    \n    if np.array_equal(sep_matrix_nested, expected_nested):\n        print(\"\u2713 Nested compound model is correct - BUG IS FIXED!\")\n    else:\n        print(\"\u2717 Nested compound model is incorrect - BUG STILL EXISTS!\")\n        print(\"This was the original bug that needed to be fixed.\")\n        return False\n    \n    print(\"\\n\" + \"=\" * 50)\n    print(\"\ud83c\udf89 ORIGINAL ISSUE HAS BEEN RESOLVED!\")\n    print(\"The separability_matrix function now correctly handles nested CompoundModels.\")\n    print(\"=\" * 50)\n    \n    return True\n\nif __name__ == \"__main__\":\n    test_original_issue()"}, "action_id": "f0c83d15-7b5f-4ab5-8fb2-8cc9a2d9e08f"}