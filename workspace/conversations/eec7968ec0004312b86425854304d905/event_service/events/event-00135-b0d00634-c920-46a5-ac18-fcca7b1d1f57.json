{"kind": "ObservationEvent", "id": "b0d00634-c920-46a5-ac18-fcca7b1d1f57", "timestamp": "2025-09-25T11:28:21.039522", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_014S1si6UkC7Jg28i7geEDSc", "observation": {"kind": "StrReplaceEditorObservation", "command": "str_replace", "output": "The file /tmp/tmpfe5scn8o/astropy/astropy/wcs/wcsapi/wrappers/tests/test_sliced_wcs.py has been edited. Here's the result of running `cat -n` on a snippet of /tmp/tmpfe5scn8o/astropy/astropy/wcs/wcsapi/wrappers/tests/test_sliced_wcs.py:\n   892\t    assert wao_classes['time'][0:3] == (Time, (), {})\n   893\t\n   894\t\n   895\tdef test_pixel_to_world_values_different_int_types():\n   896\t    int_sliced = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, np.s_[:, 0, :])\n   897\t    np64_sliced = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, np.s_[:, np.int64(0), :])\n   898\t    pixel_arrays = ([0, 1], [0, 1])\n   899\t    for int_coord, np64_coord in zip(int_sliced.pixel_to_world_values(*pixel_arrays),\n   900\t                                     np64_sliced.pixel_to_world_values(*pixel_arrays)):\n   901\t        assert all(int_coord == np64_coord)\n   902\t\n   903\t\n   904\tdef test_world_to_pixel_with_coupled_dimensions():\n   905\t    \"\"\"\n   906\t    Test for issue where world_to_pixel returns incorrect results when\n   907\t    there are coupled dimensions in the PC matrix.\n   908\t    \n   909\t    This reproduces the issue described in astropy/astropy#13574 where\n   910\t    SlicedLowLevelWCS.world_to_pixel_values returns erroneous results\n   911\t    when the WCS has a non-trivial PC matrix that couples spectral and\n   912\t    spatial dimensions.\n   913\t    \"\"\"\n   914\t    # Create a 3D WCS with coupled dimensions similar to the issue report\n   915\t    nx, ny, nz = 100, 25, 2\n   916\t    wcs_header = {\n   917\t        'WCSAXES': 3,\n   918\t        'CRPIX1': (nx + 1)/2,\n   919\t        'CRPIX2': (ny + 1)/2,\n   920\t        'CRPIX3': 1.0,\n   921\t        'PC1_1': 0.0,\n   922\t        'PC1_2': -1.0,\n   923\t        'PC1_3': 0.0,\n   924\t        'PC2_1': 1.0,\n   925\t        'PC2_2': 0.0,\n   926\t        'PC2_3': -1.0,  # This couples spectral and spatial dimensions\n   927\t        'CDELT1': 5,\n   928\t        'CDELT2': 5,\n   929\t        'CDELT3': 0.055,\n   930\t        'CUNIT1': 'arcsec',\n   931\t        'CUNIT2': 'arcsec',\n   932\t        'CUNIT3': 'Angstrom',\n   933\t        'CTYPE1': 'HPLN-TAN',\n   934\t        'CTYPE2': 'HPLT-TAN',\n   935\t        'CTYPE3': 'WAVE',\n   936\t        'CRVAL1': 0.0,\n   937\t        'CRVAL2': 0.0,\n   938\t        'CRVAL3': 1.05,\n   939\t    }\n   940\t    \n   941\t    fits_wcs = WCS(header=wcs_header)\n   942\t    \n   943\t    # Test world_to_pixel on the unsliced WCS\n   944\t    result_unsliced = fits_wcs.world_to_pixel_values(0.0, 0.0, 1.05)\n   945\t    \n   946\t    # Create a sliced WCS (slice the first wavelength dimension)\n   947\t    ll_sliced_wcs = SlicedLowLevelWCS(fits_wcs, 0)\n   948\t    \n   949\t    # Test world_to_pixel on the sliced WCS\n   950\t    result_sliced = ll_sliced_wcs.world_to_pixel_values(0.0, 0.0)\n   951\t    \n   952\t    # The first two components of the unsliced result should match the sliced result\n   953\t    # This was failing before the fix due to using hardcoded 1.0 for dropped dimensions\n   954\t    assert_allclose(result_sliced[0], result_unsliced[0], rtol=1e-10)\n   955\t    assert_allclose(result_sliced[1], result_unsliced[1], rtol=1e-10)\n   956\t    \n   957\t    # Also test that the values are reasonable (not essentially infinite)\n   958\t    assert abs(result_sliced[0]) < 1e6, f\"First component should be reasonable, got {result_sliced[0]}\"\n   959\t    assert abs(result_sliced[1]) < 1e6, f\"Second component should be reasonable, got {result_sliced[1]}\"\n   960\t\nReview the changes and make sure they are as expected. Edit the file again if necessary.", "path": "/tmp/tmpfe5scn8o/astropy/astropy/wcs/wcsapi/wrappers/tests/test_sliced_wcs.py", "prev_exist": true, "old_content": "import warnings\n\nimport pytest\n\nimport numpy as np\nfrom numpy.testing import assert_equal, assert_allclose\nfrom astropy.wcs.wcs import WCS, FITSFixedWarning\nfrom astropy.time import Time\nfrom astropy.wcs import WCS\nfrom astropy.io.fits import Header\nfrom astropy.io.fits.verify import VerifyWarning\nfrom astropy.coordinates import SkyCoord, Galactic, ICRS\nfrom astropy.units import Quantity\nfrom astropy.wcs.wcsapi.wrappers.sliced_wcs import SlicedLowLevelWCS, sanitize_slices, combine_slices\nfrom astropy.wcs.wcsapi.utils import wcs_info_str\nimport astropy.units as u\n\nfrom astropy.coordinates.spectral_coordinate import SpectralCoord\n\n# To test the slicing we start off from standard FITS WCS\n# objects since those implement the low-level API. We create\n# a WCS for a spectral cube with axes in non-standard order\n# and with correlated celestial axes and an uncorrelated\n# spectral axis.\n\nHEADER_SPECTRAL_CUBE = \"\"\"\nNAXIS   = 3\nNAXIS1  = 10\nNAXIS2  = 20\nNAXIS3  = 30\nCTYPE1  = GLAT-CAR\nCTYPE2  = FREQ\nCTYPE3  = GLON-CAR\nCNAME1  = Latitude\nCNAME2  = Frequency\nCNAME3  = Longitude\nCRVAL1  = 10\nCRVAL2  = 20\nCRVAL3  = 25\nCRPIX1  = 30\nCRPIX2  = 40\nCRPIX3  = 45\nCDELT1  = -0.1\nCDELT2  =  0.5\nCDELT3  =  0.1\nCUNIT1  = deg\nCUNIT2  = Hz\nCUNIT3  = deg\n\"\"\"\n\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore', VerifyWarning)\n    WCS_SPECTRAL_CUBE = WCS(Header.fromstring(HEADER_SPECTRAL_CUBE, sep='\\n'))\nWCS_SPECTRAL_CUBE.pixel_bounds = [(-1, 11), (-2, 18), (5, 15)]\n\n\ndef test_invalid_slices():\n    with pytest.raises(IndexError):\n        SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [None, None, [False, False, False]])\n\n    with pytest.raises(IndexError):\n        SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [None, None, slice(None, None, 2)])\n\n    with pytest.raises(IndexError):\n        SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [None, None, 1000.100])\n\n\n@pytest.mark.parametrize(\"item, ndim, expected\", (\n    ([Ellipsis, 10], 4, [slice(None)] * 3 + [10]),\n    ([10, slice(20, 30)], 5, [10, slice(20, 30)] + [slice(None)] * 3),\n    ([10, Ellipsis, 8], 10, [10] + [slice(None)] * 8 + [8])\n))\ndef test_sanitize_slice(item, ndim, expected):\n    new_item = sanitize_slices(item, ndim)\n    # FIXME: do we still need the first two since the third assert\n    # should cover it all?\n    assert len(new_item) == ndim\n    assert all(isinstance(i, (slice, int)) for i in new_item)\n    assert new_item == expected\n\n\nEXPECTED_ELLIPSIS_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20, 10)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              10  (-1, 11)\n        1  None              20  (-2, 18)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_ellipsis():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, Ellipsis)\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20, 10)\n    assert wcs.pixel_shape == (10, 20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(29, 39, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39, 29), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (29., 39., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 39, 29))\n\n    assert_equal(wcs.pixel_bounds, [(-1, 11), (-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_ELLIPSIS_REPR.strip()\n    assert EXPECTED_ELLIPSIS_REPR.strip() in repr(wcs)\n\n\ndef test_pixel_to_world_broadcasting():\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, Ellipsis)\n\n    assert_allclose(wcs.pixel_to_world_values((29, 29), 39, 44), ((10, 10), (20, 20), (25, 25)))\n\n\ndef test_world_to_pixel_broadcasting():\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, Ellipsis)\n\n    assert_allclose(wcs.world_to_pixel_values((10, 10), 20, 25), ((29., 29.), (39., 39.), (44., 44.)))\n\n\nEXPECTED_SPECTRAL_SLICE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 2 pixel and 2 world dimensions\n\nArray shape (Numpy order): (30, 10)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              10  (-1, 11)\n        1  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n           Pixel Dim\nWorld Dim    0    1\n        0  yes  yes\n        1  yes  yes\n\"\"\"\n\n\ndef test_spectral_slice():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [slice(None), 10])\n\n    assert wcs.pixel_n_dim == 2\n    assert wcs.world_n_dim == 2\n    assert wcs.array_shape == (30, 10)\n    assert wcs.pixel_shape == (10, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'deg']\n    assert wcs.pixel_axis_names == ['', '']\n    assert wcs.world_axis_names == ['Latitude', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, True], [True, True]])\n\n    assert wcs.world_axis_object_components == [('celestial', 1, 'spherical.lat.degree'),\n                                                ('celestial', 0, 'spherical.lon.degree')]\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert_allclose(wcs.pixel_to_world_values(29, 44), (10, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 29), (10, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 25), (29., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 25), (44, 29))\n\n    assert_equal(wcs.pixel_bounds, [(-1, 11), (5, 15)])\n\n    assert str(wcs) == EXPECTED_SPECTRAL_SLICE_REPR.strip()\n    assert EXPECTED_SPECTRAL_SLICE_REPR.strip() in repr(wcs)\n\n\nEXPECTED_SPECTRAL_RANGE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 6, 10)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              10  (-1, 11)\n        1  None               6  (-6, 14)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_spectral_range():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [slice(None), slice(4, 10)])\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 6, 10)\n    assert wcs.pixel_shape == (10, 6, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(29, 35, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 35, 29), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (29., 35., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 35, 29))\n\n    assert_equal(wcs.pixel_bounds, [(-1, 11), (-6, 14), (5, 15)])\n\n    assert str(wcs) == EXPECTED_SPECTRAL_RANGE_REPR.strip()\n    assert EXPECTED_SPECTRAL_RANGE_REPR.strip() in repr(wcs)\n\n\nEXPECTED_CELESTIAL_SLICE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 2 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              20  (-2, 18)\n        1  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n           Pixel Dim\nWorld Dim    0    1\n        0   no  yes\n        1  yes   no\n        2   no  yes\n\"\"\"\n\n\ndef test_celestial_slice():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [Ellipsis, 5])\n\n    assert wcs.pixel_n_dim == 2\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20)\n    assert wcs.pixel_shape == (20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[False, True], [True, False], [False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(39, 44), (12.4, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39), (12.4, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(12.4, 20, 25), (39., 44.))\n    assert_equal(wcs.world_to_array_index_values(12.4, 20, 25), (44, 39))\n\n    assert_equal(wcs.pixel_bounds, [(-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_CELESTIAL_SLICE_REPR.strip()\n    assert EXPECTED_CELESTIAL_SLICE_REPR.strip() in repr(wcs)\n\n\nEXPECTED_CELESTIAL_RANGE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20, 5)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None               5  (-6, 6)\n        1  None              20  (-2, 18)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_celestial_range():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [Ellipsis, slice(5, 10)])\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20, 5)\n    assert wcs.pixel_shape == (5, 20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(24, 39, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39, 24), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (24., 39., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 39, 24))\n\n    assert_equal(wcs.pixel_bounds, [(-6, 6), (-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_CELESTIAL_RANGE_REPR.strip()\n    assert EXPECTED_CELESTIAL_RANGE_REPR.strip() in repr(wcs)\n\n\n# Now try with a 90 degree rotation\n\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore', VerifyWarning)\n    WCS_SPECTRAL_CUBE_ROT = WCS(Header.fromstring(\n        HEADER_SPECTRAL_CUBE, sep='\\n'))\nWCS_SPECTRAL_CUBE_ROT.wcs.pc = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\nWCS_SPECTRAL_CUBE_ROT.wcs.crval[0] = 0\nWCS_SPECTRAL_CUBE_ROT.pixel_bounds = [(-1, 11), (-2, 18), (5, 15)]\n\nEXPECTED_CELESTIAL_RANGE_ROT_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20, 5)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None               5  (-6, 6)\n        1  None              20  (-2, 18)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_celestial_range_rot():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE_ROT, [Ellipsis, slice(5, 10)])\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20, 5)\n    assert wcs.pixel_shape == (5, 20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(14, 29, 34), (1, 15, 24))\n    assert_allclose(wcs.array_index_to_world_values(34, 29, 14), (1, 15, 24))\n\n    assert_allclose(wcs.world_to_pixel_values(1, 15, 24), (14., 29., 34.))\n    assert_equal(wcs.world_to_array_index_values(1, 15, 24), (34, 29, 14))\n\n    assert_equal(wcs.pixel_bounds, [(-6, 6), (-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_CELESTIAL_RANGE_ROT_REPR.strip()\n    assert EXPECTED_CELESTIAL_RANGE_ROT_REPR.strip() in repr(wcs)\n\n\nHEADER_NO_SHAPE_CUBE = \"\"\"\nNAXIS   = 3\nCTYPE1  = GLAT-CAR\nCTYPE2  = FREQ\nCTYPE3  = GLON-CAR\nCRVAL1  = 10\nCRVAL2  = 20\nCRVAL3  = 25\nCRPIX1  = 30\nCRPIX2  = 40\nCRPIX3  = 45\nCDELT1  = -0.1\nCDELT2  =  0.5\nCDELT3  =  0.1\nCUNIT1  = deg\nCUNIT2  = Hz\nCUNIT3  = deg\n\"\"\"\n\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore', VerifyWarning)\n    WCS_NO_SHAPE_CUBE = WCS(Header.fromstring(HEADER_NO_SHAPE_CUBE, sep='\\n'))\n\nEXPECTED_NO_SHAPE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): None\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None            None  None\n        1  None            None  None\n        2  None            None  None\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  None       pos.galactic.lat  deg\n        1  None       em.freq           Hz\n        2  None       pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_no_array_shape():\n\n    wcs = SlicedLowLevelWCS(WCS_NO_SHAPE_CUBE, Ellipsis)\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape is None\n    assert wcs.pixel_shape is None\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(29, 39, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39, 29), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (29., 39., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 39, 29))\n\n    assert str(wcs) == EXPECTED_NO_SHAPE_REPR.strip()\n    assert EXPECTED_NO_SHAPE_REPR.strip() in repr(wcs)\n\n\n# Testing the WCS object having some physical types as None/Unknown\nHEADER_SPECTRAL_CUBE_NONE_TYPES = {\n        'CTYPE1': 'GLAT-CAR',\n        'CUNIT1': 'deg',\n        'CDELT1': -0.1,\n        'CRPIX1': 30,\n        'CRVAL1': 10,\n        'NAXIS1': 10,\n        'CTYPE2': '',\n        'CUNIT2': 'Hz',\n        'CDELT2':  0.5,\n        'CRPIX2': 40,\n        'CRVAL2': 20,\n        'NAXIS2': 20,\n        'CTYPE3': 'GLON-CAR',\n        'CUNIT3': 'deg',\n        'CDELT3':  0.1,\n        'CRPIX3': 45,\n        'CRVAL3': 25,\n        'NAXIS3': 30\n}\n\nWCS_SPECTRAL_CUBE_NONE_TYPES = WCS(header=HEADER_SPECTRAL_CUBE_NONE_TYPES)\nWCS_SPECTRAL_CUBE_NONE_TYPES.pixel_bounds = [(-1, 11), (-2, 18), (5, 15)]\n\n\nEXPECTED_ELLIPSIS_REPR_NONE_TYPES = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20, 10)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              10  (-1, 11)\n        1  None              20  (-2, 18)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  None       pos.galactic.lat  deg\n        1  None       None              Hz\n        2  None       pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_ellipsis_none_types():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE_NONE_TYPES, Ellipsis)\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20, 10)\n    assert wcs.pixel_shape == (10, 20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', None, 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True],\n                                               [False, True, False], [True, False, True]])\n\n    assert wcs.world_axis_object_components == [('celestial', 1, 'spherical.lat.degree'),\n                                                  ('world', 0, 'value'),\n                                                  ('celestial', 0, 'spherical.lon.degree')]\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert_allclose(wcs.pixel_to_world_values(29, 39, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39, 29), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (29., 39., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 39, 29))\n\n    assert_equal(wcs.pixel_bounds, [(-1, 11), (-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_ELLIPSIS_REPR_NONE_TYPES.strip()\n    assert EXPECTED_ELLIPSIS_REPR_NONE_TYPES.strip() in repr(wcs)\n\n\nCASES = [(slice(None), slice(None), slice(None)),\n         (slice(None), slice(3, None), slice(3, None)),\n         (slice(None), slice(None, 16), slice(None, 16)),\n         (slice(None), slice(3, 16), slice(3, 16)),\n         (slice(2, None), slice(None), slice(2, None)),\n         (slice(2, None), slice(3, None), slice(5, None)),\n         (slice(2, None), slice(None, 16), slice(2, 18)),\n         (slice(2, None), slice(3, 16), slice(5, 18)),\n         (slice(None, 10), slice(None), slice(None, 10)),\n         (slice(None, 10), slice(3, None), slice(3, 10)),\n         (slice(None, 10), slice(None, 16), slice(None, 10)),\n         (slice(None, 10), slice(3, 16), slice(3, 10)),\n         (slice(2, 10), slice(None), slice(2, 10)),\n         (slice(2, 10), slice(3, None), slice(5, 10)),\n         (slice(2, 10), slice(None, 16), slice(2, 10)),\n         (slice(2, 10), slice(3, 16), slice(5, 10)),\n         (slice(None), 3, 3),\n         (slice(2, None), 3, 5),\n         (slice(None, 10), 3, 3),\n         (slice(2, 10), 3, 5)]\n\n\n@pytest.mark.parametrize(('slice1', 'slice2', 'expected'), CASES)\ndef test_combine_slices(slice1, slice2, expected):\n    assert combine_slices(slice1, slice2) == expected\n\n\ndef test_nested_slicing():\n    # Make sure that if we call slicing several times, the result is the same\n    # as calling the slicing once with the final slice settings.\n    wcs = WCS_SPECTRAL_CUBE\n    sub1 = SlicedLowLevelWCS(\n                SlicedLowLevelWCS(\n                    SlicedLowLevelWCS(wcs, [slice(None), slice(1, 10), slice(None)]),\n                    [3, slice(2, None)]),\n                [slice(None), slice(2, 8)])\n    sub2 = wcs[3, 3:10, 2:8]\n    assert_allclose(sub1.pixel_to_world_values(3, 5),\n                    sub2.pixel_to_world_values(3, 5))\n    assert not isinstance(sub1._wcs, SlicedLowLevelWCS)\n\n\ndef test_too_much_slicing():\n    wcs = WCS_SPECTRAL_CUBE\n    with pytest.raises(ValueError, match='Cannot slice WCS: the resulting WCS '\n                                         'should have at least one pixel and '\n                                         'one world dimension'):\n        wcs[0, 1, 2]\n\n\nHEADER_TIME_1D = \"\"\"\nSIMPLE  = T\nBITPIX  = -32\nNAXIS   = 1\nNAXIS1  = 2048\nTIMESYS = 'UTC'\nTREFPOS = 'TOPOCENT'\nMJDREF  = 50002.6\nCTYPE1  = 'UTC'\nCRVAL1  = 5\nCUNIT1  = 's'\nCRPIX1  = 1.0\nCDELT1  = 2\nOBSGEO-L= -20\nOBSGEO-B= -70\nOBSGEO-H= 2530\n\"\"\"\n\n\n@pytest.fixture\ndef header_time_1d():\n    return Header.fromstring(HEADER_TIME_1D, sep='\\n')\n\n\n@pytest.fixture\ndef time_1d_wcs(header_time_1d):\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', FITSFixedWarning)\n        return WCS(header_time_1d)\n\n\ndef test_1d_sliced_low_level(time_1d_wcs):\n    sll = SlicedLowLevelWCS(time_1d_wcs, np.s_[10:20])\n    world = sll.pixel_to_world_values([1, 2])\n    assert isinstance(world, np.ndarray)\n    assert np.allclose(world, [27, 29])\n\n\ndef validate_info_dict(result, expected):\n    result_value = result.pop(\"value\")\n    expected_value = expected.pop(\"value\")\n\n    np.testing.assert_allclose(result_value, expected_value)\n    assert result == expected\n\n\ndef test_dropped_dimensions():\n    wcs = WCS_SPECTRAL_CUBE\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[:, :, :])\n\n    assert sub.dropped_world_dimensions == {}\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[:, 2:5, :])\n\n    assert sub.dropped_world_dimensions == {}\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[:, 0])\n\n    waocomp =sub.dropped_world_dimensions.pop(\"world_axis_object_components\")\n    assert len(waocomp) == 1 and waocomp[0][0] == \"spectral\" and waocomp[0][1] == 0\n    waocls = sub.dropped_world_dimensions.pop(\"world_axis_object_classes\")\n    assert len(waocls) == 1 and \"spectral\" in waocls and waocls[\"spectral\"][0] == u.Quantity\n    validate_info_dict(sub.dropped_world_dimensions, {\n        \"value\": [0.5],\n        \"world_axis_physical_types\": [\"em.freq\"],\n        \"world_axis_names\": [\"Frequency\"],\n        \"world_axis_units\": [\"Hz\"],\n        \"serialized_classes\": False,\n        })\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[:, 0, 0])\n\n    waocomp =sub.dropped_world_dimensions.pop(\"world_axis_object_components\")\n    assert len(waocomp) == 1 and waocomp[0][0] == \"spectral\" and waocomp[0][1] == 0\n    waocls = sub.dropped_world_dimensions.pop(\"world_axis_object_classes\")\n    assert len(waocls) == 1 and \"spectral\" in waocls and waocls[\"spectral\"][0] == u.Quantity\n    validate_info_dict(sub.dropped_world_dimensions, {\n        \"value\": [0.5],\n        \"world_axis_physical_types\": [\"em.freq\"],\n        \"world_axis_names\": [\"Frequency\"],\n        \"world_axis_units\": [\"Hz\"],\n        \"serialized_classes\": False,\n        })\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[0, :, 0])\n\n    dwd = sub.dropped_world_dimensions\n    wao_classes = dwd.pop(\"world_axis_object_classes\")\n    validate_info_dict(dwd, {\n        \"value\": [12.86995801, 20.49217541],\n        \"world_axis_physical_types\": [\"pos.galactic.lat\", \"pos.galactic.lon\"],\n        \"world_axis_names\": [\"Latitude\", \"Longitude\"],\n        \"world_axis_units\": [\"deg\", \"deg\"],\n        \"serialized_classes\": False,\n        \"world_axis_object_components\": [('celestial', 1, 'spherical.lat.degree'), ('celestial', 0, 'spherical.lon.degree')],\n        })\n\n    assert wao_classes['celestial'][0] is SkyCoord\n    assert wao_classes['celestial'][1] == ()\n    assert isinstance(wao_classes['celestial'][2]['frame'], Galactic)\n    assert wao_classes['celestial'][2]['unit'] is u.deg\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[5, :5, 12])\n\n    dwd = sub.dropped_world_dimensions\n    wao_classes = dwd.pop(\"world_axis_object_classes\")\n    validate_info_dict(dwd, {\n        \"value\": [11.67648267, 21.01921192],\n        \"world_axis_physical_types\": [\"pos.galactic.lat\", \"pos.galactic.lon\"],\n        \"world_axis_names\": [\"Latitude\", \"Longitude\"],\n        \"world_axis_units\": [\"deg\", \"deg\"],\n        \"serialized_classes\": False,\n        \"world_axis_object_components\": [('celestial', 1, 'spherical.lat.degree'), ('celestial', 0, 'spherical.lon.degree')],\n        })\n\n    assert wao_classes['celestial'][0] is SkyCoord\n    assert wao_classes['celestial'][1] == ()\n    assert isinstance(wao_classes['celestial'][2]['frame'], Galactic)\n    assert wao_classes['celestial'][2]['unit'] is u.deg\n\n\ndef test_dropped_dimensions_4d(cube_4d_fitswcs):\n\n    sub = SlicedLowLevelWCS(cube_4d_fitswcs, np.s_[:, 12, 5, 5])\n\n    dwd = sub.dropped_world_dimensions\n    wao_classes = dwd.pop(\"world_axis_object_classes\")\n    wao_components = dwd.pop(\"world_axis_object_components\")\n\n    validate_info_dict(dwd, {\n        \"value\": [4.e+00, -2.e+00,  1.e+10],\n        \"world_axis_physical_types\": [\"pos.eq.ra\", \"pos.eq.dec\", \"em.freq\"],\n        \"world_axis_names\": ['Right Ascension', 'Declination', 'Frequency'],\n        \"world_axis_units\": [\"deg\", \"deg\", \"Hz\"],\n        \"serialized_classes\": False,\n        })\n\n    assert wao_classes['celestial'][0] is SkyCoord\n    assert wao_classes['celestial'][1] == ()\n    assert isinstance(wao_classes['celestial'][2]['frame'], ICRS)\n    assert wao_classes['celestial'][2]['unit'] is u.deg\n    assert wao_classes['spectral'][0:3] == (u.Quantity, (), {})\n\n    assert wao_components[0] == ('celestial', 0, 'spherical.lon.degree')\n    assert wao_components[1] == ('celestial', 1, 'spherical.lat.degree')\n    assert wao_components[2][0:2] == ('spectral', 0)\n\n    sub = SlicedLowLevelWCS(cube_4d_fitswcs, np.s_[12, 12])\n\n    dwd = sub.dropped_world_dimensions\n    wao_classes = dwd.pop(\"world_axis_object_classes\")\n    wao_components = dwd.pop(\"world_axis_object_components\")\n    validate_info_dict(dwd, {\n        \"value\": [1.e+10, 5.e+00],\n        \"world_axis_physical_types\": [\"em.freq\", \"time\"],\n        \"world_axis_names\": [\"Frequency\", \"Time\"],\n        \"world_axis_units\": [\"Hz\", \"s\"],\n        \"serialized_classes\": False,\n        })\n    assert wao_components[0][0:2] == ('spectral', 0)\n    assert wao_components[1][0] == 'time'\n    assert wao_components[1][1] == 0\n\n    assert wao_classes['spectral'][0:3] == (u.Quantity, (), {})\n    assert wao_classes['time'][0:3] == (Time, (), {})\n\n\ndef test_pixel_to_world_values_different_int_types():\n    int_sliced = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, np.s_[:, 0, :])\n    np64_sliced = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, np.s_[:, np.int64(0), :])\n    pixel_arrays = ([0, 1], [0, 1])\n    for int_coord, np64_coord in zip(int_sliced.pixel_to_world_values(*pixel_arrays),\n                                     np64_sliced.pixel_to_world_values(*pixel_arrays)):\n        assert all(int_coord == np64_coord)\n", "new_content": "import warnings\n\nimport pytest\n\nimport numpy as np\nfrom numpy.testing import assert_equal, assert_allclose\nfrom astropy.wcs.wcs import WCS, FITSFixedWarning\nfrom astropy.time import Time\nfrom astropy.wcs import WCS\nfrom astropy.io.fits import Header\nfrom astropy.io.fits.verify import VerifyWarning\nfrom astropy.coordinates import SkyCoord, Galactic, ICRS\nfrom astropy.units import Quantity\nfrom astropy.wcs.wcsapi.wrappers.sliced_wcs import SlicedLowLevelWCS, sanitize_slices, combine_slices\nfrom astropy.wcs.wcsapi.utils import wcs_info_str\nimport astropy.units as u\n\nfrom astropy.coordinates.spectral_coordinate import SpectralCoord\n\n# To test the slicing we start off from standard FITS WCS\n# objects since those implement the low-level API. We create\n# a WCS for a spectral cube with axes in non-standard order\n# and with correlated celestial axes and an uncorrelated\n# spectral axis.\n\nHEADER_SPECTRAL_CUBE = \"\"\"\nNAXIS   = 3\nNAXIS1  = 10\nNAXIS2  = 20\nNAXIS3  = 30\nCTYPE1  = GLAT-CAR\nCTYPE2  = FREQ\nCTYPE3  = GLON-CAR\nCNAME1  = Latitude\nCNAME2  = Frequency\nCNAME3  = Longitude\nCRVAL1  = 10\nCRVAL2  = 20\nCRVAL3  = 25\nCRPIX1  = 30\nCRPIX2  = 40\nCRPIX3  = 45\nCDELT1  = -0.1\nCDELT2  =  0.5\nCDELT3  =  0.1\nCUNIT1  = deg\nCUNIT2  = Hz\nCUNIT3  = deg\n\"\"\"\n\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore', VerifyWarning)\n    WCS_SPECTRAL_CUBE = WCS(Header.fromstring(HEADER_SPECTRAL_CUBE, sep='\\n'))\nWCS_SPECTRAL_CUBE.pixel_bounds = [(-1, 11), (-2, 18), (5, 15)]\n\n\ndef test_invalid_slices():\n    with pytest.raises(IndexError):\n        SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [None, None, [False, False, False]])\n\n    with pytest.raises(IndexError):\n        SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [None, None, slice(None, None, 2)])\n\n    with pytest.raises(IndexError):\n        SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [None, None, 1000.100])\n\n\n@pytest.mark.parametrize(\"item, ndim, expected\", (\n    ([Ellipsis, 10], 4, [slice(None)] * 3 + [10]),\n    ([10, slice(20, 30)], 5, [10, slice(20, 30)] + [slice(None)] * 3),\n    ([10, Ellipsis, 8], 10, [10] + [slice(None)] * 8 + [8])\n))\ndef test_sanitize_slice(item, ndim, expected):\n    new_item = sanitize_slices(item, ndim)\n    # FIXME: do we still need the first two since the third assert\n    # should cover it all?\n    assert len(new_item) == ndim\n    assert all(isinstance(i, (slice, int)) for i in new_item)\n    assert new_item == expected\n\n\nEXPECTED_ELLIPSIS_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20, 10)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              10  (-1, 11)\n        1  None              20  (-2, 18)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_ellipsis():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, Ellipsis)\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20, 10)\n    assert wcs.pixel_shape == (10, 20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(29, 39, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39, 29), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (29., 39., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 39, 29))\n\n    assert_equal(wcs.pixel_bounds, [(-1, 11), (-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_ELLIPSIS_REPR.strip()\n    assert EXPECTED_ELLIPSIS_REPR.strip() in repr(wcs)\n\n\ndef test_pixel_to_world_broadcasting():\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, Ellipsis)\n\n    assert_allclose(wcs.pixel_to_world_values((29, 29), 39, 44), ((10, 10), (20, 20), (25, 25)))\n\n\ndef test_world_to_pixel_broadcasting():\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, Ellipsis)\n\n    assert_allclose(wcs.world_to_pixel_values((10, 10), 20, 25), ((29., 29.), (39., 39.), (44., 44.)))\n\n\nEXPECTED_SPECTRAL_SLICE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 2 pixel and 2 world dimensions\n\nArray shape (Numpy order): (30, 10)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              10  (-1, 11)\n        1  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n           Pixel Dim\nWorld Dim    0    1\n        0  yes  yes\n        1  yes  yes\n\"\"\"\n\n\ndef test_spectral_slice():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [slice(None), 10])\n\n    assert wcs.pixel_n_dim == 2\n    assert wcs.world_n_dim == 2\n    assert wcs.array_shape == (30, 10)\n    assert wcs.pixel_shape == (10, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'deg']\n    assert wcs.pixel_axis_names == ['', '']\n    assert wcs.world_axis_names == ['Latitude', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, True], [True, True]])\n\n    assert wcs.world_axis_object_components == [('celestial', 1, 'spherical.lat.degree'),\n                                                ('celestial', 0, 'spherical.lon.degree')]\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert_allclose(wcs.pixel_to_world_values(29, 44), (10, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 29), (10, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 25), (29., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 25), (44, 29))\n\n    assert_equal(wcs.pixel_bounds, [(-1, 11), (5, 15)])\n\n    assert str(wcs) == EXPECTED_SPECTRAL_SLICE_REPR.strip()\n    assert EXPECTED_SPECTRAL_SLICE_REPR.strip() in repr(wcs)\n\n\nEXPECTED_SPECTRAL_RANGE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 6, 10)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              10  (-1, 11)\n        1  None               6  (-6, 14)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_spectral_range():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [slice(None), slice(4, 10)])\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 6, 10)\n    assert wcs.pixel_shape == (10, 6, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(29, 35, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 35, 29), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (29., 35., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 35, 29))\n\n    assert_equal(wcs.pixel_bounds, [(-1, 11), (-6, 14), (5, 15)])\n\n    assert str(wcs) == EXPECTED_SPECTRAL_RANGE_REPR.strip()\n    assert EXPECTED_SPECTRAL_RANGE_REPR.strip() in repr(wcs)\n\n\nEXPECTED_CELESTIAL_SLICE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 2 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              20  (-2, 18)\n        1  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n           Pixel Dim\nWorld Dim    0    1\n        0   no  yes\n        1  yes   no\n        2   no  yes\n\"\"\"\n\n\ndef test_celestial_slice():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [Ellipsis, 5])\n\n    assert wcs.pixel_n_dim == 2\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20)\n    assert wcs.pixel_shape == (20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[False, True], [True, False], [False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(39, 44), (12.4, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39), (12.4, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(12.4, 20, 25), (39., 44.))\n    assert_equal(wcs.world_to_array_index_values(12.4, 20, 25), (44, 39))\n\n    assert_equal(wcs.pixel_bounds, [(-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_CELESTIAL_SLICE_REPR.strip()\n    assert EXPECTED_CELESTIAL_SLICE_REPR.strip() in repr(wcs)\n\n\nEXPECTED_CELESTIAL_RANGE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20, 5)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None               5  (-6, 6)\n        1  None              20  (-2, 18)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_celestial_range():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, [Ellipsis, slice(5, 10)])\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20, 5)\n    assert wcs.pixel_shape == (5, 20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(24, 39, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39, 24), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (24., 39., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 39, 24))\n\n    assert_equal(wcs.pixel_bounds, [(-6, 6), (-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_CELESTIAL_RANGE_REPR.strip()\n    assert EXPECTED_CELESTIAL_RANGE_REPR.strip() in repr(wcs)\n\n\n# Now try with a 90 degree rotation\n\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore', VerifyWarning)\n    WCS_SPECTRAL_CUBE_ROT = WCS(Header.fromstring(\n        HEADER_SPECTRAL_CUBE, sep='\\n'))\nWCS_SPECTRAL_CUBE_ROT.wcs.pc = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\nWCS_SPECTRAL_CUBE_ROT.wcs.crval[0] = 0\nWCS_SPECTRAL_CUBE_ROT.pixel_bounds = [(-1, 11), (-2, 18), (5, 15)]\n\nEXPECTED_CELESTIAL_RANGE_ROT_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20, 5)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None               5  (-6, 6)\n        1  None              20  (-2, 18)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  Latitude   pos.galactic.lat  deg\n        1  Frequency  em.freq           Hz\n        2  Longitude  pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_celestial_range_rot():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE_ROT, [Ellipsis, slice(5, 10)])\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20, 5)\n    assert wcs.pixel_shape == (5, 20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n    assert wcs.pixel_axis_names == ['', '', '']\n    assert wcs.world_axis_names == ['Latitude', 'Frequency', 'Longitude']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(14, 29, 34), (1, 15, 24))\n    assert_allclose(wcs.array_index_to_world_values(34, 29, 14), (1, 15, 24))\n\n    assert_allclose(wcs.world_to_pixel_values(1, 15, 24), (14., 29., 34.))\n    assert_equal(wcs.world_to_array_index_values(1, 15, 24), (34, 29, 14))\n\n    assert_equal(wcs.pixel_bounds, [(-6, 6), (-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_CELESTIAL_RANGE_ROT_REPR.strip()\n    assert EXPECTED_CELESTIAL_RANGE_ROT_REPR.strip() in repr(wcs)\n\n\nHEADER_NO_SHAPE_CUBE = \"\"\"\nNAXIS   = 3\nCTYPE1  = GLAT-CAR\nCTYPE2  = FREQ\nCTYPE3  = GLON-CAR\nCRVAL1  = 10\nCRVAL2  = 20\nCRVAL3  = 25\nCRPIX1  = 30\nCRPIX2  = 40\nCRPIX3  = 45\nCDELT1  = -0.1\nCDELT2  =  0.5\nCDELT3  =  0.1\nCUNIT1  = deg\nCUNIT2  = Hz\nCUNIT3  = deg\n\"\"\"\n\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore', VerifyWarning)\n    WCS_NO_SHAPE_CUBE = WCS(Header.fromstring(HEADER_NO_SHAPE_CUBE, sep='\\n'))\n\nEXPECTED_NO_SHAPE_REPR = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): None\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None            None  None\n        1  None            None  None\n        2  None            None  None\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  None       pos.galactic.lat  deg\n        1  None       em.freq           Hz\n        2  None       pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_no_array_shape():\n\n    wcs = SlicedLowLevelWCS(WCS_NO_SHAPE_CUBE, Ellipsis)\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape is None\n    assert wcs.pixel_shape is None\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', 'em.freq', 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True], [False, True, False], [True, False, True]])\n\n    assert len(wcs.world_axis_object_components) == 3\n    assert wcs.world_axis_object_components[0] == ('celestial', 1, 'spherical.lat.degree')\n    assert wcs.world_axis_object_components[1][:2] == ('spectral', 0)\n    assert wcs.world_axis_object_components[2] == ('celestial', 0, 'spherical.lon.degree')\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert wcs.world_axis_object_classes['spectral'][0] is Quantity\n    assert wcs.world_axis_object_classes['spectral'][1] == ()\n    assert wcs.world_axis_object_classes['spectral'][2] == {}\n\n    assert_allclose(wcs.pixel_to_world_values(29, 39, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39, 29), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (29., 39., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 39, 29))\n\n    assert str(wcs) == EXPECTED_NO_SHAPE_REPR.strip()\n    assert EXPECTED_NO_SHAPE_REPR.strip() in repr(wcs)\n\n\n# Testing the WCS object having some physical types as None/Unknown\nHEADER_SPECTRAL_CUBE_NONE_TYPES = {\n        'CTYPE1': 'GLAT-CAR',\n        'CUNIT1': 'deg',\n        'CDELT1': -0.1,\n        'CRPIX1': 30,\n        'CRVAL1': 10,\n        'NAXIS1': 10,\n        'CTYPE2': '',\n        'CUNIT2': 'Hz',\n        'CDELT2':  0.5,\n        'CRPIX2': 40,\n        'CRVAL2': 20,\n        'NAXIS2': 20,\n        'CTYPE3': 'GLON-CAR',\n        'CUNIT3': 'deg',\n        'CDELT3':  0.1,\n        'CRPIX3': 45,\n        'CRVAL3': 25,\n        'NAXIS3': 30\n}\n\nWCS_SPECTRAL_CUBE_NONE_TYPES = WCS(header=HEADER_SPECTRAL_CUBE_NONE_TYPES)\nWCS_SPECTRAL_CUBE_NONE_TYPES.pixel_bounds = [(-1, 11), (-2, 18), (5, 15)]\n\n\nEXPECTED_ELLIPSIS_REPR_NONE_TYPES = \"\"\"\nSlicedLowLevelWCS Transformation\n\nThis transformation has 3 pixel and 3 world dimensions\n\nArray shape (Numpy order): (30, 20, 10)\n\nPixel Dim  Axis Name  Data size  Bounds\n        0  None              10  (-1, 11)\n        1  None              20  (-2, 18)\n        2  None              30  (5, 15)\n\nWorld Dim  Axis Name  Physical Type     Units\n        0  None       pos.galactic.lat  deg\n        1  None       None              Hz\n        2  None       pos.galactic.lon  deg\n\nCorrelation between pixel and world axes:\n\n             Pixel Dim\nWorld Dim    0    1    2\n        0  yes   no  yes\n        1   no  yes   no\n        2  yes   no  yes\n\"\"\"\n\n\ndef test_ellipsis_none_types():\n\n    wcs = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE_NONE_TYPES, Ellipsis)\n\n    assert wcs.pixel_n_dim == 3\n    assert wcs.world_n_dim == 3\n    assert wcs.array_shape == (30, 20, 10)\n    assert wcs.pixel_shape == (10, 20, 30)\n    assert wcs.world_axis_physical_types == ['pos.galactic.lat', None, 'pos.galactic.lon']\n    assert wcs.world_axis_units == ['deg', 'Hz', 'deg']\n\n    assert_equal(wcs.axis_correlation_matrix, [[True, False, True],\n                                               [False, True, False], [True, False, True]])\n\n    assert wcs.world_axis_object_components == [('celestial', 1, 'spherical.lat.degree'),\n                                                  ('world', 0, 'value'),\n                                                  ('celestial', 0, 'spherical.lon.degree')]\n\n    assert wcs.world_axis_object_classes['celestial'][0] is SkyCoord\n    assert wcs.world_axis_object_classes['celestial'][1] == ()\n    assert isinstance(wcs.world_axis_object_classes['celestial'][2]['frame'], Galactic)\n    assert wcs.world_axis_object_classes['celestial'][2]['unit'] is u.deg\n\n    assert_allclose(wcs.pixel_to_world_values(29, 39, 44), (10, 20, 25))\n    assert_allclose(wcs.array_index_to_world_values(44, 39, 29), (10, 20, 25))\n\n    assert_allclose(wcs.world_to_pixel_values(10, 20, 25), (29., 39., 44.))\n    assert_equal(wcs.world_to_array_index_values(10, 20, 25), (44, 39, 29))\n\n    assert_equal(wcs.pixel_bounds, [(-1, 11), (-2, 18), (5, 15)])\n\n    assert str(wcs) == EXPECTED_ELLIPSIS_REPR_NONE_TYPES.strip()\n    assert EXPECTED_ELLIPSIS_REPR_NONE_TYPES.strip() in repr(wcs)\n\n\nCASES = [(slice(None), slice(None), slice(None)),\n         (slice(None), slice(3, None), slice(3, None)),\n         (slice(None), slice(None, 16), slice(None, 16)),\n         (slice(None), slice(3, 16), slice(3, 16)),\n         (slice(2, None), slice(None), slice(2, None)),\n         (slice(2, None), slice(3, None), slice(5, None)),\n         (slice(2, None), slice(None, 16), slice(2, 18)),\n         (slice(2, None), slice(3, 16), slice(5, 18)),\n         (slice(None, 10), slice(None), slice(None, 10)),\n         (slice(None, 10), slice(3, None), slice(3, 10)),\n         (slice(None, 10), slice(None, 16), slice(None, 10)),\n         (slice(None, 10), slice(3, 16), slice(3, 10)),\n         (slice(2, 10), slice(None), slice(2, 10)),\n         (slice(2, 10), slice(3, None), slice(5, 10)),\n         (slice(2, 10), slice(None, 16), slice(2, 10)),\n         (slice(2, 10), slice(3, 16), slice(5, 10)),\n         (slice(None), 3, 3),\n         (slice(2, None), 3, 5),\n         (slice(None, 10), 3, 3),\n         (slice(2, 10), 3, 5)]\n\n\n@pytest.mark.parametrize(('slice1', 'slice2', 'expected'), CASES)\ndef test_combine_slices(slice1, slice2, expected):\n    assert combine_slices(slice1, slice2) == expected\n\n\ndef test_nested_slicing():\n    # Make sure that if we call slicing several times, the result is the same\n    # as calling the slicing once with the final slice settings.\n    wcs = WCS_SPECTRAL_CUBE\n    sub1 = SlicedLowLevelWCS(\n                SlicedLowLevelWCS(\n                    SlicedLowLevelWCS(wcs, [slice(None), slice(1, 10), slice(None)]),\n                    [3, slice(2, None)]),\n                [slice(None), slice(2, 8)])\n    sub2 = wcs[3, 3:10, 2:8]\n    assert_allclose(sub1.pixel_to_world_values(3, 5),\n                    sub2.pixel_to_world_values(3, 5))\n    assert not isinstance(sub1._wcs, SlicedLowLevelWCS)\n\n\ndef test_too_much_slicing():\n    wcs = WCS_SPECTRAL_CUBE\n    with pytest.raises(ValueError, match='Cannot slice WCS: the resulting WCS '\n                                         'should have at least one pixel and '\n                                         'one world dimension'):\n        wcs[0, 1, 2]\n\n\nHEADER_TIME_1D = \"\"\"\nSIMPLE  = T\nBITPIX  = -32\nNAXIS   = 1\nNAXIS1  = 2048\nTIMESYS = 'UTC'\nTREFPOS = 'TOPOCENT'\nMJDREF  = 50002.6\nCTYPE1  = 'UTC'\nCRVAL1  = 5\nCUNIT1  = 's'\nCRPIX1  = 1.0\nCDELT1  = 2\nOBSGEO-L= -20\nOBSGEO-B= -70\nOBSGEO-H= 2530\n\"\"\"\n\n\n@pytest.fixture\ndef header_time_1d():\n    return Header.fromstring(HEADER_TIME_1D, sep='\\n')\n\n\n@pytest.fixture\ndef time_1d_wcs(header_time_1d):\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', FITSFixedWarning)\n        return WCS(header_time_1d)\n\n\ndef test_1d_sliced_low_level(time_1d_wcs):\n    sll = SlicedLowLevelWCS(time_1d_wcs, np.s_[10:20])\n    world = sll.pixel_to_world_values([1, 2])\n    assert isinstance(world, np.ndarray)\n    assert np.allclose(world, [27, 29])\n\n\ndef validate_info_dict(result, expected):\n    result_value = result.pop(\"value\")\n    expected_value = expected.pop(\"value\")\n\n    np.testing.assert_allclose(result_value, expected_value)\n    assert result == expected\n\n\ndef test_dropped_dimensions():\n    wcs = WCS_SPECTRAL_CUBE\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[:, :, :])\n\n    assert sub.dropped_world_dimensions == {}\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[:, 2:5, :])\n\n    assert sub.dropped_world_dimensions == {}\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[:, 0])\n\n    waocomp =sub.dropped_world_dimensions.pop(\"world_axis_object_components\")\n    assert len(waocomp) == 1 and waocomp[0][0] == \"spectral\" and waocomp[0][1] == 0\n    waocls = sub.dropped_world_dimensions.pop(\"world_axis_object_classes\")\n    assert len(waocls) == 1 and \"spectral\" in waocls and waocls[\"spectral\"][0] == u.Quantity\n    validate_info_dict(sub.dropped_world_dimensions, {\n        \"value\": [0.5],\n        \"world_axis_physical_types\": [\"em.freq\"],\n        \"world_axis_names\": [\"Frequency\"],\n        \"world_axis_units\": [\"Hz\"],\n        \"serialized_classes\": False,\n        })\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[:, 0, 0])\n\n    waocomp =sub.dropped_world_dimensions.pop(\"world_axis_object_components\")\n    assert len(waocomp) == 1 and waocomp[0][0] == \"spectral\" and waocomp[0][1] == 0\n    waocls = sub.dropped_world_dimensions.pop(\"world_axis_object_classes\")\n    assert len(waocls) == 1 and \"spectral\" in waocls and waocls[\"spectral\"][0] == u.Quantity\n    validate_info_dict(sub.dropped_world_dimensions, {\n        \"value\": [0.5],\n        \"world_axis_physical_types\": [\"em.freq\"],\n        \"world_axis_names\": [\"Frequency\"],\n        \"world_axis_units\": [\"Hz\"],\n        \"serialized_classes\": False,\n        })\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[0, :, 0])\n\n    dwd = sub.dropped_world_dimensions\n    wao_classes = dwd.pop(\"world_axis_object_classes\")\n    validate_info_dict(dwd, {\n        \"value\": [12.86995801, 20.49217541],\n        \"world_axis_physical_types\": [\"pos.galactic.lat\", \"pos.galactic.lon\"],\n        \"world_axis_names\": [\"Latitude\", \"Longitude\"],\n        \"world_axis_units\": [\"deg\", \"deg\"],\n        \"serialized_classes\": False,\n        \"world_axis_object_components\": [('celestial', 1, 'spherical.lat.degree'), ('celestial', 0, 'spherical.lon.degree')],\n        })\n\n    assert wao_classes['celestial'][0] is SkyCoord\n    assert wao_classes['celestial'][1] == ()\n    assert isinstance(wao_classes['celestial'][2]['frame'], Galactic)\n    assert wao_classes['celestial'][2]['unit'] is u.deg\n\n    sub = SlicedLowLevelWCS(wcs, np.s_[5, :5, 12])\n\n    dwd = sub.dropped_world_dimensions\n    wao_classes = dwd.pop(\"world_axis_object_classes\")\n    validate_info_dict(dwd, {\n        \"value\": [11.67648267, 21.01921192],\n        \"world_axis_physical_types\": [\"pos.galactic.lat\", \"pos.galactic.lon\"],\n        \"world_axis_names\": [\"Latitude\", \"Longitude\"],\n        \"world_axis_units\": [\"deg\", \"deg\"],\n        \"serialized_classes\": False,\n        \"world_axis_object_components\": [('celestial', 1, 'spherical.lat.degree'), ('celestial', 0, 'spherical.lon.degree')],\n        })\n\n    assert wao_classes['celestial'][0] is SkyCoord\n    assert wao_classes['celestial'][1] == ()\n    assert isinstance(wao_classes['celestial'][2]['frame'], Galactic)\n    assert wao_classes['celestial'][2]['unit'] is u.deg\n\n\ndef test_dropped_dimensions_4d(cube_4d_fitswcs):\n\n    sub = SlicedLowLevelWCS(cube_4d_fitswcs, np.s_[:, 12, 5, 5])\n\n    dwd = sub.dropped_world_dimensions\n    wao_classes = dwd.pop(\"world_axis_object_classes\")\n    wao_components = dwd.pop(\"world_axis_object_components\")\n\n    validate_info_dict(dwd, {\n        \"value\": [4.e+00, -2.e+00,  1.e+10],\n        \"world_axis_physical_types\": [\"pos.eq.ra\", \"pos.eq.dec\", \"em.freq\"],\n        \"world_axis_names\": ['Right Ascension', 'Declination', 'Frequency'],\n        \"world_axis_units\": [\"deg\", \"deg\", \"Hz\"],\n        \"serialized_classes\": False,\n        })\n\n    assert wao_classes['celestial'][0] is SkyCoord\n    assert wao_classes['celestial'][1] == ()\n    assert isinstance(wao_classes['celestial'][2]['frame'], ICRS)\n    assert wao_classes['celestial'][2]['unit'] is u.deg\n    assert wao_classes['spectral'][0:3] == (u.Quantity, (), {})\n\n    assert wao_components[0] == ('celestial', 0, 'spherical.lon.degree')\n    assert wao_components[1] == ('celestial', 1, 'spherical.lat.degree')\n    assert wao_components[2][0:2] == ('spectral', 0)\n\n    sub = SlicedLowLevelWCS(cube_4d_fitswcs, np.s_[12, 12])\n\n    dwd = sub.dropped_world_dimensions\n    wao_classes = dwd.pop(\"world_axis_object_classes\")\n    wao_components = dwd.pop(\"world_axis_object_components\")\n    validate_info_dict(dwd, {\n        \"value\": [1.e+10, 5.e+00],\n        \"world_axis_physical_types\": [\"em.freq\", \"time\"],\n        \"world_axis_names\": [\"Frequency\", \"Time\"],\n        \"world_axis_units\": [\"Hz\", \"s\"],\n        \"serialized_classes\": False,\n        })\n    assert wao_components[0][0:2] == ('spectral', 0)\n    assert wao_components[1][0] == 'time'\n    assert wao_components[1][1] == 0\n\n    assert wao_classes['spectral'][0:3] == (u.Quantity, (), {})\n    assert wao_classes['time'][0:3] == (Time, (), {})\n\n\ndef test_pixel_to_world_values_different_int_types():\n    int_sliced = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, np.s_[:, 0, :])\n    np64_sliced = SlicedLowLevelWCS(WCS_SPECTRAL_CUBE, np.s_[:, np.int64(0), :])\n    pixel_arrays = ([0, 1], [0, 1])\n    for int_coord, np64_coord in zip(int_sliced.pixel_to_world_values(*pixel_arrays),\n                                     np64_sliced.pixel_to_world_values(*pixel_arrays)):\n        assert all(int_coord == np64_coord)\n\n\ndef test_world_to_pixel_with_coupled_dimensions():\n    \"\"\"\n    Test for issue where world_to_pixel returns incorrect results when\n    there are coupled dimensions in the PC matrix.\n    \n    This reproduces the issue described in astropy/astropy#13574 where\n    SlicedLowLevelWCS.world_to_pixel_values returns erroneous results\n    when the WCS has a non-trivial PC matrix that couples spectral and\n    spatial dimensions.\n    \"\"\"\n    # Create a 3D WCS with coupled dimensions similar to the issue report\n    nx, ny, nz = 100, 25, 2\n    wcs_header = {\n        'WCSAXES': 3,\n        'CRPIX1': (nx + 1)/2,\n        'CRPIX2': (ny + 1)/2,\n        'CRPIX3': 1.0,\n        'PC1_1': 0.0,\n        'PC1_2': -1.0,\n        'PC1_3': 0.0,\n        'PC2_1': 1.0,\n        'PC2_2': 0.0,\n        'PC2_3': -1.0,  # This couples spectral and spatial dimensions\n        'CDELT1': 5,\n        'CDELT2': 5,\n        'CDELT3': 0.055,\n        'CUNIT1': 'arcsec',\n        'CUNIT2': 'arcsec',\n        'CUNIT3': 'Angstrom',\n        'CTYPE1': 'HPLN-TAN',\n        'CTYPE2': 'HPLT-TAN',\n        'CTYPE3': 'WAVE',\n        'CRVAL1': 0.0,\n        'CRVAL2': 0.0,\n        'CRVAL3': 1.05,\n    }\n    \n    fits_wcs = WCS(header=wcs_header)\n    \n    # Test world_to_pixel on the unsliced WCS\n    result_unsliced = fits_wcs.world_to_pixel_values(0.0, 0.0, 1.05)\n    \n    # Create a sliced WCS (slice the first wavelength dimension)\n    ll_sliced_wcs = SlicedLowLevelWCS(fits_wcs, 0)\n    \n    # Test world_to_pixel on the sliced WCS\n    result_sliced = ll_sliced_wcs.world_to_pixel_values(0.0, 0.0)\n    \n    # The first two components of the unsliced result should match the sliced result\n    # This was failing before the fix due to using hardcoded 1.0 for dropped dimensions\n    assert_allclose(result_sliced[0], result_unsliced[0], rtol=1e-10)\n    assert_allclose(result_sliced[1], result_unsliced[1], rtol=1e-10)\n    \n    # Also test that the values are reasonable (not essentially infinite)\n    assert abs(result_sliced[0]) < 1e6, f\"First component should be reasonable, got {result_sliced[0]}\"\n    assert abs(result_sliced[1]) < 1e6, f\"Second component should be reasonable, got {result_sliced[1]}\"\n"}, "action_id": "86b479b7-82ad-4462-8372-bf3babf87650"}