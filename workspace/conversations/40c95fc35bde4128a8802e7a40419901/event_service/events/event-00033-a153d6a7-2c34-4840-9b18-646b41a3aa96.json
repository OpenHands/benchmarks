{"kind": "ObservationEvent", "id": "a153d6a7-2c34-4840-9b18-646b41a3aa96", "timestamp": "2025-09-26T01:42:37.293474", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_01PjyLuNNFcoi53JGVztMccE", "observation": {"kind": "StrReplaceEditorObservation", "command": "str_replace", "output": "The file /tmp/tmp1c5hnr0b/sympy/sympy/assumptions/sathandlers.py has been edited. Here's the result of running `cat -n` on a snippet of /tmp/tmp1c5hnr0b/sympy/sympy/assumptions/sathandlers.py:\n     1\tfrom __future__ import print_function, division\n     2\t\n     3\tfrom collections import defaultdict\n     4\ttry:\n     5\t    from collections.abc import MutableMapping\n     6\texcept ImportError:\n     7\t    from collections import MutableMapping\n     8\t\n     9\tfrom sympy.core import (Add, Mul, Pow, Integer, Number, NumberSymbol,)\n    10\tfrom sympy.core.numbers import ImaginaryUnit\n    11\tfrom sympy.core.sympify import _sympify\n    12\t\nReview the changes and make sure they are as expected. Edit the file again if necessary.", "path": "/tmp/tmp1c5hnr0b/sympy/sympy/assumptions/sathandlers.py", "prev_exist": true, "old_content": "from __future__ import print_function, division\n\nfrom collections import MutableMapping, defaultdict\n\nfrom sympy.core import (Add, Mul, Pow, Integer, Number, NumberSymbol,)\nfrom sympy.core.numbers import ImaginaryUnit\nfrom sympy.core.sympify import _sympify\nfrom sympy.core.rules import Transform\nfrom sympy.core.logic import fuzzy_or, fuzzy_and\nfrom sympy.matrices.expressions import MatMul\n\nfrom sympy.functions.elementary.complexes import Abs\n\nfrom sympy.assumptions.ask import Q\nfrom sympy.assumptions.assume import Predicate, AppliedPredicate\nfrom sympy.logic.boolalg import (Equivalent, Implies, And, Or,\n    BooleanFunction, Not)\n\n# APIs here may be subject to change\n\n# XXX: Better name?\nclass UnevaluatedOnFree(BooleanFunction):\n    \"\"\"\n    Represents a Boolean function that remains unevaluated on free predicates\n\n    This is intended to be a superclass of other classes, which define the\n    behavior on singly applied predicates.\n\n    A free predicate is a predicate that is not applied, or a combination\n    thereof. For example, Q.zero or Or(Q.positive, Q.negative).\n\n    A singly applied predicate is a free predicate applied everywhere to a\n    single expression. For instance, Q.zero(x) and Or(Q.positive(x*y),\n    Q.negative(x*y)) are singly applied, but Or(Q.positive(x), Q.negative(y))\n    and Or(Q.positive, Q.negative(y)) are not.\n\n    The boolean literals True and False are considered to be both free and\n    singly applied.\n\n    This class raises ValueError unless the input is a free predicate or a\n    singly applied predicate.\n\n    On a free predicate, this class remains unevaluated. On a singly applied\n    predicate, the method apply() is called and returned, or the original\n    expression returned if apply() returns None. When apply() is called,\n    self.expr is set to the unique expression that the predicates are applied\n    at. self.pred is set to the free form of the predicate.\n\n    The typical usage is to create this class with free predicates and\n    evaluate it using .rcall().\n\n    \"\"\"\n    def __new__(cls, arg):\n        # Mostly type checking here\n        arg = _sympify(arg)\n        predicates = arg.atoms(Predicate)\n        applied_predicates = arg.atoms(AppliedPredicate)\n        if predicates and applied_predicates:\n            raise ValueError(\"arg must be either completely free or singly applied\")\n        if not applied_predicates:\n            obj = BooleanFunction.__new__(cls, arg)\n            obj.pred = arg\n            obj.expr = None\n            return obj\n        predicate_args = {pred.args[0] for pred in applied_predicates}\n        if len(predicate_args) > 1:\n            raise ValueError(\"The AppliedPredicates in arg must be applied to a single expression.\")\n        obj = BooleanFunction.__new__(cls, arg)\n        obj.expr = predicate_args.pop()\n        obj.pred = arg.xreplace(Transform(lambda e: e.func, lambda e:\n            isinstance(e, AppliedPredicate)))\n        applied = obj.apply()\n        if applied is None:\n            return obj\n        return applied\n\n    def apply(self):\n        return\n\n\nclass AllArgs(UnevaluatedOnFree):\n    \"\"\"\n    Class representing vectorizing a predicate over all the .args of an\n    expression\n\n    See the docstring of UnevaluatedOnFree for more information on this\n    class.\n\n    The typical usage is to evaluate predicates with expressions using .rcall().\n\n    Example\n    =======\n\n    >>> from sympy.assumptions.sathandlers import AllArgs\n    >>> from sympy import symbols, Q\n    >>> x, y = symbols('x y')\n    >>> a = AllArgs(Q.positive | Q.negative)\n    >>> a\n    AllArgs(Q.negative | Q.positive)\n    >>> a.rcall(x*y)\n    (Q.negative(x) | Q.positive(x)) & (Q.negative(y) | Q.positive(y))\n    \"\"\"\n\n    def apply(self):\n        return And(*[self.pred.rcall(arg) for arg in self.expr.args])\n\n\nclass AnyArgs(UnevaluatedOnFree):\n    \"\"\"\n    Class representing vectorizing a predicate over any of the .args of an\n    expression.\n\n    See the docstring of UnevaluatedOnFree for more information on this\n    class.\n\n    The typical usage is to evaluate predicates with expressions using .rcall().\n\n    Example\n    =======\n\n    >>> from sympy.assumptions.sathandlers import AnyArgs\n    >>> from sympy import symbols, Q\n    >>> x, y = symbols('x y')\n    >>> a = AnyArgs(Q.positive & Q.negative)\n    >>> a\n    AnyArgs(Q.negative & Q.positive)\n    >>> a.rcall(x*y)\n    (Q.negative(x) & Q.positive(x)) | (Q.negative(y) & Q.positive(y))\n    \"\"\"\n\n    def apply(self):\n        return Or(*[self.pred.rcall(arg) for arg in self.expr.args])\n\n\nclass ExactlyOneArg(UnevaluatedOnFree):\n    \"\"\"\n    Class representing a predicate holding on exactly one of the .args of an\n    expression.\n\n    See the docstring of UnevaluatedOnFree for more information on this\n    class.\n\n    The typical usage is to evaluate predicate with expressions using\n    .rcall().\n\n    Example\n    =======\n\n    >>> from sympy.assumptions.sathandlers import ExactlyOneArg\n    >>> from sympy import symbols, Q\n    >>> x, y = symbols('x y')\n    >>> a = ExactlyOneArg(Q.positive)\n    >>> a\n    ExactlyOneArg(Q.positive)\n    >>> a.rcall(x*y)\n    (Q.positive(x) & ~Q.positive(y)) | (Q.positive(y) & ~Q.positive(x))\n    \"\"\"\n    def apply(self):\n        expr = self.expr\n        pred = self.pred\n        pred_args = [pred.rcall(arg) for arg in expr.args]\n        # Technically this is xor, but if one term in the disjunction is true,\n        # it is not possible for the remainder to be true, so regular or is\n        # fine in this case.\n        return Or(*[And(pred_args[i], *map(Not, pred_args[:i] +\n            pred_args[i+1:])) for i in range(len(pred_args))])\n        # Note: this is the equivalent cnf form. The above is more efficient\n        # as the first argument of an implication, since p >> q is the same as\n        # q | ~p, so the the ~ will convert the Or to and, and one just needs\n        # to distribute the q across it to get to cnf.\n\n        # return And(*[Or(*map(Not, c)) for c in combinations(pred_args, 2)]) & Or(*pred_args)\n\n\ndef _old_assump_replacer(obj):\n    # Things to be careful of:\n    # - real means real or infinite in the old assumptions.\n    # - nonzero does not imply real in the old assumptions.\n    # - finite means finite and not zero in the old assumptions.\n    if not isinstance(obj, AppliedPredicate):\n        return obj\n\n    e = obj.args[0]\n    ret = None\n\n    if obj.func == Q.positive:\n        ret = fuzzy_and([e.is_finite, e.is_positive])\n    if obj.func == Q.zero:\n        ret = e.is_zero\n    if obj.func == Q.negative:\n        ret = fuzzy_and([e.is_finite, e.is_negative])\n    if obj.func == Q.nonpositive:\n        ret = fuzzy_and([e.is_finite, e.is_nonpositive])\n    if obj.func == Q.nonzero:\n        ret = fuzzy_and([e.is_nonzero, e.is_finite])\n    if obj.func == Q.nonnegative:\n        ret = fuzzy_and([fuzzy_or([e.is_zero, e.is_finite]),\n        e.is_nonnegative])\n\n    if obj.func == Q.rational:\n        ret = e.is_rational\n    if obj.func == Q.irrational:\n        ret = e.is_irrational\n\n    if obj.func == Q.even:\n        ret = e.is_even\n    if obj.func == Q.odd:\n        ret = e.is_odd\n    if obj.func == Q.integer:\n        ret = e.is_integer\n    if obj.func == Q.imaginary:\n        ret = e.is_imaginary\n    if obj.func == Q.commutative:\n        ret = e.is_commutative\n\n    if ret is None:\n        return obj\n    return ret\n\n\ndef evaluate_old_assump(pred):\n    \"\"\"\n    Replace assumptions of expressions replaced with their values in the old\n    assumptions (like Q.negative(-1) => True). Useful because some direct\n    computations for numeric objects is defined most conveniently in the old\n    assumptions.\n\n    \"\"\"\n    return pred.xreplace(Transform(_old_assump_replacer))\n\n\nclass CheckOldAssump(UnevaluatedOnFree):\n    def apply(self):\n        return Equivalent(self.args[0], evaluate_old_assump(self.args[0]))\n\n\nclass CheckIsPrime(UnevaluatedOnFree):\n    def apply(self):\n        from sympy import isprime\n        return Equivalent(self.args[0], isprime(self.expr))\n\n\nclass CustomLambda(object):\n    \"\"\"\n    Interface to lambda with rcall\n\n    Workaround until we get a better way to represent certain facts.\n    \"\"\"\n    def __init__(self, lamda):\n        self.lamda = lamda\n\n    def rcall(self, *args):\n        return self.lamda(*args)\n\n\nclass ClassFactRegistry(MutableMapping):\n    \"\"\"\n    Register handlers against classes\n\n    ``registry[C] = handler`` registers ``handler`` for class\n    ``C``. ``registry[C]`` returns a set of handlers for class ``C``, or any\n    of its superclasses.\n    \"\"\"\n    def __init__(self, d=None):\n        d = d or {}\n        self.d = defaultdict(frozenset, d)\n        super(ClassFactRegistry, self).__init__()\n\n    def __setitem__(self, key, item):\n        self.d[key] = frozenset(item)\n\n    def __getitem__(self, key):\n        ret = self.d[key]\n        for k in self.d:\n            if issubclass(key, k):\n                ret |= self.d[k]\n        return ret\n\n    def __delitem__(self, key):\n        del self.d[key]\n\n    def __iter__(self):\n        return self.d.__iter__()\n\n    def __len__(self):\n        return len(self.d)\n\n    def __repr__(self):\n        return repr(self.d)\n\n\nfact_registry = ClassFactRegistry()\n\n\ndef register_fact(klass, fact, registry=fact_registry):\n    registry[klass] |= {fact}\n\n\nfor klass, fact in [\n    (Mul, Equivalent(Q.zero, AnyArgs(Q.zero))),\n    (MatMul, Implies(AllArgs(Q.square), Equivalent(Q.invertible, AllArgs(Q.invertible)))),\n    (Add, Implies(AllArgs(Q.positive), Q.positive)),\n    (Add, Implies(AllArgs(Q.negative), Q.negative)),\n    (Mul, Implies(AllArgs(Q.positive), Q.positive)),\n    (Mul, Implies(AllArgs(Q.commutative), Q.commutative)),\n    (Mul, Implies(AllArgs(Q.real), Q.commutative)),\n\n    (Pow, CustomLambda(lambda power: Implies(Q.real(power.base) &\n    Q.even(power.exp) & Q.nonnegative(power.exp), Q.nonnegative(power)))),\n    (Pow, CustomLambda(lambda power: Implies(Q.nonnegative(power.base) & Q.odd(power.exp) & Q.nonnegative(power.exp), Q.nonnegative(power)))),\n    (Pow, CustomLambda(lambda power: Implies(Q.nonpositive(power.base) & Q.odd(power.exp) & Q.nonnegative(power.exp), Q.nonpositive(power)))),\n\n    # This one can still be made easier to read. I think we need basic pattern\n    # matching, so that we can just write Equivalent(Q.zero(x**y), Q.zero(x) & Q.positive(y))\n    (Pow, CustomLambda(lambda power: Equivalent(Q.zero(power), Q.zero(power.base) & Q.positive(power.exp)))),\n    (Integer, CheckIsPrime(Q.prime)),\n    # Implicitly assumes Mul has more than one arg\n    # Would be AllArgs(Q.prime | Q.composite) except 1 is composite\n    (Mul, Implies(AllArgs(Q.prime), ~Q.prime)),\n    # More advanced prime assumptions will require inequalities, as 1 provides\n    # a corner case.\n    (Mul, Implies(AllArgs(Q.imaginary | Q.real), Implies(ExactlyOneArg(Q.imaginary), Q.imaginary))),\n    (Mul, Implies(AllArgs(Q.real), Q.real)),\n    (Add, Implies(AllArgs(Q.real), Q.real)),\n    # General Case: Odd number of imaginary args implies mul is imaginary(To be implemented)\n    (Mul, Implies(AllArgs(Q.real), Implies(ExactlyOneArg(Q.irrational),\n        Q.irrational))),\n    (Add, Implies(AllArgs(Q.real), Implies(ExactlyOneArg(Q.irrational),\n        Q.irrational))),\n    (Mul, Implies(AllArgs(Q.rational), Q.rational)),\n    (Add, Implies(AllArgs(Q.rational), Q.rational)),\n\n    (Abs, Q.nonnegative),\n    (Abs, Equivalent(AllArgs(~Q.zero), ~Q.zero)),\n\n    # Including the integer qualification means we don't need to add any facts\n    # for odd, since the assumptions already know that every integer is\n    # exactly one of even or odd.\n    (Mul, Implies(AllArgs(Q.integer), Equivalent(AnyArgs(Q.even), Q.even))),\n\n    (Abs, Implies(AllArgs(Q.even), Q.even)),\n    (Abs, Implies(AllArgs(Q.odd), Q.odd)),\n\n    (Add, Implies(AllArgs(Q.integer), Q.integer)),\n    (Add, Implies(ExactlyOneArg(~Q.integer), ~Q.integer)),\n    (Mul, Implies(AllArgs(Q.integer), Q.integer)),\n    (Mul, Implies(ExactlyOneArg(~Q.rational), ~Q.integer)),\n    (Abs, Implies(AllArgs(Q.integer), Q.integer)),\n\n    (Number, CheckOldAssump(Q.negative)),\n    (Number, CheckOldAssump(Q.zero)),\n    (Number, CheckOldAssump(Q.positive)),\n    (Number, CheckOldAssump(Q.nonnegative)),\n    (Number, CheckOldAssump(Q.nonzero)),\n    (Number, CheckOldAssump(Q.nonpositive)),\n    (Number, CheckOldAssump(Q.rational)),\n    (Number, CheckOldAssump(Q.irrational)),\n    (Number, CheckOldAssump(Q.even)),\n    (Number, CheckOldAssump(Q.odd)),\n    (Number, CheckOldAssump(Q.integer)),\n    (Number, CheckOldAssump(Q.imaginary)),\n    # For some reason NumberSymbol does not subclass Number\n    (NumberSymbol, CheckOldAssump(Q.negative)),\n    (NumberSymbol, CheckOldAssump(Q.zero)),\n    (NumberSymbol, CheckOldAssump(Q.positive)),\n    (NumberSymbol, CheckOldAssump(Q.nonnegative)),\n    (NumberSymbol, CheckOldAssump(Q.nonzero)),\n    (NumberSymbol, CheckOldAssump(Q.nonpositive)),\n    (NumberSymbol, CheckOldAssump(Q.rational)),\n    (NumberSymbol, CheckOldAssump(Q.irrational)),\n    (NumberSymbol, CheckOldAssump(Q.imaginary)),\n    (ImaginaryUnit, CheckOldAssump(Q.negative)),\n    (ImaginaryUnit, CheckOldAssump(Q.zero)),\n    (ImaginaryUnit, CheckOldAssump(Q.positive)),\n    (ImaginaryUnit, CheckOldAssump(Q.nonnegative)),\n    (ImaginaryUnit, CheckOldAssump(Q.nonzero)),\n    (ImaginaryUnit, CheckOldAssump(Q.nonpositive)),\n    (ImaginaryUnit, CheckOldAssump(Q.rational)),\n    (ImaginaryUnit, CheckOldAssump(Q.irrational)),\n    (ImaginaryUnit, CheckOldAssump(Q.imaginary))\n    ]:\n\n    register_fact(klass, fact)\n", "new_content": "from __future__ import print_function, division\n\nfrom collections import defaultdict\ntry:\n    from collections.abc import MutableMapping\nexcept ImportError:\n    from collections import MutableMapping\n\nfrom sympy.core import (Add, Mul, Pow, Integer, Number, NumberSymbol,)\nfrom sympy.core.numbers import ImaginaryUnit\nfrom sympy.core.sympify import _sympify\nfrom sympy.core.rules import Transform\nfrom sympy.core.logic import fuzzy_or, fuzzy_and\nfrom sympy.matrices.expressions import MatMul\n\nfrom sympy.functions.elementary.complexes import Abs\n\nfrom sympy.assumptions.ask import Q\nfrom sympy.assumptions.assume import Predicate, AppliedPredicate\nfrom sympy.logic.boolalg import (Equivalent, Implies, And, Or,\n    BooleanFunction, Not)\n\n# APIs here may be subject to change\n\n# XXX: Better name?\nclass UnevaluatedOnFree(BooleanFunction):\n    \"\"\"\n    Represents a Boolean function that remains unevaluated on free predicates\n\n    This is intended to be a superclass of other classes, which define the\n    behavior on singly applied predicates.\n\n    A free predicate is a predicate that is not applied, or a combination\n    thereof. For example, Q.zero or Or(Q.positive, Q.negative).\n\n    A singly applied predicate is a free predicate applied everywhere to a\n    single expression. For instance, Q.zero(x) and Or(Q.positive(x*y),\n    Q.negative(x*y)) are singly applied, but Or(Q.positive(x), Q.negative(y))\n    and Or(Q.positive, Q.negative(y)) are not.\n\n    The boolean literals True and False are considered to be both free and\n    singly applied.\n\n    This class raises ValueError unless the input is a free predicate or a\n    singly applied predicate.\n\n    On a free predicate, this class remains unevaluated. On a singly applied\n    predicate, the method apply() is called and returned, or the original\n    expression returned if apply() returns None. When apply() is called,\n    self.expr is set to the unique expression that the predicates are applied\n    at. self.pred is set to the free form of the predicate.\n\n    The typical usage is to create this class with free predicates and\n    evaluate it using .rcall().\n\n    \"\"\"\n    def __new__(cls, arg):\n        # Mostly type checking here\n        arg = _sympify(arg)\n        predicates = arg.atoms(Predicate)\n        applied_predicates = arg.atoms(AppliedPredicate)\n        if predicates and applied_predicates:\n            raise ValueError(\"arg must be either completely free or singly applied\")\n        if not applied_predicates:\n            obj = BooleanFunction.__new__(cls, arg)\n            obj.pred = arg\n            obj.expr = None\n            return obj\n        predicate_args = {pred.args[0] for pred in applied_predicates}\n        if len(predicate_args) > 1:\n            raise ValueError(\"The AppliedPredicates in arg must be applied to a single expression.\")\n        obj = BooleanFunction.__new__(cls, arg)\n        obj.expr = predicate_args.pop()\n        obj.pred = arg.xreplace(Transform(lambda e: e.func, lambda e:\n            isinstance(e, AppliedPredicate)))\n        applied = obj.apply()\n        if applied is None:\n            return obj\n        return applied\n\n    def apply(self):\n        return\n\n\nclass AllArgs(UnevaluatedOnFree):\n    \"\"\"\n    Class representing vectorizing a predicate over all the .args of an\n    expression\n\n    See the docstring of UnevaluatedOnFree for more information on this\n    class.\n\n    The typical usage is to evaluate predicates with expressions using .rcall().\n\n    Example\n    =======\n\n    >>> from sympy.assumptions.sathandlers import AllArgs\n    >>> from sympy import symbols, Q\n    >>> x, y = symbols('x y')\n    >>> a = AllArgs(Q.positive | Q.negative)\n    >>> a\n    AllArgs(Q.negative | Q.positive)\n    >>> a.rcall(x*y)\n    (Q.negative(x) | Q.positive(x)) & (Q.negative(y) | Q.positive(y))\n    \"\"\"\n\n    def apply(self):\n        return And(*[self.pred.rcall(arg) for arg in self.expr.args])\n\n\nclass AnyArgs(UnevaluatedOnFree):\n    \"\"\"\n    Class representing vectorizing a predicate over any of the .args of an\n    expression.\n\n    See the docstring of UnevaluatedOnFree for more information on this\n    class.\n\n    The typical usage is to evaluate predicates with expressions using .rcall().\n\n    Example\n    =======\n\n    >>> from sympy.assumptions.sathandlers import AnyArgs\n    >>> from sympy import symbols, Q\n    >>> x, y = symbols('x y')\n    >>> a = AnyArgs(Q.positive & Q.negative)\n    >>> a\n    AnyArgs(Q.negative & Q.positive)\n    >>> a.rcall(x*y)\n    (Q.negative(x) & Q.positive(x)) | (Q.negative(y) & Q.positive(y))\n    \"\"\"\n\n    def apply(self):\n        return Or(*[self.pred.rcall(arg) for arg in self.expr.args])\n\n\nclass ExactlyOneArg(UnevaluatedOnFree):\n    \"\"\"\n    Class representing a predicate holding on exactly one of the .args of an\n    expression.\n\n    See the docstring of UnevaluatedOnFree for more information on this\n    class.\n\n    The typical usage is to evaluate predicate with expressions using\n    .rcall().\n\n    Example\n    =======\n\n    >>> from sympy.assumptions.sathandlers import ExactlyOneArg\n    >>> from sympy import symbols, Q\n    >>> x, y = symbols('x y')\n    >>> a = ExactlyOneArg(Q.positive)\n    >>> a\n    ExactlyOneArg(Q.positive)\n    >>> a.rcall(x*y)\n    (Q.positive(x) & ~Q.positive(y)) | (Q.positive(y) & ~Q.positive(x))\n    \"\"\"\n    def apply(self):\n        expr = self.expr\n        pred = self.pred\n        pred_args = [pred.rcall(arg) for arg in expr.args]\n        # Technically this is xor, but if one term in the disjunction is true,\n        # it is not possible for the remainder to be true, so regular or is\n        # fine in this case.\n        return Or(*[And(pred_args[i], *map(Not, pred_args[:i] +\n            pred_args[i+1:])) for i in range(len(pred_args))])\n        # Note: this is the equivalent cnf form. The above is more efficient\n        # as the first argument of an implication, since p >> q is the same as\n        # q | ~p, so the the ~ will convert the Or to and, and one just needs\n        # to distribute the q across it to get to cnf.\n\n        # return And(*[Or(*map(Not, c)) for c in combinations(pred_args, 2)]) & Or(*pred_args)\n\n\ndef _old_assump_replacer(obj):\n    # Things to be careful of:\n    # - real means real or infinite in the old assumptions.\n    # - nonzero does not imply real in the old assumptions.\n    # - finite means finite and not zero in the old assumptions.\n    if not isinstance(obj, AppliedPredicate):\n        return obj\n\n    e = obj.args[0]\n    ret = None\n\n    if obj.func == Q.positive:\n        ret = fuzzy_and([e.is_finite, e.is_positive])\n    if obj.func == Q.zero:\n        ret = e.is_zero\n    if obj.func == Q.negative:\n        ret = fuzzy_and([e.is_finite, e.is_negative])\n    if obj.func == Q.nonpositive:\n        ret = fuzzy_and([e.is_finite, e.is_nonpositive])\n    if obj.func == Q.nonzero:\n        ret = fuzzy_and([e.is_nonzero, e.is_finite])\n    if obj.func == Q.nonnegative:\n        ret = fuzzy_and([fuzzy_or([e.is_zero, e.is_finite]),\n        e.is_nonnegative])\n\n    if obj.func == Q.rational:\n        ret = e.is_rational\n    if obj.func == Q.irrational:\n        ret = e.is_irrational\n\n    if obj.func == Q.even:\n        ret = e.is_even\n    if obj.func == Q.odd:\n        ret = e.is_odd\n    if obj.func == Q.integer:\n        ret = e.is_integer\n    if obj.func == Q.imaginary:\n        ret = e.is_imaginary\n    if obj.func == Q.commutative:\n        ret = e.is_commutative\n\n    if ret is None:\n        return obj\n    return ret\n\n\ndef evaluate_old_assump(pred):\n    \"\"\"\n    Replace assumptions of expressions replaced with their values in the old\n    assumptions (like Q.negative(-1) => True). Useful because some direct\n    computations for numeric objects is defined most conveniently in the old\n    assumptions.\n\n    \"\"\"\n    return pred.xreplace(Transform(_old_assump_replacer))\n\n\nclass CheckOldAssump(UnevaluatedOnFree):\n    def apply(self):\n        return Equivalent(self.args[0], evaluate_old_assump(self.args[0]))\n\n\nclass CheckIsPrime(UnevaluatedOnFree):\n    def apply(self):\n        from sympy import isprime\n        return Equivalent(self.args[0], isprime(self.expr))\n\n\nclass CustomLambda(object):\n    \"\"\"\n    Interface to lambda with rcall\n\n    Workaround until we get a better way to represent certain facts.\n    \"\"\"\n    def __init__(self, lamda):\n        self.lamda = lamda\n\n    def rcall(self, *args):\n        return self.lamda(*args)\n\n\nclass ClassFactRegistry(MutableMapping):\n    \"\"\"\n    Register handlers against classes\n\n    ``registry[C] = handler`` registers ``handler`` for class\n    ``C``. ``registry[C]`` returns a set of handlers for class ``C``, or any\n    of its superclasses.\n    \"\"\"\n    def __init__(self, d=None):\n        d = d or {}\n        self.d = defaultdict(frozenset, d)\n        super(ClassFactRegistry, self).__init__()\n\n    def __setitem__(self, key, item):\n        self.d[key] = frozenset(item)\n\n    def __getitem__(self, key):\n        ret = self.d[key]\n        for k in self.d:\n            if issubclass(key, k):\n                ret |= self.d[k]\n        return ret\n\n    def __delitem__(self, key):\n        del self.d[key]\n\n    def __iter__(self):\n        return self.d.__iter__()\n\n    def __len__(self):\n        return len(self.d)\n\n    def __repr__(self):\n        return repr(self.d)\n\n\nfact_registry = ClassFactRegistry()\n\n\ndef register_fact(klass, fact, registry=fact_registry):\n    registry[klass] |= {fact}\n\n\nfor klass, fact in [\n    (Mul, Equivalent(Q.zero, AnyArgs(Q.zero))),\n    (MatMul, Implies(AllArgs(Q.square), Equivalent(Q.invertible, AllArgs(Q.invertible)))),\n    (Add, Implies(AllArgs(Q.positive), Q.positive)),\n    (Add, Implies(AllArgs(Q.negative), Q.negative)),\n    (Mul, Implies(AllArgs(Q.positive), Q.positive)),\n    (Mul, Implies(AllArgs(Q.commutative), Q.commutative)),\n    (Mul, Implies(AllArgs(Q.real), Q.commutative)),\n\n    (Pow, CustomLambda(lambda power: Implies(Q.real(power.base) &\n    Q.even(power.exp) & Q.nonnegative(power.exp), Q.nonnegative(power)))),\n    (Pow, CustomLambda(lambda power: Implies(Q.nonnegative(power.base) & Q.odd(power.exp) & Q.nonnegative(power.exp), Q.nonnegative(power)))),\n    (Pow, CustomLambda(lambda power: Implies(Q.nonpositive(power.base) & Q.odd(power.exp) & Q.nonnegative(power.exp), Q.nonpositive(power)))),\n\n    # This one can still be made easier to read. I think we need basic pattern\n    # matching, so that we can just write Equivalent(Q.zero(x**y), Q.zero(x) & Q.positive(y))\n    (Pow, CustomLambda(lambda power: Equivalent(Q.zero(power), Q.zero(power.base) & Q.positive(power.exp)))),\n    (Integer, CheckIsPrime(Q.prime)),\n    # Implicitly assumes Mul has more than one arg\n    # Would be AllArgs(Q.prime | Q.composite) except 1 is composite\n    (Mul, Implies(AllArgs(Q.prime), ~Q.prime)),\n    # More advanced prime assumptions will require inequalities, as 1 provides\n    # a corner case.\n    (Mul, Implies(AllArgs(Q.imaginary | Q.real), Implies(ExactlyOneArg(Q.imaginary), Q.imaginary))),\n    (Mul, Implies(AllArgs(Q.real), Q.real)),\n    (Add, Implies(AllArgs(Q.real), Q.real)),\n    # General Case: Odd number of imaginary args implies mul is imaginary(To be implemented)\n    (Mul, Implies(AllArgs(Q.real), Implies(ExactlyOneArg(Q.irrational),\n        Q.irrational))),\n    (Add, Implies(AllArgs(Q.real), Implies(ExactlyOneArg(Q.irrational),\n        Q.irrational))),\n    (Mul, Implies(AllArgs(Q.rational), Q.rational)),\n    (Add, Implies(AllArgs(Q.rational), Q.rational)),\n\n    (Abs, Q.nonnegative),\n    (Abs, Equivalent(AllArgs(~Q.zero), ~Q.zero)),\n\n    # Including the integer qualification means we don't need to add any facts\n    # for odd, since the assumptions already know that every integer is\n    # exactly one of even or odd.\n    (Mul, Implies(AllArgs(Q.integer), Equivalent(AnyArgs(Q.even), Q.even))),\n\n    (Abs, Implies(AllArgs(Q.even), Q.even)),\n    (Abs, Implies(AllArgs(Q.odd), Q.odd)),\n\n    (Add, Implies(AllArgs(Q.integer), Q.integer)),\n    (Add, Implies(ExactlyOneArg(~Q.integer), ~Q.integer)),\n    (Mul, Implies(AllArgs(Q.integer), Q.integer)),\n    (Mul, Implies(ExactlyOneArg(~Q.rational), ~Q.integer)),\n    (Abs, Implies(AllArgs(Q.integer), Q.integer)),\n\n    (Number, CheckOldAssump(Q.negative)),\n    (Number, CheckOldAssump(Q.zero)),\n    (Number, CheckOldAssump(Q.positive)),\n    (Number, CheckOldAssump(Q.nonnegative)),\n    (Number, CheckOldAssump(Q.nonzero)),\n    (Number, CheckOldAssump(Q.nonpositive)),\n    (Number, CheckOldAssump(Q.rational)),\n    (Number, CheckOldAssump(Q.irrational)),\n    (Number, CheckOldAssump(Q.even)),\n    (Number, CheckOldAssump(Q.odd)),\n    (Number, CheckOldAssump(Q.integer)),\n    (Number, CheckOldAssump(Q.imaginary)),\n    # For some reason NumberSymbol does not subclass Number\n    (NumberSymbol, CheckOldAssump(Q.negative)),\n    (NumberSymbol, CheckOldAssump(Q.zero)),\n    (NumberSymbol, CheckOldAssump(Q.positive)),\n    (NumberSymbol, CheckOldAssump(Q.nonnegative)),\n    (NumberSymbol, CheckOldAssump(Q.nonzero)),\n    (NumberSymbol, CheckOldAssump(Q.nonpositive)),\n    (NumberSymbol, CheckOldAssump(Q.rational)),\n    (NumberSymbol, CheckOldAssump(Q.irrational)),\n    (NumberSymbol, CheckOldAssump(Q.imaginary)),\n    (ImaginaryUnit, CheckOldAssump(Q.negative)),\n    (ImaginaryUnit, CheckOldAssump(Q.zero)),\n    (ImaginaryUnit, CheckOldAssump(Q.positive)),\n    (ImaginaryUnit, CheckOldAssump(Q.nonnegative)),\n    (ImaginaryUnit, CheckOldAssump(Q.nonzero)),\n    (ImaginaryUnit, CheckOldAssump(Q.nonpositive)),\n    (ImaginaryUnit, CheckOldAssump(Q.rational)),\n    (ImaginaryUnit, CheckOldAssump(Q.irrational)),\n    (ImaginaryUnit, CheckOldAssump(Q.imaginary))\n    ]:\n\n    register_fact(klass, fact)\n"}, "action_id": "5f7ab346-876e-4bf9-8131-7f1ab35b3712"}