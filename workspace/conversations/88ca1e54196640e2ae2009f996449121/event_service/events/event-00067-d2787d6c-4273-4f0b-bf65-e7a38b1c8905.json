{"kind": "ObservationEvent", "id": "d2787d6c-4273-4f0b-bf65-e7a38b1c8905", "timestamp": "2025-09-25T19:01:29.964053", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_01M9Py7eS2akJSLxXpjhMksD", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmpyjyraizy/sympy/sympy/matrices/expressions/matexpr.py:\n     1\tfrom __future__ import print_function, division\n     2\t\n     3\tfrom functools import wraps, reduce\n     4\timport collections\n     5\t\n     6\tfrom sympy.core import S, Symbol, Tuple, Integer, Basic, Expr, Eq\n     7\tfrom sympy.core.decorators import call_highest_priority\n     8\tfrom sympy.core.compatibility import range, SYMPY_INTS, default_sort_key\n     9\tfrom sympy.core.sympify import SympifyError, sympify\n    10\tfrom sympy.functions import conjugate, adjoint\n    11\tfrom sympy.functions.special.tensor_functions import KroneckerDelta\n    12\tfrom sympy.matrices import ShapeError\n    13\tfrom sympy.simplify import simplify\n    14\tfrom sympy.utilities.misc import filldedent\n    15\t\n    16\t\n    17\tdef _sympifyit(arg, retval=None):\n    18\t    # This version of _sympifyit sympifies MutableMatrix objects\n    19\t    def deco(func):\n    20\t        @wraps(func)\n    21\t        def __sympifyit_wrapper(a, b):\n    22\t            try:\n    23\t                b = sympify(b, strict=True)\n    24\t                return func(a, b)\n    25\t            except SympifyError:\n    26\t                return retval\n    27\t\n    28\t        return __sympifyit_wrapper\n    29\t\n    30\t    return deco\n    31\t\n    32\t\n    33\tclass MatrixExpr(Expr):\n    34\t    \"\"\" Superclass for Matrix Expressions\n    35\t\n    36\t    MatrixExprs represent abstract matrices, linear transformations represented\n    37\t    within a particular basis.\n    38\t\n    39\t    Examples\n    40\t    ========\n    41\t\n    42\t    >>> from sympy import MatrixSymbol\n    43\t    >>> A = MatrixSymbol('A', 3, 3)\n    44\t    >>> y = MatrixSymbol('y', 3, 1)\n    45\t    >>> x = (A.T*A).I * A * y\n    46\t\n    47\t    See Also\n    48\t    ========\n    49\t        MatrixSymbol\n    50\t        MatAdd\n    51\t        MatMul\n    52\t        Transpose\n    53\t        Inverse\n    54\t    \"\"\"\n    55\t\n    56\t    # Should not be considered iterable by the\n    57\t    # sympy.core.compatibility.iterable function. Subclass that actually are\n    58\t    # iterable (i.e., explicit matrices) should set this to True.\n    59\t    _iterable = False\n    60\t\n    61\t    _op_priority = 11.0\n    62\t\n    63\t    is_Matrix = True\n    64\t    is_MatrixExpr = True\n    65\t    is_Identity = None\n    66\t    is_Inverse = False\n    67\t    is_Transpose = False\n    68\t    is_ZeroMatrix = False\n    69\t    is_MatAdd = False\n    70\t    is_MatMul = False\n    71\t\n    72\t    is_commutative = False\n    73\t    is_number = False\n    74\t    is_symbol = True\n    75\t\n    76\t    def __new__(cls, *args, **kwargs):\n    77\t        args = map(sympify, args)\n    78\t        return Basic.__new__(cls, *args, **kwargs)\n    79\t\n    80\t    # The following is adapted from the core Expr object\n    81\t    def __neg__(self):\n    82\t        return MatMul(S.NegativeOne, self).doit()\n    83\t\n    84\t    def __abs__(self):\n    85\t        raise NotImplementedError\n    86\t\n    87\t    @_sympifyit('other', NotImplemented)\n    88\t    @call_highest_priority('__radd__')\n    89\t    def __add__(self, other):\n    90\t        return MatAdd(self, other).doit()\n    91\t\n    92\t    @_sympifyit('other', NotImplemented)\n    93\t    @call_highest_priority('__add__')\n    94\t    def __radd__(self, other):\n    95\t        return MatAdd(other, self).doit()\n    96\t\n    97\t    @_sympifyit('other', NotImplemented)\n    98\t    @call_highest_priority('__rsub__')\n    99\t    def __sub__(self, other):\n   100\t        return MatAdd(self, -other).doit()\n   101\t\n   102\t    @_sympifyit('other', NotImplemented)\n   103\t    @call_highest_priority('__sub__')\n   104\t    def __rsub__(self, other):\n   105\t        return MatAdd(other, -self).doit()\n   106\t\n   107\t    @_sympifyit('other', NotImplemented)\n   108\t    @call_highest_priority('__rmul__')\n   109\t    def __mul__(self, other):\n   110\t        return MatMul(self, other).doit()\n   111\t\n   112\t    @_sympifyit('other', NotImplemented)\n   113\t    @call_highest_priority('__rmul__')\n   114\t    def __matmul__(self, other):\n   115\t        return MatMul(self, other).doit()\n   116\t\n   117\t    @_sympifyit('other', NotImplemented)\n   118\t    @call_highest_priority('__mul__')\n   119\t    def __rmul__(self, other):\n   120\t        return MatMul(other, self).doit()\n   121\t\n   122\t    @_sympifyit('other', NotImplemented)\n   123\t    @call_highest_priority('__mul__')\n   124\t    def __rmatmul__(self, other):\n   125\t        return MatMul(other, self).doit()\n   126\t\n   127\t    @_sympifyit('other', NotImplemented)\n   128\t    @call_highest_priority('__rpow__')\n   129\t    def __pow__(self, other):\n   130\t        if not self.is_square:\n   131\t            raise ShapeError(\"Power of non-square matrix %s\" % self)\n   132\t        elif self.is_Identity:\n   133\t            return self\n   134\t        elif other is S.NegativeOne:\n   135\t            return Inverse(self)\n   136\t        elif other is S.Zero:\n   137\t            return Identity(self.rows)\n   138\t        elif other is S.One:\n   139\t            return self\n   140\t        return MatPow(self, other)\n   141\t\n   142\t    @_sympifyit('other', NotImplemented)\n   143\t    @call_highest_priority('__pow__')\n   144\t    def __rpow__(self, other):\n   145\t        raise NotImplementedError(\"Matrix Power not defined\")\n   146\t\n   147\t    @_sympifyit('other', NotImplemented)\n   148\t    @call_highest_priority('__rdiv__')\n   149\t    def __div__(self, other):\n   150\t        return self * other**S.NegativeOne\n   151\t\n   152\t    @_sympifyit('other', NotImplemented)\n   153\t    @call_highest_priority('__div__')\n   154\t    def __rdiv__(self, other):\n   155\t        raise NotImplementedError()\n   156\t        #return MatMul(other, Pow(self, S.NegativeOne))\n   157\t\n   158\t    __truediv__ = __div__\n   159\t    __rtruediv__ = __rdiv__\n   160\t\n   161\t    @property\n   162\t    def rows(self):\n   163\t        return self.shape[0]\n   164\t\n   165\t    @property\n   166\t    def cols(self):\n   167\t        return self.shape[1]\n   168\t\n   169\t    @property\n   170\t    def is_square(self):\n   171\t        return self.rows == self.cols\n   172\t\n   173\t    def _eval_conjugate(self):\n   174\t        from sympy.matrices.expressions.adjoint import Adjoint\n   175\t        from sympy.matrices.expressions.transpose import Transpose\n   176\t        return Adjoint(Transpose(self))\n   177\t\n   178\t    def as_real_imag(self):\n   179\t        from sympy import I\n   180\t        real = (S(1)/2) * (self + self._eval_conjugate())\n   181\t        im = (self - self._eval_conjugate())/(2*I)\n   182\t        return (real, im)\n   183\t\n   184\t    def _eval_inverse(self):\n   185\t        from sympy.matrices.expressions.inverse import Inverse\n   186\t        return Inverse(self)\n   187\t\n   188\t    def _eval_transpose(self):\n   189\t        return Transpose(self)\n   190\t\n   191\t    def _eval_power(self, exp):\n   192\t        return MatPow(self, exp)\n   193\t\n   194\t    def _eval_simplify(self, **kwargs):\n   195\t        if self.is_Atom:\n   196\t            return self\n   197\t        else:\n   198\t            return self.__class__(*[simplify(x, **kwargs) for x in self.args])\n   199\t\n   200\t    def _eval_adjoint(self):\n   201\t        from sympy.matrices.expressions.adjoint import Adjoint\n   202\t        return Adjoint(self)\n   203\t\n   204\t    def _eval_derivative(self, v):\n   205\t        if not isinstance(v, MatrixExpr):\n   206\t            return None\n   207\t\n   208\t        # Convert to the index-summation notation, perform the derivative, then\n   209\t        # reconvert it back to matrix expression.\n   210\t        from sympy import symbols, Dummy, Lambda, Trace\n   211\t        i, j, m, n = symbols(\"i j m n\", cls=Dummy)\n   212\t        M = self._entry(i, j, expand=False)\n   213\t\n   214\t        # Replace traces with summations:\n   215\t        def getsum(x):\n   216\t            di = Dummy(\"d_i\")\n   217\t            return Sum(x.args[0], (di, 0, x.args[0].shape[0]-1))\n   218\t        M = M.replace(lambda x: isinstance(x, Trace), getsum)\n   219\t\n   220\t        repl = {}\n   221\t        if self.shape[0] == 1:\n   222\t            repl[i] = 0\n   223\t        if self.shape[1] == 1:\n   224\t            repl[j] = 0\n   225\t        if v.shape[0] == 1:\n   226\t            repl[m] = 0\n   227\t        if v.shape[1] == 1:\n   228\t            repl[n] = 0\n   229\t        res = M.diff(v[m, n])\n   230\t        res = res.xreplace(repl)\n   231\t        if res == 0:\n   232\t            return res\n   233\t        if len(repl) < 2:\n   234\t            return res\n   235\t        if m not in repl:\n   236\t            return MatrixExpr.from_index_summation(res, m)\n   237\t        if i not in repl:\n   238\t            return MatrixExpr.from_index_summation(res, i)\n   239\t        return MatrixExpr.from_index_summation(res)\n   240\t\n   241\t    def _entry(self, i, j, **kwargs):\n   242\t        raise NotImplementedError(\n   243\t            \"Indexing not implemented for %s\" % self.__class__.__name__)\n   244\t\n   245\t    def adjoint(self):\n   246\t        return adjoint(self)\n   247\t\n   248\t    def as_coeff_Mul(self, rational=False):\n   249\t        \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n   250\t        return S.One, self\n   251\t\n   252\t    def conjugate(self):\n   253\t        return conjugate(self)\n   254\t\n   255\t    def transpose(self):\n   256\t        from sympy.matrices.expressions.transpose import transpose\n   257\t        return transpose(self)\n   258\t\n   259\t    T = property(transpose, None, None, 'Matrix transposition.')\n   260\t\n   261\t    def inverse(self):\n   262\t        return self._eval_inverse()\n   263\t\n   264\t    inv = inverse\n   265\t\n   266\t    @property\n   267\t    def I(self):\n   268\t        return self.inverse()\n   269\t\n   270\t    def valid_index(self, i, j):\n   271\t        def is_valid(idx):\n   272\t            return isinstance(idx, (int, Integer, Symbol, Expr))\n   273\t        return (is_valid(i) and is_valid(j) and\n   274\t                (self.rows is None<response clipped><NOTE>Due to the max output limit, only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE>ddend in res:\n   275\t                    scalar = 1\n   276\t                    for elem, indices in res_addend:\n   277\t                        if indices is None:\n   278\t                            scalar = elem\n   279\t                            continue\n   280\t                        indices = tuple(sorted(indices, key=default_sort_key))\n   281\t                        d[indices].append(scalar*remove_matelement(elem, *indices))\n   282\t                        scalar = 1\n   283\t                return [(MatrixElement(Add.fromiter(v), *k), k) for k, v in d.items()]\n   284\t            elif isinstance(expr, KroneckerDelta):\n   285\t                i1, i2 = expr.args\n   286\t                return [(MatrixElement(S.One, i1, i2), (i1, i2))]\n   287\t            elif isinstance(expr, MatrixElement):\n   288\t                matrix_symbol, i1, i2 = expr.args\n   289\t                if i1 in index_ranges:\n   290\t                    r1, r2 = index_ranges[i1]\n   291\t                    if r1 != 0 or matrix_symbol.shape[0] != r2+1:\n   292\t                        raise ValueError(\"index range mismatch: {0} vs. (0, {1})\".format(\n   293\t                            (r1, r2), matrix_symbol.shape[0]))\n   294\t                if i2 in index_ranges:\n   295\t                    r1, r2 = index_ranges[i2]\n   296\t                    if r1 != 0 or matrix_symbol.shape[1] != r2+1:\n   297\t                        raise ValueError(\"index range mismatch: {0} vs. (0, {1})\".format(\n   298\t                            (r1, r2), matrix_symbol.shape[1]))\n   299\t                if (i1 == i2) and (i1 in index_ranges):\n   300\t                    return [(trace(matrix_symbol), None)]\n   301\t                return [(MatrixElement(matrix_symbol, i1, i2), (i1, i2))]\n   302\t            elif isinstance(expr, Sum):\n   303\t                return recurse_expr(\n   304\t                    expr.args[0],\n   305\t                    index_ranges={i[0]: i[1:] for i in expr.args[1:]}\n   306\t                )\n   307\t            else:\n   308\t                return [(expr, None)]\n   309\t\n   310\t        retvals = recurse_expr(expr)\n   311\t        factors, indices = zip(*retvals)\n   312\t        retexpr = Mul.fromiter(factors)\n   313\t        if len(indices) == 0 or list(set(indices)) == [None]:\n   314\t            return retexpr\n   315\t        if first_index is None:\n   316\t            for i in indices:\n   317\t                if i is not None:\n   318\t                    ind0 = i\n   319\t                    break\n   320\t            return remove_matelement(retexpr, *ind0)\n   321\t        else:\n   322\t            return remove_matelement(retexpr, first_index, last_index)\n   323\t\n   324\t\n   325\tclass MatrixElement(Expr):\n   326\t    parent = property(lambda self: self.args[0])\n   327\t    i = property(lambda self: self.args[1])\n   328\t    j = property(lambda self: self.args[2])\n   329\t    _diff_wrt = True\n   330\t    is_symbol = True\n   331\t    is_commutative = True\n   332\t\n   333\t    def __new__(cls, name, n, m):\n   334\t        n, m = map(sympify, (n, m))\n   335\t        from sympy import MatrixBase\n   336\t        if isinstance(name, (MatrixBase,)):\n   337\t            if n.is_Integer and m.is_Integer:\n   338\t                return name[n, m]\n   339\t        name = sympify(name)\n   340\t        obj = Expr.__new__(cls, name, n, m)\n   341\t        return obj\n   342\t\n   343\t    def doit(self, **kwargs):\n   344\t        deep = kwargs.get('deep', True)\n   345\t        if deep:\n   346\t            args = [arg.doit(**kwargs) for arg in self.args]\n   347\t        else:\n   348\t            args = self.args\n   349\t        return args[0][args[1], args[2]]\n   350\t\n   351\t    def _eval_derivative(self, v):\n   352\t        from sympy import Sum, symbols, Dummy\n   353\t\n   354\t        if not isinstance(v, MatrixElement):\n   355\t            from sympy import MatrixBase\n   356\t            if isinstance(self.parent, MatrixBase):\n   357\t                return self.parent.diff(v)[self.i, self.j]\n   358\t            return S.Zero\n   359\t\n   360\t        M = self.args[0]\n   361\t\n   362\t        if M == v.args[0]:\n   363\t            return KroneckerDelta(self.args[1], v.args[1])*KroneckerDelta(self.args[2], v.args[2])\n   364\t\n   365\t        if isinstance(M, Inverse):\n   366\t            i, j = self.args[1:]\n   367\t            i1, i2 = symbols(\"z1, z2\", cls=Dummy)\n   368\t            Y = M.args[0]\n   369\t            r1, r2 = Y.shape\n   370\t            return -Sum(M[i, i1]*Y[i1, i2].diff(v)*M[i2, j], (i1, 0, r1-1), (i2, 0, r2-1))\n   371\t\n   372\t        if self.has(v.args[0]):\n   373\t            return None\n   374\t\n   375\t        return S.Zero\n   376\t\n   377\t\n   378\tclass MatrixSymbol(MatrixExpr):\n   379\t    \"\"\"Symbolic representation of a Matrix object\n   380\t\n   381\t    Creates a SymPy Symbol to represent a Matrix. This matrix has a shape and\n   382\t    can be included in Matrix Expressions\n   383\t\n   384\t    >>> from sympy import MatrixSymbol, Identity\n   385\t    >>> A = MatrixSymbol('A', 3, 4) # A 3 by 4 Matrix\n   386\t    >>> B = MatrixSymbol('B', 4, 3) # A 4 by 3 Matrix\n   387\t    >>> A.shape\n   388\t    (3, 4)\n   389\t    >>> 2*A*B + Identity(3)\n   390\t    I + 2*A*B\n   391\t    \"\"\"\n   392\t    is_commutative = False\n   393\t    _diff_wrt = True\n   394\t\n   395\t    def __new__(cls, name, n, m):\n   396\t        n, m = sympify(n), sympify(m)\n   397\t        obj = Basic.__new__(cls, name, n, m)\n   398\t        return obj\n   399\t\n   400\t    def _hashable_content(self):\n   401\t        return(self.name, self.shape)\n   402\t\n   403\t    @property\n   404\t    def shape(self):\n   405\t        return self.args[1:3]\n   406\t\n   407\t    @property\n   408\t    def name(self):\n   409\t        return self.args[0]\n   410\t\n   411\t    def _eval_subs(self, old, new):\n   412\t        # only do substitutions in shape\n   413\t        shape = Tuple(*self.shape)._subs(old, new)\n   414\t        return MatrixSymbol(self.name, *shape)\n   415\t\n   416\t    def __call__(self, *args):\n   417\t        raise TypeError( \"%s object is not callable\" % self.__class__ )\n   418\t\n   419\t    def _entry(self, i, j, **kwargs):\n   420\t        return MatrixElement(self, i, j)\n   421\t\n   422\t    @property\n   423\t    def free_symbols(self):\n   424\t        return set((self,))\n   425\t\n   426\t    def doit(self, **hints):\n   427\t        if hints.get('deep', True):\n   428\t            return type(self)(self.name, self.args[1].doit(**hints),\n   429\t                    self.args[2].doit(**hints))\n   430\t        else:\n   431\t            return self\n   432\t\n   433\t    def _eval_simplify(self, **kwargs):\n   434\t        return self\n   435\t\n   436\tclass Identity(MatrixExpr):\n   437\t    \"\"\"The Matrix Identity I - multiplicative identity\n   438\t\n   439\t    >>> from sympy.matrices import Identity, MatrixSymbol\n   440\t    >>> A = MatrixSymbol('A', 3, 5)\n   441\t    >>> I = Identity(3)\n   442\t    >>> I*A\n   443\t    A\n   444\t    \"\"\"\n   445\t\n   446\t    is_Identity = True\n   447\t\n   448\t    def __new__(cls, n):\n   449\t        return super(Identity, cls).__new__(cls, sympify(n))\n   450\t\n   451\t    @property\n   452\t    def rows(self):\n   453\t        return self.args[0]\n   454\t\n   455\t    @property\n   456\t    def cols(self):\n   457\t        return self.args[0]\n   458\t\n   459\t    @property\n   460\t    def shape(self):\n   461\t        return (self.args[0], self.args[0])\n   462\t\n   463\t    def _eval_transpose(self):\n   464\t        return self\n   465\t\n   466\t    def _eval_trace(self):\n   467\t        return self.rows\n   468\t\n   469\t    def _eval_inverse(self):\n   470\t        return self\n   471\t\n   472\t    def conjugate(self):\n   473\t        return self\n   474\t\n   475\t    def _entry(self, i, j, **kwargs):\n   476\t        eq = Eq(i, j)\n   477\t        if eq is S.true:\n   478\t            return S.One\n   479\t        elif eq is S.false:\n   480\t            return S.Zero\n   481\t        return KroneckerDelta(i, j)\n   482\t\n   483\t    def _eval_determinant(self):\n   484\t        return S.One\n   485\t\n   486\t\n   487\tclass ZeroMatrix(MatrixExpr):\n   488\t    \"\"\"The Matrix Zero 0 - additive identity\n   489\t\n   490\t    >>> from sympy import MatrixSymbol, ZeroMatrix\n   491\t    >>> A = MatrixSymbol('A', 3, 5)\n   492\t    >>> Z = ZeroMatrix(3, 5)\n   493\t    >>> A+Z\n   494\t    A\n   495\t    >>> Z*A.T\n   496\t    0\n   497\t    \"\"\"\n   498\t    is_ZeroMatrix = True\n   499\t\n   500\t    def __new__(cls, m, n):\n   501\t        return super(ZeroMatrix, cls).__new__(cls, m, n)\n   502\t\n   503\t    @property\n   504\t    def shape(self):\n   505\t        return (self.args[0], self.args[1])\n   506\t\n   507\t\n   508\t    @_sympifyit('other', NotImplemented)\n   509\t    @call_highest_priority('__rpow__')\n   510\t    def __pow__(self, other):\n   511\t        if other != 1 and not self.is_square:\n   512\t            raise ShapeError(\"Power of non-square matrix %s\" % self)\n   513\t        if other == 0:\n   514\t            return Identity(self.rows)\n   515\t        if other < 1:\n   516\t            raise ValueError(\"Matrix det == 0; not invertible.\")\n   517\t        return self\n   518\t\n   519\t    def _eval_transpose(self):\n   520\t        return ZeroMatrix(self.cols, self.rows)\n   521\t\n   522\t    def _eval_trace(self):\n   523\t        return S.Zero\n   524\t\n   525\t    def _eval_determinant(self):\n   526\t        return S.Zero\n   527\t\n   528\t    def conjugate(self):\n   529\t        return self\n   530\t\n   531\t    def _entry(self, i, j, **kwargs):\n   532\t        return S.Zero\n   533\t\n   534\t    def __nonzero__(self):\n   535\t        return False\n   536\t\n   537\t    __bool__ = __nonzero__\n   538\t\n   539\t\n   540\tdef matrix_symbols(expr):\n   541\t    return [sym for sym in expr.free_symbols if sym.is_Matrix]\n   542\t\n   543\tfrom .matmul import MatMul\n   544\tfrom .matadd import MatAdd\n   545\tfrom .matpow import MatPow\n   546\tfrom .transpose import Transpose\n   547\tfrom .inverse import Inverse\n   548\t\n", "path": "/tmp/tmpyjyraizy/sympy/sympy/matrices/expressions/matexpr.py", "prev_exist": true}, "action_id": "130e61c4-3ba5-4c82-b05f-6f3e6cfe5f6e"}