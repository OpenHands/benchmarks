{"kind": "ObservationEvent", "id": "512b0b47-e666-4ea8-ae79-ebb383e99e03", "timestamp": "2025-09-25T11:34:03.114605", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_01MAdpyDqh65LrcW8moD56kM", "observation": {"kind": "StrReplaceEditorObservation", "command": "create", "output": "File created successfully at: /tmp/tmpbx0kuhou/astropy/test_separable_standalone.py", "path": "/tmp/tmpbx0kuhou/astropy/test_separable_standalone.py", "prev_exist": false, "new_content": "#!/usr/bin/env python3\n\"\"\"\nStandalone test for the separability matrix issue.\nThis directly imports the separable module without going through astropy.__init__.\n\"\"\"\n\nimport sys\nimport os\nimport numpy as np\n\n# Add the astropy directory to the path\nsys.path.insert(0, '/tmp/tmpbx0kuhou/astropy')\n\n# Create minimal mock classes that match the interface expected by separable.py\nclass Model:\n    \"\"\"Minimal Model base class\"\"\"\n    def __init__(self, n_inputs=1, n_outputs=1, separable=True, name=None):\n        self.n_inputs = n_inputs\n        self.n_outputs = n_outputs\n        self.separable = separable\n        self.name = name or f\"Model({n_inputs}\u2192{n_outputs})\"\n        self.inputs = tuple(f\"x{i}\" for i in range(n_inputs))\n        self.outputs = tuple(f\"y{i}\" for i in range(n_outputs))\n    \n    def _calculate_separability_matrix(self):\n        return NotImplemented\n    \n    def __repr__(self):\n        return self.name\n\nclass CompoundModel(Model):\n    \"\"\"Minimal CompoundModel class\"\"\"\n    def __init__(self, op, left, right, name=None):\n        self.op = op\n        self.left = left\n        self.right = right\n        \n        if op == '&':\n            n_inputs = left.n_inputs + right.n_inputs\n            n_outputs = left.n_outputs + right.n_outputs\n        elif op == '|':\n            n_inputs = left.n_inputs\n            n_outputs = right.n_outputs\n        else:\n            raise ValueError(f\"Unsupported operator: {op}\")\n            \n        super().__init__(n_inputs, n_outputs, separable=True, \n                        name=name or f\"({left} {op} {right})\")\n    \n    def _calculate_separability_matrix(self):\n        return NotImplemented\n\nclass Linear1D(Model):\n    \"\"\"Mock Linear1D model\"\"\"\n    def __init__(self, slope, name=None):\n        super().__init__(1, 1, separable=True, name=name or f\"Linear1D({slope})\")\n        self.slope = slope\n\nclass Pix2Sky_TAN(Model):\n    \"\"\"Mock Pix2Sky_TAN model\"\"\"\n    def __init__(self, name=None):\n        super().__init__(2, 2, separable=False, name=name or \"Pix2Sky_TAN()\")\n\nclass ModelDefinitionError(Exception):\n    \"\"\"Mock ModelDefinitionError\"\"\"\n    pass\n\nclass Mapping(Model):\n    \"\"\"Mock Mapping model\"\"\"\n    def __init__(self, mapping, name=None):\n        self.mapping = mapping\n        n_inputs = max(mapping) + 1 if mapping else 0\n        n_outputs = len(mapping)\n        super().__init__(n_inputs, n_outputs, separable=True, \n                        name=name or f\"Mapping({mapping})\")\n\n# Mock the & operator\ndef mock_and_operator(left, right):\n    return CompoundModel('&', left, right)\n\n# Set up the mock models\nLinear1D.__and__ = mock_and_operator\nPix2Sky_TAN.__and__ = mock_and_operator\nCompoundModel.__and__ = mock_and_operator\n\n# Now patch the modules that separable.py will import\nimport astropy.modeling.core\nastropy.modeling.core.Model = Model\nastropy.modeling.core.CompoundModel = CompoundModel\nastropy.modeling.core.ModelDefinitionError = ModelDefinitionError\n\nimport astropy.modeling.mappings\nastropy.modeling.mappings.Mapping = Mapping\n\ndef test_separability_issue():\n    \"\"\"Test the separability matrix issue\"\"\"\n    print(\"Testing separability matrix issue with nested CompoundModels\")\n    print(\"=\" * 60)\n    \n    # Import the separable module directly\n    try:\n        from astropy.modeling.separable import separability_matrix, _separable\n        print(\"\u2713 Successfully imported separable module\")\n    except ImportError as e:\n        print(f\"\u2717 Failed to import separable module: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n    \n    # Create the models as described in the issue\n    print(\"\\n1. Creating simple compound model: cm = Linear1D(10) & Linear1D(5)\")\n    linear1 = Linear1D(10)\n    linear2 = Linear1D(5)\n    cm = linear1 & linear2\n    \n    print(f\"   cm = {cm}\")\n    print(f\"   cm.n_inputs = {cm.n_inputs}, cm.n_outputs = {cm.n_outputs}\")\n    \n    # Test separability matrix for simple compound model\n    print(\"\\n2. Testing separability matrix for simple compound model\")\n    try:\n        sep_matrix_cm = separability_matrix(cm)\n        print(f\"   separability_matrix(cm) =\")\n        print(f\"   {sep_matrix_cm}\")\n        \n        # Expected: diagonal matrix [[True, False], [False, True]]\n        expected_cm = np.array([[True, False], [False, True]])\n        if np.array_equal(sep_matrix_cm, expected_cm):\n            print(\"   \u2713 Simple compound model separability is correct\")\n        else:\n            print(\"   \u2717 Simple compound model separability is incorrect\")\n            print(f\"   Expected: {expected_cm}\")\n    except Exception as e:\n        print(f\"   \u2717 Error computing separability matrix for cm: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n    \n    # Create the more complex model\n    print(\"\\n3. Creating complex model: Pix2Sky_TAN() & Linear1D(10) & Linear1D(5)\")\n    pix2sky = Pix2Sky_TAN()\n    # Note: & is left-associative, so this is (pix2sky & linear1) & linear2\n    complex_model = pix2sky & linear1 & linear2\n    \n    print(f\"   complex_model = {complex_model}\")\n    print(f\"   complex_model.n_inputs = {complex_model.n_inputs}, complex_model.n_outputs = {complex_model.n_outputs}\")\n    \n    # Test separability matrix for complex model\n    print(\"\\n4. Testing separability matrix for complex model\")\n    try:\n        sep_matrix_complex = separability_matrix(complex_model)\n        print(f\"   separability_matrix(complex_model) =\")\n        print(f\"   {sep_matrix_complex}\")\n        \n        # Expected: block diagonal matrix\n        expected_complex = np.array([\n            [True, True, False, False],\n            [True, True, False, False],\n            [False, False, True, False],\n            [False, False, False, True]\n        ])\n        if np.array_equal(sep_matrix_complex, expected_complex):\n            print(\"   \u2713 Complex model separability is correct\")\n        else:\n            print(\"   \u2717 Complex model separability is incorrect\")\n            print(f\"   Expected:\\n{expected_complex}\")\n            print(f\"   Actual:\\n{sep_matrix_complex}\")\n    except Exception as e:\n        print(f\"   \u2717 Error computing separability matrix for complex_model: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n    \n    # Create the nested compound model (the problematic case)\n    print(\"\\n5. Creating nested compound model: Pix2Sky_TAN() & cm\")\n    nested_model = pix2sky & cm\n    \n    print(f\"   nested_model = {nested_model}\")\n    print(f\"   nested_model.n_inputs = {nested_model.n_inputs}, nested_model.n_outputs = {nested_model.n_outputs}\")\n    \n    # Test separability matrix for nested model\n    print(\"\\n6. Testing separability matrix for nested model (THE BUG)\")\n    try:\n        sep_matrix_nested = separability_matrix(nested_model)\n        print(f\"   separability_matrix(nested_model) =\")\n        print(f\"   {sep_matrix_nested}\")\n        \n        # Expected: same as complex model (block diagonal)\n        expected_nested = np.array([\n            [True, True, False, False],\n            [True, True, False, False],\n            [False, False, True, False],\n            [False, False, False, True]\n        ])\n        \n        if np.array_equal(sep_matrix_nested, expected_nested):\n            print(\"   \u2713 Nested model separability is correct\")\n            return True\n        else:\n            print(\"   \u2717 Nested model separability is INCORRECT - BUG REPRODUCED!\")\n            print(f\"   Expected:\\n{expected_nested}\")\n            print(f\"   Actual:\\n{sep_matrix_nested}\")\n            \n            # Show the difference\n            diff = sep_matrix_nested != expected_nested\n            if np.any(diff):\n                print(\"   Differences at positions:\")\n                for i, j in zip(*np.where(diff)):\n                    print(f\"     [{i},{j}]: got {sep_matrix_nested[i,j]}, expected {expected_nested[i,j]}\")\n            return False\n            \n    except Exception as e:\n        print(f\"   \u2717 Error computing separability matrix for nested_model: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\nif __name__ == \"__main__\":\n    success = test_separability_issue()\n    if success:\n        print(\"\\n\ud83c\udf89 All tests passed!\")\n        sys.exit(0)\n    else:\n        print(\"\\n\ud83d\udca5 Bug reproduced!\")\n        sys.exit(1)"}, "action_id": "8c555382-8a56-4066-8fe8-d2cbb7146a28"}