{"kind": "ObservationEvent", "id": "8295bff9-fdec-47ff-8b7d-9b6412c4619a", "timestamp": "2025-09-25T19:09:04.254634", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_016ja7cMqr8QwX26w3XmTEEu", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmpf25j40i4/sphinx/sphinx/ext/autodoc/typehints.py:\n     1\t\"\"\"\n     2\t    sphinx.ext.autodoc.typehints\n     3\t    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n     4\t\n     5\t    Generating content for autodoc using typehints\n     6\t\n     7\t    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n     8\t    :license: BSD, see LICENSE for details.\n     9\t\"\"\"\n    10\t\n    11\timport re\n    12\tfrom collections import OrderedDict\n    13\tfrom typing import Any, Dict, Iterable, cast\n    14\t\n    15\tfrom docutils import nodes\n    16\tfrom docutils.nodes import Element\n    17\t\n    18\tfrom sphinx import addnodes\n    19\tfrom sphinx.application import Sphinx\n    20\tfrom sphinx.util import inspect, typing\n    21\t\n    22\t\n    23\tdef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n    24\t                     options: Dict, args: str, retann: str) -> None:\n    25\t    \"\"\"Record type hints to env object.\"\"\"\n    26\t    try:\n    27\t        if callable(obj):\n    28\t            annotations = app.env.temp_data.setdefault('annotations', {})\n    29\t            annotation = annotations.setdefault(name, OrderedDict())\n    30\t            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n    31\t            for param in sig.parameters.values():\n    32\t                if param.annotation is not param.empty:\n    33\t                    annotation[param.name] = typing.stringify(param.annotation)\n    34\t            if sig.return_annotation is not sig.empty:\n    35\t                annotation['return'] = typing.stringify(sig.return_annotation)\n    36\t    except (TypeError, ValueError):\n    37\t        pass\n    38\t\n    39\t\n    40\tdef apply_type_aliases(annotation: str, type_aliases: Dict[str, str]) -> str:\n    41\t    \"\"\"Apply type aliases to a stringified type annotation.\"\"\"\n    42\t    if not type_aliases:\n    43\t        return annotation\n    44\t    \n    45\t    # Apply type aliases by replacing the type names\n    46\t    result = annotation\n    47\t    for alias, replacement in type_aliases.items():\n    48\t        result = result.replace(alias, replacement)\n    49\t    \n    50\t    return result\n    51\t\n    52\t\n    53\tdef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    54\t    if domain != 'py':\n    55\t        return\n    56\t    if app.config.autodoc_typehints != 'description':\n    57\t        return\n    58\t    if objtype == 'class' and app.config.autoclass_content not in ('init', 'both'):\n    59\t        return\n    60\t\n    61\t    try:\n    62\t        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n    63\t        if signature['module']:\n    64\t            fullname = '.'.join([signature['module'], signature['fullname']])\n    65\t        else:\n    66\t            fullname = signature['fullname']\n    67\t    except KeyError:\n    68\t        # signature node does not have valid context info for the target object\n    69\t        return\n    70\t\n    71\t    annotations = app.env.temp_data.get('annotations', {})\n    72\t    if annotations.get(fullname, {}):\n    73\t        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n    74\t        if field_lists == []:\n    75\t            field_list = insert_field_list(contentnode)\n    76\t            field_lists.append(field_list)\n    77\t\n    78\t        for field_list in field_lists:\n    79\t            modify_field_list(field_list, annotations[fullname], app.config.autodoc_type_aliases)\n    80\t\n    81\t\n    82\tdef insert_field_list(node: Element) -> nodes.field_list:\n    83\t    field_list = nodes.field_list()\n    84\t    desc = [n for n in node if isinstance(n, addnodes.desc)]\n    85\t    if desc:\n    86\t        # insert just before sub object descriptions (ex. methods, nested classes, etc.)\n    87\t        index = node.index(desc[0])\n    88\t        node.insert(index - 1, [field_list])\n    89\t    else:\n    90\t        node += field_list\n    91\t\n    92\t    return field_list\n    93\t\n    94\t\n    95\tdef modify_field_list(node: nodes.field_list, annotations: Dict[str, str], type_aliases: Dict[str, str]) -> None:\n    96\t    arguments = {}  # type: Dict[str, Dict[str, bool]]\n    97\t    fields = cast(Iterable[nodes.field], node)\n    98\t    for field in fields:\n    99\t        field_name = field[0].astext()\n   100\t        parts = re.split(' +', field_name)\n   101\t        if parts[0] == 'param':\n   102\t            if len(parts) == 2:\n   103\t                # :param xxx:\n   104\t                arg = arguments.setdefault(parts[1], {})\n   105\t                arg['param'] = True\n   106\t            elif len(parts) > 2:\n   107\t                # :param xxx yyy:\n   108\t                name = ' '.join(parts[2:])\n   109\t                arg = arguments.setdefault(name, {})\n   110\t                arg['param'] = True\n   111\t                arg['type'] = True\n   112\t        elif parts[0] == 'type':\n   113\t            name = ' '.join(parts[1:])\n   114\t            arg = arguments.setdefault(name, {})\n   115\t            arg['type'] = True\n   116\t        elif parts[0] == 'rtype':\n   117\t            arguments['return'] = {'type': True}\n   118\t\n   119\t    for name, annotation in annotations.items():\n   120\t        if name == 'return':\n   121\t            continue\n   122\t\n   123\t        arg = arguments.get(name, {})\n   124\t        if not arg.get('type'):\n   125\t            field = nodes.field()\n   126\t            field += nodes.field_name('', 'type ' + name)\n   127\t            field += nodes.field_body('', nodes.paragraph('', apply_type_aliases(annotation, type_aliases)))\n   128\t            node += field\n   129\t        if not arg.get('param'):\n   130\t            field = nodes.field()\n   131\t            field += nodes.field_name('', 'param ' + name)\n   132\t            field += nodes.field_body('', nodes.paragraph('', ''))\n   133\t            node += field\n   134\t\n   135\t    if 'return' in annotations and 'return' not in arguments:\n   136\t        field = nodes.field()\n   137\t        field += nodes.field_name('', 'rtype')\n   138\t        field += nodes.field_body('', nodes.paragraph('', apply_type_aliases(annotations['return'], type_aliases)))\n   139\t        node += field\n   140\t\n   141\t\n   142\tdef setup(app: Sphinx) -> Dict[str, Any]:\n   143\t    app.connect('autodoc-process-signature', record_typehints)\n   144\t    app.connect('object-description-transform', merge_typehints)\n   145\t\n   146\t    return {\n   147\t        'version': 'builtin',\n   148\t        'parallel_read_safe': True,\n   149\t        'parallel_write_safe': True,\n   150\t    }\n   151\t\n", "path": "/tmp/tmpf25j40i4/sphinx/sphinx/ext/autodoc/typehints.py", "prev_exist": true}, "action_id": "54b1e010-9638-48da-98fd-723bf977cd47"}