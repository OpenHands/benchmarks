{"kind": "ObservationEvent", "id": "a25bd34b-a044-4750-9a60-961daf5c67eb", "timestamp": "2025-09-25T11:26:43.588768", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_011qmxd7QADBUL51r7KymZcx", "observation": {"kind": "StrReplaceEditorObservation", "command": "str_replace", "output": "The file /tmp/tmpr5a8owwj/astropy/astropy/timeseries/tests/test_binned.py has been edited. Here's the result of running `cat -n` on a snippet of /tmp/tmpr5a8owwj/astropy/astropy/timeseries/tests/test_binned.py:\n    24\t\n    25\t    # Make sure things crash when the first column added is not a time column\n    26\t\n    27\t    ts = BinnedTimeSeries()\n    28\t    with pytest.raises(ValueError) as exc:\n    29\t        ts['flux'] = [1, 2, 3]\n    30\t    assert exc.value.args[0] == (\"BinnedTimeSeries object is invalid - required \"\n    31\t                                 \"column 'time_bin_start' is missing\")\n    32\t\n    33\t\n    34\tdef test_initialization_time_bin_invalid():\n    35\t\n    36\t\nReview the changes and make sure they are as expected. Edit the file again if necessary.", "path": "/tmp/tmpr5a8owwj/astropy/astropy/timeseries/tests/test_binned.py", "prev_exist": true, "old_content": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\nimport pytest\nfrom numpy.testing import assert_equal, assert_allclose\n\nfrom astropy import units as u\nfrom astropy.time import Time, TimeDelta\nfrom astropy.utils.data import get_pkg_data_filename\n\nfrom astropy.timeseries.periodograms import BoxLeastSquares, LombScargle\nfrom astropy.timeseries.binned import BinnedTimeSeries\nfrom astropy.tests.helper import assert_quantity_allclose\n\n\nCSV_FILE = get_pkg_data_filename('data/binned.csv')\n\n\ndef test_empty_initialization():\n    ts = BinnedTimeSeries()\n    ts['time_bin_start'] = Time([1, 2, 3], format='mjd')\n\n\ndef test_empty_initialization_invalid():\n\n    # Make sure things crash when the first column added is not a time column\n\n    ts = BinnedTimeSeries()\n    with pytest.raises(ValueError) as exc:\n        ts['flux'] = [1, 2, 3]\n    assert exc.value.args[0] == (\"BinnedTimeSeries object is invalid - expected \"\n                                 \"'time_bin_start' as the first column but found 'flux'\")\n\n\ndef test_initialization_time_bin_invalid():\n\n    # Make sure things crash when time_bin_* is passed incorrectly.\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data=[[1, 4, 3]])\n    assert exc.value.args[0] == (\"'time_bin_start' has not been specified\")\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31', data=[[1, 4, 3]])\n    assert exc.value.args[0] == (\"Either 'time_bin_size' or 'time_bin_end' should be specified\")\n\n\ndef test_initialization_time_bin_both():\n\n    # Make sure things crash when time_bin_* is passed twice.\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time_bin_start\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=\"2016-03-22T12:30:31\")\n    assert exc.value.args[0] == (\"'time_bin_start' has been given both in the table \"\n                                 \"and as a keyword argument\")\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time_bin_size\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_size=[1]*u.s)\n    assert exc.value.args[0] == (\"'time_bin_size' has been given both in the table \"\n                                 \"and as a keyword argument\")\n\n\ndef test_initialization_time_bin_size():\n\n    # Make sure things crash when time_bin_size has no units\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=\"2016-03-22T12:30:31\",\n                         time_bin_size=1)\n    assert exc.value.args[0] == (\"'time_bin_size' should be a Quantity or a TimeDelta\")\n\n    # TimeDelta for time_bin_size\n    ts = BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                          time_bin_start=\"2016-03-22T12:30:31\",\n                          time_bin_size=TimeDelta(1, format=\"jd\"))\n    assert isinstance(ts.time_bin_size, u.quantity.Quantity)\n\n\ndef test_initialization_time_bin_start_scalar():\n\n    # Make sure things crash when time_bin_start is a scalar with no time_bin_size\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=Time(1, format='mjd'),\n                         time_bin_end=Time(1, format='mjd'))\n    assert exc.value.args[0] == (\"'time_bin_start' is scalar, so 'time_bin_size' is required\")\n\n\ndef test_initialization_n_bins_invalid_arguments():\n\n    # Make sure an exception is raised when n_bins is passed as an argument while\n    # any of the parameters 'time_bin_start' or 'time_bin_end' is not scalar.\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(time_bin_start=Time([1, 2, 3], format='cxcsec'),\n                         time_bin_size=1*u.s,\n                         n_bins=10)\n    assert exc.value.args[0] == (\"'n_bins' cannot be specified if 'time_bin_start' or \"\n                                 \"'time_bin_size' are not scalar'\")\n\n\ndef test_initialization_n_bins():\n\n    # Make sure things crash with incorrect n_bins\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=Time(1, format='mjd'),\n                         time_bin_size=1*u.s,\n                         time_bin_end=Time(1, format='mjd'),\n                         n_bins=10)\n    assert exc.value.args[0] == (\"'n_bins' has been given and it is not the \"\n                                 \"same length as the input data.\")\n\n\ndef test_initialization_non_scalar_time():\n\n    # Make sure things crash with incorrect size of time_bin_start\n\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=[\"2016-03-22T12:30:31\", \"2016-03-22T12:30:32\"],\n                         time_bin_size=1*u.s,\n                         time_bin_end=Time(1, format='mjd'))\n    assert exc.value.args[0] == (\"Length of 'time_bin_start' (2) should match table length (1)\")\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=[\"2016-03-22T12:30:31\"],\n                         time_bin_size=None,\n                         time_bin_end=None)\n    assert exc.value.args[0] == (\"Either 'time_bin_size' or 'time_bin_end' should be specified\")\n\n\ndef test_even_contiguous():\n\n    # Initialize a ``BinnedTimeSeries`` with even contiguous bins by specifying\n    # the bin width:\n\n    ts = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31',\n                          time_bin_size=3 * u.s, data=[[1, 4, 3]])\n\n    assert_equal(ts.time_bin_start.isot, ['2016-03-22T12:30:31.000',\n                                          '2016-03-22T12:30:34.000',\n                                          '2016-03-22T12:30:37.000'])\n\n    assert_equal(ts.time_bin_center.isot, ['2016-03-22T12:30:32.500',\n                                           '2016-03-22T12:30:35.500',\n                                           '2016-03-22T12:30:38.500'])\n\n    assert_equal(ts.time_bin_end.isot, ['2016-03-22T12:30:34.000',\n                                        '2016-03-22T12:30:37.000',\n                                        '2016-03-22T12:30:40.000'])\n\n\ndef test_uneven_contiguous():\n\n    # Initialize a ``BinnedTimeSeries`` with uneven contiguous bins by giving an\n    # end time:\n\n    ts = BinnedTimeSeries(time_bin_start=['2016-03-22T12:30:31',\n                                          '2016-03-22T12:30:32',\n                                          '2016-03-22T12:30:40'],\n                          time_bin_end='2016-03-22T12:30:55',\n                          data=[[1, 4, 3]])\n\n    assert_equal(ts.time_bin_start.isot, ['2016-03-22T12:30:31.000',\n                                          '2016-03-22T12:30:32.000',\n                                          '2016-03-22T12:30:40.000'])\n\n    assert_equal(ts.time_bin_center.isot, ['2016-03-22T12:30:31.500',\n                                           '2016-03-22T12:30:36.000',\n                                           '2016-03-22T12:30:47.500'])\n\n    assert_equal(ts.time_bin_end.isot, ['2016-03-22T12:30:32.000',\n                                        '2016-03-22T12:30:40.000',\n                                        '2016-03-22T12:30:55.000'])\n\n\ndef test_uneven_non_contiguous():\n\n    # Initialize a ``BinnedTimeSeries`` with uneven non-contiguous bins with\n    # lists of start times, bin sizes and data:\n\n    ts = BinnedTimeSeries(time_bin_start=['2016-03-22T12:30:31',\n                                          '2016-03-22T12:30:38',\n                                          '2016-03-22T12:34:40'],\n                          time_bin_size=[5, 100, 2]*u.s,\n                          data=[[1, 4, 3]])\n\n    assert_equal(ts.time_bin_start.isot, ['2016-03-22T12:30:31.000',\n                                          '2016-03-22T12:30:38.000',\n                                          '2016-03-22T12:34:40.000'])\n\n    assert_equal(ts.time_bin_center.isot, ['2016-03-22T12:30:33.500',\n                                           '2016-03-22T12:31:28.000',\n                                           '2016-03-22T12:34:41.000'])\n\n    assert_equal(ts.time_bin_end.isot, ['2016-03-22T12:30:36.000',\n                                        '2016-03-22T12:32:18.000',\n                                        '2016-03-22T12:34:42.000'])\n\n\ndef test_uneven_non_contiguous_full():\n\n    # Initialize a ``BinnedTimeSeries`` with uneven non-contiguous bins by\n    # specifying the start and end times for the bins:\n\n    ts = BinnedTimeSeries(time_bin_start=['2016-03-22T12:30:31',\n                                          '2016-03-22T12:30:33',\n                                          '2016-03-22T12:30:40'],\n                          time_bin_end=['2016-03-22T12:30:32',\n                                        '2016-03-22T12:30:35',\n                                        '2016-03-22T12:30:41'],\n                          data=[[1, 4, 3]])\n\n    assert_equal(ts.time_bin_start.isot, ['2016-03-22T12:30:31.000',\n                                          '2016-03-22T12:30:33.000',\n                                          '2016-03-22T12:30:40.000'])\n\n    assert_equal(ts.time_bin_center.isot, ['2016-03-22T12:30:31.500',\n                                           '2016-03-22T12:30:34.000',\n                                           '2016-03-22T12:30:40.500'])\n\n    assert_equal(ts.time_bin_end.isot, ['2016-03-22T12:30:32.000',\n                                        '2016-03-22T12:30:35.000',\n                                        '2016-03-22T12:30:41.000'])\n\n\ndef test_read_empty():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, format='csv')\n    assert exc.value.args[0] == '``time_bin_start_column`` should be provided since the default Table readers are being used.'\n\n\ndef test_read_no_size_end():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', format='csv')\n    assert exc.value.args[0] == 'Either `time_bin_end_column` or `time_bin_size_column` should be provided.'\n\n\ndef test_read_both_extra_bins():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_end_column='END', time_bin_size_column='bin_size', format='csv')\n    assert exc.value.args[0] == \"Cannot specify both `time_bin_end_column` and `time_bin_size_column`.\"\n\n\ndef test_read_size_no_unit():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_size_column='bin_size', format='csv')\n    assert exc.value.args[0] == \"The bin size unit should be specified as an astropy Unit using ``time_bin_size_unit``.\"\n\n\ndef test_read_start_time_missing():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='abc', time_bin_size_column='bin_size', time_bin_size_unit=u.second, format='csv')\n    assert exc.value.args[0] == \"Bin start time column 'abc' not found in the input data.\"\n\n\ndef test_read_end_time_missing():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_end_column=\"missing\", format='csv')\n    assert exc.value.args[0] == \"Bin end time column 'missing' not found in the input data.\"\n\n\ndef test_read_size_missing():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_size_column=\"missing\", time_bin_size_unit=u.second, format='csv')\n    assert exc.value.args[0] == \"Bin size column 'missing' not found in the input data.\"\n\n\ndef test_read_time_unit_missing():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_size_column=\"bin_size\", format='csv')\n    assert exc.value.args[0] == \"The bin size unit should be specified as an astropy Unit using ``time_bin_size_unit``.\"\n\n\ndef test_read():\n\n    timeseries = BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start',\n                                       time_bin_end_column='time_end', format='csv')\n    assert timeseries.colnames == ['time_bin_start', 'time_bin_size', 'bin_size', 'A', 'B', 'C', 'D', 'E', 'F']\n    assert len(timeseries) == 10\n    assert timeseries['B'].sum() == 1151.54\n\n    timeseries = BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start',\n                                       time_bin_size_column='bin_size',\n                                       time_bin_size_unit=u.second, format='csv')\n    assert timeseries.colnames == ['time_bin_start', 'time_bin_size', 'time_end', 'A', 'B', 'C', 'D', 'E', 'F']\n    assert len(timeseries) == 10\n    assert timeseries['B'].sum() == 1151.54\n\n\n@pytest.mark.parametrize('cls', [BoxLeastSquares, LombScargle])\ndef test_periodogram(cls):\n\n    # Note that we don't need to check the actual results from the periodogram\n    # classes here since these are tested extensively in\n    # astropy.timeseries.periodograms.\n\n    ts = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31',\n                          time_bin_size=3 * u.s, data=[[1, 4, 3], [3, 4, 3]], names=['a', 'b'])\n\n    p1 = cls.from_timeseries(ts, 'a')\n    assert isinstance(p1, cls)\n    assert_allclose(p1.t.jd, ts.time_bin_center.jd)\n    assert_equal(p1.y, ts['a'])\n    assert p1.dy is None\n\n    p2 = cls.from_timeseries(ts, 'a', uncertainty='b')\n    assert_quantity_allclose(p2.dy, ts['b'])\n\n    p3 = cls.from_timeseries(ts, 'a', uncertainty=0.1)\n    assert_allclose(p3.dy, 0.1)\n", "new_content": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\nimport pytest\nfrom numpy.testing import assert_equal, assert_allclose\n\nfrom astropy import units as u\nfrom astropy.time import Time, TimeDelta\nfrom astropy.utils.data import get_pkg_data_filename\n\nfrom astropy.timeseries.periodograms import BoxLeastSquares, LombScargle\nfrom astropy.timeseries.binned import BinnedTimeSeries\nfrom astropy.tests.helper import assert_quantity_allclose\n\n\nCSV_FILE = get_pkg_data_filename('data/binned.csv')\n\n\ndef test_empty_initialization():\n    ts = BinnedTimeSeries()\n    ts['time_bin_start'] = Time([1, 2, 3], format='mjd')\n\n\ndef test_empty_initialization_invalid():\n\n    # Make sure things crash when the first column added is not a time column\n\n    ts = BinnedTimeSeries()\n    with pytest.raises(ValueError) as exc:\n        ts['flux'] = [1, 2, 3]\n    assert exc.value.args[0] == (\"BinnedTimeSeries object is invalid - required \"\n                                 \"column 'time_bin_start' is missing\")\n\n\ndef test_initialization_time_bin_invalid():\n\n    # Make sure things crash when time_bin_* is passed incorrectly.\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data=[[1, 4, 3]])\n    assert exc.value.args[0] == (\"'time_bin_start' has not been specified\")\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31', data=[[1, 4, 3]])\n    assert exc.value.args[0] == (\"Either 'time_bin_size' or 'time_bin_end' should be specified\")\n\n\ndef test_initialization_time_bin_both():\n\n    # Make sure things crash when time_bin_* is passed twice.\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time_bin_start\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=\"2016-03-22T12:30:31\")\n    assert exc.value.args[0] == (\"'time_bin_start' has been given both in the table \"\n                                 \"and as a keyword argument\")\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time_bin_size\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_size=[1]*u.s)\n    assert exc.value.args[0] == (\"'time_bin_size' has been given both in the table \"\n                                 \"and as a keyword argument\")\n\n\ndef test_initialization_time_bin_size():\n\n    # Make sure things crash when time_bin_size has no units\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=\"2016-03-22T12:30:31\",\n                         time_bin_size=1)\n    assert exc.value.args[0] == (\"'time_bin_size' should be a Quantity or a TimeDelta\")\n\n    # TimeDelta for time_bin_size\n    ts = BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                          time_bin_start=\"2016-03-22T12:30:31\",\n                          time_bin_size=TimeDelta(1, format=\"jd\"))\n    assert isinstance(ts.time_bin_size, u.quantity.Quantity)\n\n\ndef test_initialization_time_bin_start_scalar():\n\n    # Make sure things crash when time_bin_start is a scalar with no time_bin_size\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=Time(1, format='mjd'),\n                         time_bin_end=Time(1, format='mjd'))\n    assert exc.value.args[0] == (\"'time_bin_start' is scalar, so 'time_bin_size' is required\")\n\n\ndef test_initialization_n_bins_invalid_arguments():\n\n    # Make sure an exception is raised when n_bins is passed as an argument while\n    # any of the parameters 'time_bin_start' or 'time_bin_end' is not scalar.\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(time_bin_start=Time([1, 2, 3], format='cxcsec'),\n                         time_bin_size=1*u.s,\n                         n_bins=10)\n    assert exc.value.args[0] == (\"'n_bins' cannot be specified if 'time_bin_start' or \"\n                                 \"'time_bin_size' are not scalar'\")\n\n\ndef test_initialization_n_bins():\n\n    # Make sure things crash with incorrect n_bins\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=Time(1, format='mjd'),\n                         time_bin_size=1*u.s,\n                         time_bin_end=Time(1, format='mjd'),\n                         n_bins=10)\n    assert exc.value.args[0] == (\"'n_bins' has been given and it is not the \"\n                                 \"same length as the input data.\")\n\n\ndef test_initialization_non_scalar_time():\n\n    # Make sure things crash with incorrect size of time_bin_start\n\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=[\"2016-03-22T12:30:31\", \"2016-03-22T12:30:32\"],\n                         time_bin_size=1*u.s,\n                         time_bin_end=Time(1, format='mjd'))\n    assert exc.value.args[0] == (\"Length of 'time_bin_start' (2) should match table length (1)\")\n\n    with pytest.raises(TypeError) as exc:\n        BinnedTimeSeries(data={\"time\": [\"2016-03-22T12:30:31\"]},\n                         time_bin_start=[\"2016-03-22T12:30:31\"],\n                         time_bin_size=None,\n                         time_bin_end=None)\n    assert exc.value.args[0] == (\"Either 'time_bin_size' or 'time_bin_end' should be specified\")\n\n\ndef test_even_contiguous():\n\n    # Initialize a ``BinnedTimeSeries`` with even contiguous bins by specifying\n    # the bin width:\n\n    ts = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31',\n                          time_bin_size=3 * u.s, data=[[1, 4, 3]])\n\n    assert_equal(ts.time_bin_start.isot, ['2016-03-22T12:30:31.000',\n                                          '2016-03-22T12:30:34.000',\n                                          '2016-03-22T12:30:37.000'])\n\n    assert_equal(ts.time_bin_center.isot, ['2016-03-22T12:30:32.500',\n                                           '2016-03-22T12:30:35.500',\n                                           '2016-03-22T12:30:38.500'])\n\n    assert_equal(ts.time_bin_end.isot, ['2016-03-22T12:30:34.000',\n                                        '2016-03-22T12:30:37.000',\n                                        '2016-03-22T12:30:40.000'])\n\n\ndef test_uneven_contiguous():\n\n    # Initialize a ``BinnedTimeSeries`` with uneven contiguous bins by giving an\n    # end time:\n\n    ts = BinnedTimeSeries(time_bin_start=['2016-03-22T12:30:31',\n                                          '2016-03-22T12:30:32',\n                                          '2016-03-22T12:30:40'],\n                          time_bin_end='2016-03-22T12:30:55',\n                          data=[[1, 4, 3]])\n\n    assert_equal(ts.time_bin_start.isot, ['2016-03-22T12:30:31.000',\n                                          '2016-03-22T12:30:32.000',\n                                          '2016-03-22T12:30:40.000'])\n\n    assert_equal(ts.time_bin_center.isot, ['2016-03-22T12:30:31.500',\n                                           '2016-03-22T12:30:36.000',\n                                           '2016-03-22T12:30:47.500'])\n\n    assert_equal(ts.time_bin_end.isot, ['2016-03-22T12:30:32.000',\n                                        '2016-03-22T12:30:40.000',\n                                        '2016-03-22T12:30:55.000'])\n\n\ndef test_uneven_non_contiguous():\n\n    # Initialize a ``BinnedTimeSeries`` with uneven non-contiguous bins with\n    # lists of start times, bin sizes and data:\n\n    ts = BinnedTimeSeries(time_bin_start=['2016-03-22T12:30:31',\n                                          '2016-03-22T12:30:38',\n                                          '2016-03-22T12:34:40'],\n                          time_bin_size=[5, 100, 2]*u.s,\n                          data=[[1, 4, 3]])\n\n    assert_equal(ts.time_bin_start.isot, ['2016-03-22T12:30:31.000',\n                                          '2016-03-22T12:30:38.000',\n                                          '2016-03-22T12:34:40.000'])\n\n    assert_equal(ts.time_bin_center.isot, ['2016-03-22T12:30:33.500',\n                                           '2016-03-22T12:31:28.000',\n                                           '2016-03-22T12:34:41.000'])\n\n    assert_equal(ts.time_bin_end.isot, ['2016-03-22T12:30:36.000',\n                                        '2016-03-22T12:32:18.000',\n                                        '2016-03-22T12:34:42.000'])\n\n\ndef test_uneven_non_contiguous_full():\n\n    # Initialize a ``BinnedTimeSeries`` with uneven non-contiguous bins by\n    # specifying the start and end times for the bins:\n\n    ts = BinnedTimeSeries(time_bin_start=['2016-03-22T12:30:31',\n                                          '2016-03-22T12:30:33',\n                                          '2016-03-22T12:30:40'],\n                          time_bin_end=['2016-03-22T12:30:32',\n                                        '2016-03-22T12:30:35',\n                                        '2016-03-22T12:30:41'],\n                          data=[[1, 4, 3]])\n\n    assert_equal(ts.time_bin_start.isot, ['2016-03-22T12:30:31.000',\n                                          '2016-03-22T12:30:33.000',\n                                          '2016-03-22T12:30:40.000'])\n\n    assert_equal(ts.time_bin_center.isot, ['2016-03-22T12:30:31.500',\n                                           '2016-03-22T12:30:34.000',\n                                           '2016-03-22T12:30:40.500'])\n\n    assert_equal(ts.time_bin_end.isot, ['2016-03-22T12:30:32.000',\n                                        '2016-03-22T12:30:35.000',\n                                        '2016-03-22T12:30:41.000'])\n\n\ndef test_read_empty():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, format='csv')\n    assert exc.value.args[0] == '``time_bin_start_column`` should be provided since the default Table readers are being used.'\n\n\ndef test_read_no_size_end():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', format='csv')\n    assert exc.value.args[0] == 'Either `time_bin_end_column` or `time_bin_size_column` should be provided.'\n\n\ndef test_read_both_extra_bins():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_end_column='END', time_bin_size_column='bin_size', format='csv')\n    assert exc.value.args[0] == \"Cannot specify both `time_bin_end_column` and `time_bin_size_column`.\"\n\n\ndef test_read_size_no_unit():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_size_column='bin_size', format='csv')\n    assert exc.value.args[0] == \"The bin size unit should be specified as an astropy Unit using ``time_bin_size_unit``.\"\n\n\ndef test_read_start_time_missing():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='abc', time_bin_size_column='bin_size', time_bin_size_unit=u.second, format='csv')\n    assert exc.value.args[0] == \"Bin start time column 'abc' not found in the input data.\"\n\n\ndef test_read_end_time_missing():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_end_column=\"missing\", format='csv')\n    assert exc.value.args[0] == \"Bin end time column 'missing' not found in the input data.\"\n\n\ndef test_read_size_missing():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_size_column=\"missing\", time_bin_size_unit=u.second, format='csv')\n    assert exc.value.args[0] == \"Bin size column 'missing' not found in the input data.\"\n\n\ndef test_read_time_unit_missing():\n    with pytest.raises(ValueError) as exc:\n        BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start', time_bin_size_column=\"bin_size\", format='csv')\n    assert exc.value.args[0] == \"The bin size unit should be specified as an astropy Unit using ``time_bin_size_unit``.\"\n\n\ndef test_read():\n\n    timeseries = BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start',\n                                       time_bin_end_column='time_end', format='csv')\n    assert timeseries.colnames == ['time_bin_start', 'time_bin_size', 'bin_size', 'A', 'B', 'C', 'D', 'E', 'F']\n    assert len(timeseries) == 10\n    assert timeseries['B'].sum() == 1151.54\n\n    timeseries = BinnedTimeSeries.read(CSV_FILE, time_bin_start_column='time_start',\n                                       time_bin_size_column='bin_size',\n                                       time_bin_size_unit=u.second, format='csv')\n    assert timeseries.colnames == ['time_bin_start', 'time_bin_size', 'time_end', 'A', 'B', 'C', 'D', 'E', 'F']\n    assert len(timeseries) == 10\n    assert timeseries['B'].sum() == 1151.54\n\n\n@pytest.mark.parametrize('cls', [BoxLeastSquares, LombScargle])\ndef test_periodogram(cls):\n\n    # Note that we don't need to check the actual results from the periodogram\n    # classes here since these are tested extensively in\n    # astropy.timeseries.periodograms.\n\n    ts = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31',\n                          time_bin_size=3 * u.s, data=[[1, 4, 3], [3, 4, 3]], names=['a', 'b'])\n\n    p1 = cls.from_timeseries(ts, 'a')\n    assert isinstance(p1, cls)\n    assert_allclose(p1.t.jd, ts.time_bin_center.jd)\n    assert_equal(p1.y, ts['a'])\n    assert p1.dy is None\n\n    p2 = cls.from_timeseries(ts, 'a', uncertainty='b')\n    assert_quantity_allclose(p2.dy, ts['b'])\n\n    p3 = cls.from_timeseries(ts, 'a', uncertainty=0.1)\n    assert_allclose(p3.dy, 0.1)\n"}, "action_id": "48723280-a31c-4ff4-95f0-da695d238220"}