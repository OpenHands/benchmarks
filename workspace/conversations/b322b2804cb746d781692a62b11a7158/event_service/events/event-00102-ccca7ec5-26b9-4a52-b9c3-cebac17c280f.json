{"kind": "ObservationEvent", "id": "ccca7ec5-26b9-4a52-b9c3-cebac17c280f", "timestamp": "2025-09-25T11:25:39.188765", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_011q147N2iSsxiVxpfG1ZJ2g", "observation": {"kind": "StrReplaceEditorObservation", "command": "str_replace", "output": "The file /tmp/tmpr5a8owwj/astropy/astropy/timeseries/tests/test_sampled.py has been edited. Here's the result of running `cat -n` on a snippet of /tmp/tmpr5a8owwj/astropy/astropy/timeseries/tests/test_sampled.py:\n   380\t    assert exc.value.args[0] == (\"TimeSeries object is invalid - required \"\n   381\t                                 \"column 'time' is missing\")\n   382\t\n   383\t    with pytest.raises(ValueError) as exc:\n   384\t        ts.copy().remove_column('time')\n   385\t    assert exc.value.args[0] == (\"TimeSeries object is invalid - required \"\n   386\t                                 \"column 'time' is missing\")\n   387\t\n   388\t    with pytest.raises(ValueError) as exc:\n   389\t        ts.copy().remove_columns(['time', 'a'])\n   390\t    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n   391\t\nReview the changes and make sure they are as expected. Edit the file again if necessary.", "path": "/tmp/tmpr5a8owwj/astropy/astropy/timeseries/tests/test_sampled.py", "prev_exist": true, "old_content": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\nfrom datetime import datetime\n\nimport pytest\n\nfrom numpy.testing import assert_equal, assert_allclose\n\nfrom astropy.table import Table, Column\nfrom astropy.time import Time, TimeDelta\nfrom astropy import units as u\nfrom astropy.units import Quantity\nfrom astropy.utils.data import get_pkg_data_filename\nfrom astropy.tests.helper import assert_quantity_allclose\n\nfrom astropy.timeseries.periodograms import BoxLeastSquares, LombScargle\nfrom astropy.timeseries.sampled import TimeSeries\n\nINPUT_TIME = Time(['2016-03-22T12:30:31',\n                   '2015-01-21T12:30:32',\n                   '2016-03-22T12:30:40'])\nPLAIN_TABLE = Table([[1, 2, 11], [3, 4, 1], [1, 1, 1]], names=['a', 'b', 'c'])\n\nCSV_FILE = get_pkg_data_filename('data/sampled.csv')\n\n\ndef test_empty_initialization():\n    ts = TimeSeries()\n    ts['time'] = Time([50001, 50002, 50003], format='mjd')\n\n\ndef test_empty_initialization_invalid():\n    # Make sure things crash when the first column added is not a time column\n    ts = TimeSeries()\n    with pytest.raises(ValueError) as exc:\n        ts['flux'] = [1, 2, 3]\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'flux'\")\n\n\ndef test_initialize_only_time():\n    ts = TimeSeries(time=INPUT_TIME)\n    assert ts['time'] is ts.time\n    # NOTE: the object in the table is a copy\n    assert_equal(ts.time.isot, INPUT_TIME.isot)\n\n\ndef test_initialization_with_data():\n    ts = TimeSeries(time=INPUT_TIME, data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert_equal(ts.time.isot, INPUT_TIME.isot)\n    assert_equal(ts['a'], [10, 2, 3])\n    assert_equal(ts['b'], [4, 5, 6])\n\n\ndef test_initialize_only_data():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert exc.value.args[0] == \"Either 'time' or 'time_start' should be specified\"\n\n\ndef test_initialization_with_table():\n    ts = TimeSeries(time=INPUT_TIME, data=PLAIN_TABLE)\n    assert ts.colnames == ['time', 'a', 'b', 'c']\n\n\ndef test_initialization_with_time_delta():\n    ts = TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n                    time_delta=TimeDelta(3, format='sec'),\n                    data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert_equal(ts.time.isot, ['2018-07-01T10:10:10.000',\n                                '2018-07-01T10:10:13.000',\n                                '2018-07-01T10:10:16.000'])\n\n\ndef test_initialization_missing_time_delta():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert exc.value.args[0] == \"'time' is scalar, so 'time_delta' is required\"\n\n\ndef test_initialization_invalid_time_and_time_start():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time=INPUT_TIME, time_start=datetime(2018, 7, 1, 10, 10, 10),\n                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert exc.value.args[0] == \"Cannot specify both 'time' and 'time_start'\"\n\n\ndef test_initialization_invalid_time_delta():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n                   time_delta=[1, 4, 3],\n                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert exc.value.args[0] == \"'time_delta' should be a Quantity or a TimeDelta\"\n\n\ndef test_initialization_with_time_in_data():\n\n    data = PLAIN_TABLE.copy()\n    data['time'] = INPUT_TIME\n\n    ts1 = TimeSeries(data=data)\n\n    assert set(ts1.colnames) == set(['time', 'a', 'b', 'c'])\n    assert all(ts1.time == INPUT_TIME)\n\n    ts2 = TimeSeries(data=[[10, 2, 3], INPUT_TIME], names=['a', 'time'])\n    assert set(ts2.colnames) == set(['time', 'a'])\n    assert all(ts2.time == INPUT_TIME)\n\n    with pytest.raises(TypeError) as exc:\n        # Don't allow ambiguous cases of passing multiple 'time' columns\n        TimeSeries(data=data, time=INPUT_TIME)\n    assert exc.value.args[0] == \"'time' has been given both in the table and as a keyword argument\"\n\n    with pytest.raises(TypeError) as exc:\n        # 'time' is a protected name, don't allow ambiguous cases\n        TimeSeries(time=INPUT_TIME, data=[[10, 2, 3], INPUT_TIME], names=['a', 'time'])\n    assert exc.value.args[0] == \"'time' has been given both in the table and as a keyword argument\"\n\n\ndef test_initialization_n_samples():\n\n    # Make sure things crash with incorrect n_samples\n\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time=INPUT_TIME, data=PLAIN_TABLE, n_samples=1000)\n    assert exc.value.args[0] == (\"'n_samples' has been given both and it is not the \"\n                                 \"same length as the input data.\")\n\n\ndef test_initialization_length_mismatch():\n    with pytest.raises(ValueError) as exc:\n        TimeSeries(time=INPUT_TIME, data=[[10, 2], [4, 5]], names=['a', 'b'])\n    assert exc.value.args[0] == \"Length of 'time' (3) should match data length (2)\"\n\n\ndef test_initialization_invalid_both_time_and_time_delta():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time=INPUT_TIME, time_delta=TimeDelta(3, format='sec'))\n    assert exc.value.args[0] == (\"'time_delta' should not be specified since \"\n                                 \"'time' is an array\")\n\n\ndef test_fold():\n\n    times = Time([1, 2, 3, 8, 9, 12], format='unix')\n\n    ts = TimeSeries(time=times)\n    ts['flux'] = [1, 4, 4, 3, 2, 3]\n\n    # Try without epoch time, as it should default to the first time and\n    # wrapping at half the period.\n    tsf = ts.fold(period=3.2 * u.s)\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [0, 1, -1.2, 0.6, -1.6, 1.4], rtol=1e-6)\n\n    # Try with epoch time\n    tsf = ts.fold(period=3.2 * u.s, epoch_time=Time(1.6, format='unix'))\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [-0.6, 0.4, 1.4, 0.0, 1.0, 0.8], rtol=1e-6, atol=1e-6)\n\n    # Now with wrap_phase set to the full period\n    tsf = ts.fold(period=3.2 * u.s, wrap_phase=3.2 * u.s)\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [0, 1, 2, 0.6, 1.6, 1.4], rtol=1e-6)\n\n    # Now set epoch_phase to be 1/4 of the way through the phase\n    tsf = ts.fold(period=3.2 * u.s, epoch_phase=0.8 * u.s)\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [0.8, -1.4, -0.4, 1.4, -0.8, -1.0], rtol=1e-6)\n\n    # And combining epoch_phase and wrap_phase\n    tsf = ts.fold(period=3.2 * u.s, epoch_phase=0.8 * u.s, wrap_phase=3.2 * u.s)\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [0.8, 1.8, 2.8, 1.4, 2.4, 2.2], rtol=1e-6)\n\n    # Now repeat the above tests but with normalization applied\n\n    # Try without epoch time, as it should default to the first time and\n    # wrapping at half the period.\n    tsf = ts.fold(period=3.2 * u.s, normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [0, 1/3.2, -1.2/3.2, 0.6/3.2, -1.6/3.2, 1.4/3.2],\n                    rtol=1e-6)\n\n    # Try with epoch time\n    tsf = ts.fold(period=3.2 * u.s, epoch_time=Time(1.6, format='unix'),\n                  normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [-0.6/3.2, 0.4/3.2, 1.4/3.2, 0.0/3.2, 1.0/3.2, 0.8/3.2],\n                    rtol=1e-6, atol=1e-6)\n\n    # Now with wrap_phase set to the full period\n    tsf = ts.fold(period=3.2 * u.s, wrap_phase=1, normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [0, 1/3.2, 2/3.2, 0.6/3.2, 1.6/3.2, 1.4/3.2],\n                    rtol=1e-6)\n\n    # Now set epoch_phase to be 1/4 of the way through the phase\n    tsf = ts.fold(period=3.2 * u.s, epoch_phase=0.25, normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [0.8/3.2, -1.4/3.2, -0.4/3.2, 1.4/3.2, -0.8/3.2, -1.0/3.2],\n                    rtol=1e-6)\n\n    # And combining epoch_phase and wrap_phase\n    tsf = ts.fold(period=3.2 * u.s, epoch_phase=0.25, wrap_phase=1,\n                  normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [0.8/3.2, 1.8/3.2, 2.8/3.2, 1.4/3.2, 2.4/3.2, 2.2/3.2],\n                    rtol=1e-6)\n\n\ndef test_fold_invalid_options():\n\n    times = Time([1, 2, 3, 8, 9, 12], format='unix')\n\n    ts = TimeSeries(time=times)\n    ts['flux'] = [1, 4, 4, 3, 2, 3]\n\n    with pytest.raises(u.UnitsError,\n                       match='period should be a Quantity in units of time'):\n        ts.fold(period=3.2)\n\n    with pytest.raises(u.UnitsError,\n                       match='period should be a Quantity in units of time'):\n        ts.fold(period=3.2 * u.m)\n\n    with pytest.raises(u.UnitsError,\n                       match='epoch_phase should be a Quantity in units of '\n                             'time when normalize_phase=False'):\n        ts.fold(period=3.2 * u.s, epoch_phase=0.2)\n\n    with pytest.raises(u.UnitsError,\n                       match='epoch_phase should be a dimensionless Quantity '\n                             'or a float when normalize_phase=True'):\n        ts.fold(period=3.2 * u.s, epoch_phase=0.2 * u.s, normalize_phase=True)\n\n    with pytest.raises(u.UnitsError,\n                       match='wrap_phase should be a Quantity in units of '\n                             'time when normalize_phase=False'):\n        ts.fold(period=3.2 * u.s, wrap_phase=0.2)\n\n    with pytest.raises(u.UnitsError,\n                       match='wrap_phase should be dimensionless when '\n                             'normalize_phase=True'):\n        ts.fold(period=3.2 * u.s, wrap_phase=0.2 * u.s, normalize_phase=True)\n\n    with pytest.raises(ValueError,\n                       match='wrap_phase should be between 0 and the period'):\n        ts.fold(period=3.2 * u.s, wrap_phase=-0.1 * u.s)\n\n    with pytest.raises(ValueError,\n                       match='wrap_phase should be between 0 and the period'):\n        ts.fold(period=3.2 * u.s, wrap_phase=-4.2 * u.s)\n\n    with pytest.raises(ValueError,\n                       match='wrap_phase should be between 0 and 1'):\n        ts.fold(period=3.2 * u.s, wrap_phase=-0.1, normalize_phase=True)\n\n    with pytest.raises(ValueError,\n                       match='wrap_phase should be between 0 and 1'):\n        ts.fold(period=3.2 * u.s, wrap_phase=2.2, normalize_phase=True)\n\n\ndef test_pandas():\n    pandas = pytest.importorskip(\"pandas\")\n\n    df1 = pandas.DataFrame()\n    df1['a'] = [1, 2, 3]\n    df1.set_index(pandas.DatetimeIndex(INPUT_TIME.datetime64), inplace=True)\n\n    ts = TimeSeries.from_pandas(df1)\n    assert_equal(ts.time.isot, INPUT_TIME.isot)\n    assert ts.colnames == ['time', 'a']\n    assert len(ts.indices) == 1\n    assert (ts.indices['time'].columns[0] == INPUT_TIME).all()\n\n    ts_tcb = TimeSeries.from_pandas(df1, time_scale='tcb')\n    assert ts_tcb.time.scale == 'tcb'\n\n    df2 = ts.to_pandas()\n    assert (df2.index.values == pandas.Index(INPUT_TIME.datetime64).values).all()\n    assert df2.columns == pandas.Index(['a'])\n    assert (df1['a'] == df2['a']).all()\n\n    with pytest.raises(TypeError) as exc:\n        TimeSeries.from_pandas(None)\n    assert exc.value.args[0] == 'Input should be a pandas DataFrame'\n\n    df4 = pandas.DataFrame()\n    df4['a'] = [1, 2, 3]\n\n    with pytest.raises(TypeError) as exc:\n        TimeSeries.from_pandas(df4)\n    assert exc.value.args[0] == 'DataFrame does not have a DatetimeIndex'\n\n\ndef test_read_time_missing():\n    with pytest.raises(ValueError) as exc:\n        TimeSeries.read(CSV_FILE, format='csv')\n    assert exc.value.args[0] == '``time_column`` should be provided since the default Table readers are being used.'\n\n\ndef test_read_time_wrong():\n    with pytest.raises(ValueError) as exc:\n        TimeSeries.read(CSV_FILE, time_column='abc', format='csv')\n    assert exc.value.args[0] == \"Time column 'abc' not found in the input data.\"\n\n\ndef test_read():\n    timeseries = TimeSeries.read(CSV_FILE, time_column='Date', format='csv')\n    assert timeseries.colnames == ['time', 'A', 'B', 'C', 'D', 'E', 'F', 'G']\n    assert len(timeseries) == 11\n    assert timeseries['time'].format == 'iso'\n    assert timeseries['A'].sum() == 266.5\n\n\n@pytest.mark.remote_data(source='astropy')\ndef test_kepler_astropy():\n    from astropy.units import UnitsWarning\n\n    filename = get_pkg_data_filename('timeseries/kplr010666592-2009131110544_slc.fits')\n\n    with pytest.warns(UnitsWarning):\n        timeseries = TimeSeries.read(filename, format='kepler.fits')\n\n    assert timeseries[\"time\"].format == 'isot'\n    assert timeseries[\"time\"].scale == 'tdb'\n    assert timeseries[\"sap_flux\"].unit.to_string() == 'electron / s'\n    assert len(timeseries) == 14280\n    assert len(timeseries.columns) == 20\n\n\n@pytest.mark.remote_data(source='astropy')\ndef test_tess_astropy():\n    filename = get_pkg_data_filename('timeseries/hlsp_tess-data-alerts_tess_phot_00025155310-s01_tess_v1_lc.fits')\n    with pytest.warns(UserWarning, match='Ignoring 815 rows with NaN times'):\n        timeseries = TimeSeries.read(filename, format='tess.fits')\n    assert timeseries[\"time\"].format == 'isot'\n    assert timeseries[\"time\"].scale == 'tdb'\n    assert timeseries[\"sap_flux\"].unit.to_string() == 'electron / s'\n    assert len(timeseries) == 19261\n    assert len(timeseries.columns) == 20\n\n\ndef test_required_columns():\n\n    # Test the machinery that makes sure that the required columns are present\n\n    ts = TimeSeries(time=INPUT_TIME,\n                    data=[[10, 2, 3], [4, 5, 6]],\n                    names=['a', 'b'])\n\n    # In the examples below, the operation (e.g. remove_column) is actually\n    # carried out before the checks are made, so we need to use copy() so that\n    # we don't change the main version of the time series.\n\n    # Make sure copy works fine\n    ts.copy()\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().add_column(Column([3, 4, 5], name='c'), index=0)\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'c'\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().add_columns([Column([3, 4, 5], name='d'),\n                               Column([3, 4, 5], name='e')], indexes=[0, 1])\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'd'\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().keep_columns(['a', 'b'])\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - required \"\n                                 \"column 'time' is missing\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().remove_column('time')\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'a'\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().remove_columns(['time', 'a'])\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'b'\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().rename_column('time', 'banana')\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'banana'\")\n\n\n@pytest.mark.parametrize('cls', [BoxLeastSquares, LombScargle])\ndef test_periodogram(cls):\n\n    # Note that we don't need to check the actual results from the periodogram\n    # classes here since these are tested extensively in\n    # astropy.timeseries.periodograms.\n\n    ts = TimeSeries(time=INPUT_TIME,\n                    data=[[10, 2, 3], [4, 5, 6]],\n                    names=['a', 'b'])\n\n    p1 = cls.from_timeseries(ts, 'a')\n    assert isinstance(p1, cls)\n    assert_allclose(p1.t.jd, ts.time.jd)\n    assert_equal(p1.y, ts['a'])\n    assert p1.dy is None\n\n    p2 = cls.from_timeseries(ts, 'a', uncertainty='b')\n    assert_quantity_allclose(p2.dy, ts['b'])\n\n    p3 = cls.from_timeseries(ts, 'a', uncertainty=0.1)\n    assert_allclose(p3.dy, 0.1)\n", "new_content": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\nfrom datetime import datetime\n\nimport pytest\n\nfrom numpy.testing import assert_equal, assert_allclose\n\nfrom astropy.table import Table, Column\nfrom astropy.time import Time, TimeDelta\nfrom astropy import units as u\nfrom astropy.units import Quantity\nfrom astropy.utils.data import get_pkg_data_filename\nfrom astropy.tests.helper import assert_quantity_allclose\n\nfrom astropy.timeseries.periodograms import BoxLeastSquares, LombScargle\nfrom astropy.timeseries.sampled import TimeSeries\n\nINPUT_TIME = Time(['2016-03-22T12:30:31',\n                   '2015-01-21T12:30:32',\n                   '2016-03-22T12:30:40'])\nPLAIN_TABLE = Table([[1, 2, 11], [3, 4, 1], [1, 1, 1]], names=['a', 'b', 'c'])\n\nCSV_FILE = get_pkg_data_filename('data/sampled.csv')\n\n\ndef test_empty_initialization():\n    ts = TimeSeries()\n    ts['time'] = Time([50001, 50002, 50003], format='mjd')\n\n\ndef test_empty_initialization_invalid():\n    # Make sure things crash when the first column added is not a time column\n    ts = TimeSeries()\n    with pytest.raises(ValueError) as exc:\n        ts['flux'] = [1, 2, 3]\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'flux'\")\n\n\ndef test_initialize_only_time():\n    ts = TimeSeries(time=INPUT_TIME)\n    assert ts['time'] is ts.time\n    # NOTE: the object in the table is a copy\n    assert_equal(ts.time.isot, INPUT_TIME.isot)\n\n\ndef test_initialization_with_data():\n    ts = TimeSeries(time=INPUT_TIME, data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert_equal(ts.time.isot, INPUT_TIME.isot)\n    assert_equal(ts['a'], [10, 2, 3])\n    assert_equal(ts['b'], [4, 5, 6])\n\n\ndef test_initialize_only_data():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert exc.value.args[0] == \"Either 'time' or 'time_start' should be specified\"\n\n\ndef test_initialization_with_table():\n    ts = TimeSeries(time=INPUT_TIME, data=PLAIN_TABLE)\n    assert ts.colnames == ['time', 'a', 'b', 'c']\n\n\ndef test_initialization_with_time_delta():\n    ts = TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n                    time_delta=TimeDelta(3, format='sec'),\n                    data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert_equal(ts.time.isot, ['2018-07-01T10:10:10.000',\n                                '2018-07-01T10:10:13.000',\n                                '2018-07-01T10:10:16.000'])\n\n\ndef test_initialization_missing_time_delta():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert exc.value.args[0] == \"'time' is scalar, so 'time_delta' is required\"\n\n\ndef test_initialization_invalid_time_and_time_start():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time=INPUT_TIME, time_start=datetime(2018, 7, 1, 10, 10, 10),\n                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert exc.value.args[0] == \"Cannot specify both 'time' and 'time_start'\"\n\n\ndef test_initialization_invalid_time_delta():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n                   time_delta=[1, 4, 3],\n                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    assert exc.value.args[0] == \"'time_delta' should be a Quantity or a TimeDelta\"\n\n\ndef test_initialization_with_time_in_data():\n\n    data = PLAIN_TABLE.copy()\n    data['time'] = INPUT_TIME\n\n    ts1 = TimeSeries(data=data)\n\n    assert set(ts1.colnames) == set(['time', 'a', 'b', 'c'])\n    assert all(ts1.time == INPUT_TIME)\n\n    ts2 = TimeSeries(data=[[10, 2, 3], INPUT_TIME], names=['a', 'time'])\n    assert set(ts2.colnames) == set(['time', 'a'])\n    assert all(ts2.time == INPUT_TIME)\n\n    with pytest.raises(TypeError) as exc:\n        # Don't allow ambiguous cases of passing multiple 'time' columns\n        TimeSeries(data=data, time=INPUT_TIME)\n    assert exc.value.args[0] == \"'time' has been given both in the table and as a keyword argument\"\n\n    with pytest.raises(TypeError) as exc:\n        # 'time' is a protected name, don't allow ambiguous cases\n        TimeSeries(time=INPUT_TIME, data=[[10, 2, 3], INPUT_TIME], names=['a', 'time'])\n    assert exc.value.args[0] == \"'time' has been given both in the table and as a keyword argument\"\n\n\ndef test_initialization_n_samples():\n\n    # Make sure things crash with incorrect n_samples\n\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time=INPUT_TIME, data=PLAIN_TABLE, n_samples=1000)\n    assert exc.value.args[0] == (\"'n_samples' has been given both and it is not the \"\n                                 \"same length as the input data.\")\n\n\ndef test_initialization_length_mismatch():\n    with pytest.raises(ValueError) as exc:\n        TimeSeries(time=INPUT_TIME, data=[[10, 2], [4, 5]], names=['a', 'b'])\n    assert exc.value.args[0] == \"Length of 'time' (3) should match data length (2)\"\n\n\ndef test_initialization_invalid_both_time_and_time_delta():\n    with pytest.raises(TypeError) as exc:\n        TimeSeries(time=INPUT_TIME, time_delta=TimeDelta(3, format='sec'))\n    assert exc.value.args[0] == (\"'time_delta' should not be specified since \"\n                                 \"'time' is an array\")\n\n\ndef test_fold():\n\n    times = Time([1, 2, 3, 8, 9, 12], format='unix')\n\n    ts = TimeSeries(time=times)\n    ts['flux'] = [1, 4, 4, 3, 2, 3]\n\n    # Try without epoch time, as it should default to the first time and\n    # wrapping at half the period.\n    tsf = ts.fold(period=3.2 * u.s)\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [0, 1, -1.2, 0.6, -1.6, 1.4], rtol=1e-6)\n\n    # Try with epoch time\n    tsf = ts.fold(period=3.2 * u.s, epoch_time=Time(1.6, format='unix'))\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [-0.6, 0.4, 1.4, 0.0, 1.0, 0.8], rtol=1e-6, atol=1e-6)\n\n    # Now with wrap_phase set to the full period\n    tsf = ts.fold(period=3.2 * u.s, wrap_phase=3.2 * u.s)\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [0, 1, 2, 0.6, 1.6, 1.4], rtol=1e-6)\n\n    # Now set epoch_phase to be 1/4 of the way through the phase\n    tsf = ts.fold(period=3.2 * u.s, epoch_phase=0.8 * u.s)\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [0.8, -1.4, -0.4, 1.4, -0.8, -1.0], rtol=1e-6)\n\n    # And combining epoch_phase and wrap_phase\n    tsf = ts.fold(period=3.2 * u.s, epoch_phase=0.8 * u.s, wrap_phase=3.2 * u.s)\n    assert isinstance(tsf.time, TimeDelta)\n    assert_allclose(tsf.time.sec, [0.8, 1.8, 2.8, 1.4, 2.4, 2.2], rtol=1e-6)\n\n    # Now repeat the above tests but with normalization applied\n\n    # Try without epoch time, as it should default to the first time and\n    # wrapping at half the period.\n    tsf = ts.fold(period=3.2 * u.s, normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [0, 1/3.2, -1.2/3.2, 0.6/3.2, -1.6/3.2, 1.4/3.2],\n                    rtol=1e-6)\n\n    # Try with epoch time\n    tsf = ts.fold(period=3.2 * u.s, epoch_time=Time(1.6, format='unix'),\n                  normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [-0.6/3.2, 0.4/3.2, 1.4/3.2, 0.0/3.2, 1.0/3.2, 0.8/3.2],\n                    rtol=1e-6, atol=1e-6)\n\n    # Now with wrap_phase set to the full period\n    tsf = ts.fold(period=3.2 * u.s, wrap_phase=1, normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [0, 1/3.2, 2/3.2, 0.6/3.2, 1.6/3.2, 1.4/3.2],\n                    rtol=1e-6)\n\n    # Now set epoch_phase to be 1/4 of the way through the phase\n    tsf = ts.fold(period=3.2 * u.s, epoch_phase=0.25, normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [0.8/3.2, -1.4/3.2, -0.4/3.2, 1.4/3.2, -0.8/3.2, -1.0/3.2],\n                    rtol=1e-6)\n\n    # And combining epoch_phase and wrap_phase\n    tsf = ts.fold(period=3.2 * u.s, epoch_phase=0.25, wrap_phase=1,\n                  normalize_phase=True)\n    assert isinstance(tsf.time, Quantity)\n    assert_allclose(tsf.time.to_value(u.one),\n                    [0.8/3.2, 1.8/3.2, 2.8/3.2, 1.4/3.2, 2.4/3.2, 2.2/3.2],\n                    rtol=1e-6)\n\n\ndef test_fold_invalid_options():\n\n    times = Time([1, 2, 3, 8, 9, 12], format='unix')\n\n    ts = TimeSeries(time=times)\n    ts['flux'] = [1, 4, 4, 3, 2, 3]\n\n    with pytest.raises(u.UnitsError,\n                       match='period should be a Quantity in units of time'):\n        ts.fold(period=3.2)\n\n    with pytest.raises(u.UnitsError,\n                       match='period should be a Quantity in units of time'):\n        ts.fold(period=3.2 * u.m)\n\n    with pytest.raises(u.UnitsError,\n                       match='epoch_phase should be a Quantity in units of '\n                             'time when normalize_phase=False'):\n        ts.fold(period=3.2 * u.s, epoch_phase=0.2)\n\n    with pytest.raises(u.UnitsError,\n                       match='epoch_phase should be a dimensionless Quantity '\n                             'or a float when normalize_phase=True'):\n        ts.fold(period=3.2 * u.s, epoch_phase=0.2 * u.s, normalize_phase=True)\n\n    with pytest.raises(u.UnitsError,\n                       match='wrap_phase should be a Quantity in units of '\n                             'time when normalize_phase=False'):\n        ts.fold(period=3.2 * u.s, wrap_phase=0.2)\n\n    with pytest.raises(u.UnitsError,\n                       match='wrap_phase should be dimensionless when '\n                             'normalize_phase=True'):\n        ts.fold(period=3.2 * u.s, wrap_phase=0.2 * u.s, normalize_phase=True)\n\n    with pytest.raises(ValueError,\n                       match='wrap_phase should be between 0 and the period'):\n        ts.fold(period=3.2 * u.s, wrap_phase=-0.1 * u.s)\n\n    with pytest.raises(ValueError,\n                       match='wrap_phase should be between 0 and the period'):\n        ts.fold(period=3.2 * u.s, wrap_phase=-4.2 * u.s)\n\n    with pytest.raises(ValueError,\n                       match='wrap_phase should be between 0 and 1'):\n        ts.fold(period=3.2 * u.s, wrap_phase=-0.1, normalize_phase=True)\n\n    with pytest.raises(ValueError,\n                       match='wrap_phase should be between 0 and 1'):\n        ts.fold(period=3.2 * u.s, wrap_phase=2.2, normalize_phase=True)\n\n\ndef test_pandas():\n    pandas = pytest.importorskip(\"pandas\")\n\n    df1 = pandas.DataFrame()\n    df1['a'] = [1, 2, 3]\n    df1.set_index(pandas.DatetimeIndex(INPUT_TIME.datetime64), inplace=True)\n\n    ts = TimeSeries.from_pandas(df1)\n    assert_equal(ts.time.isot, INPUT_TIME.isot)\n    assert ts.colnames == ['time', 'a']\n    assert len(ts.indices) == 1\n    assert (ts.indices['time'].columns[0] == INPUT_TIME).all()\n\n    ts_tcb = TimeSeries.from_pandas(df1, time_scale='tcb')\n    assert ts_tcb.time.scale == 'tcb'\n\n    df2 = ts.to_pandas()\n    assert (df2.index.values == pandas.Index(INPUT_TIME.datetime64).values).all()\n    assert df2.columns == pandas.Index(['a'])\n    assert (df1['a'] == df2['a']).all()\n\n    with pytest.raises(TypeError) as exc:\n        TimeSeries.from_pandas(None)\n    assert exc.value.args[0] == 'Input should be a pandas DataFrame'\n\n    df4 = pandas.DataFrame()\n    df4['a'] = [1, 2, 3]\n\n    with pytest.raises(TypeError) as exc:\n        TimeSeries.from_pandas(df4)\n    assert exc.value.args[0] == 'DataFrame does not have a DatetimeIndex'\n\n\ndef test_read_time_missing():\n    with pytest.raises(ValueError) as exc:\n        TimeSeries.read(CSV_FILE, format='csv')\n    assert exc.value.args[0] == '``time_column`` should be provided since the default Table readers are being used.'\n\n\ndef test_read_time_wrong():\n    with pytest.raises(ValueError) as exc:\n        TimeSeries.read(CSV_FILE, time_column='abc', format='csv')\n    assert exc.value.args[0] == \"Time column 'abc' not found in the input data.\"\n\n\ndef test_read():\n    timeseries = TimeSeries.read(CSV_FILE, time_column='Date', format='csv')\n    assert timeseries.colnames == ['time', 'A', 'B', 'C', 'D', 'E', 'F', 'G']\n    assert len(timeseries) == 11\n    assert timeseries['time'].format == 'iso'\n    assert timeseries['A'].sum() == 266.5\n\n\n@pytest.mark.remote_data(source='astropy')\ndef test_kepler_astropy():\n    from astropy.units import UnitsWarning\n\n    filename = get_pkg_data_filename('timeseries/kplr010666592-2009131110544_slc.fits')\n\n    with pytest.warns(UnitsWarning):\n        timeseries = TimeSeries.read(filename, format='kepler.fits')\n\n    assert timeseries[\"time\"].format == 'isot'\n    assert timeseries[\"time\"].scale == 'tdb'\n    assert timeseries[\"sap_flux\"].unit.to_string() == 'electron / s'\n    assert len(timeseries) == 14280\n    assert len(timeseries.columns) == 20\n\n\n@pytest.mark.remote_data(source='astropy')\ndef test_tess_astropy():\n    filename = get_pkg_data_filename('timeseries/hlsp_tess-data-alerts_tess_phot_00025155310-s01_tess_v1_lc.fits')\n    with pytest.warns(UserWarning, match='Ignoring 815 rows with NaN times'):\n        timeseries = TimeSeries.read(filename, format='tess.fits')\n    assert timeseries[\"time\"].format == 'isot'\n    assert timeseries[\"time\"].scale == 'tdb'\n    assert timeseries[\"sap_flux\"].unit.to_string() == 'electron / s'\n    assert len(timeseries) == 19261\n    assert len(timeseries.columns) == 20\n\n\ndef test_required_columns():\n\n    # Test the machinery that makes sure that the required columns are present\n\n    ts = TimeSeries(time=INPUT_TIME,\n                    data=[[10, 2, 3], [4, 5, 6]],\n                    names=['a', 'b'])\n\n    # In the examples below, the operation (e.g. remove_column) is actually\n    # carried out before the checks are made, so we need to use copy() so that\n    # we don't change the main version of the time series.\n\n    # Make sure copy works fine\n    ts.copy()\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().add_column(Column([3, 4, 5], name='c'), index=0)\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'c'\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().add_columns([Column([3, 4, 5], name='d'),\n                               Column([3, 4, 5], name='e')], indexes=[0, 1])\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'd'\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().keep_columns(['a', 'b'])\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - required \"\n                                 \"column 'time' is missing\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().remove_column('time')\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - required \"\n                                 \"column 'time' is missing\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().remove_columns(['time', 'a'])\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'b'\")\n\n    with pytest.raises(ValueError) as exc:\n        ts.copy().rename_column('time', 'banana')\n    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n                                 \"'time' as the first column but found 'banana'\")\n\n\n@pytest.mark.parametrize('cls', [BoxLeastSquares, LombScargle])\ndef test_periodogram(cls):\n\n    # Note that we don't need to check the actual results from the periodogram\n    # classes here since these are tested extensively in\n    # astropy.timeseries.periodograms.\n\n    ts = TimeSeries(time=INPUT_TIME,\n                    data=[[10, 2, 3], [4, 5, 6]],\n                    names=['a', 'b'])\n\n    p1 = cls.from_timeseries(ts, 'a')\n    assert isinstance(p1, cls)\n    assert_allclose(p1.t.jd, ts.time.jd)\n    assert_equal(p1.y, ts['a'])\n    assert p1.dy is None\n\n    p2 = cls.from_timeseries(ts, 'a', uncertainty='b')\n    assert_quantity_allclose(p2.dy, ts['b'])\n\n    p3 = cls.from_timeseries(ts, 'a', uncertainty=0.1)\n    assert_allclose(p3.dy, 0.1)\n"}, "action_id": "99ecfa7f-8661-49de-b035-0aef0a07d07f"}