{"kind": "ObservationEvent", "id": "db527a78-e331-447f-8cf9-c7fa199242bc", "timestamp": "2025-09-26T01:28:27.444022", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_01RzfhxJMaepkzwGkbiwho3q", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmpenvpl8sw/matplotlib/lib/matplotlib/offsetbox.py:\n     1\tr\"\"\"\n     2\tContainer classes for `.Artist`\\s.\n     3\t\n     4\t`OffsetBox`\n     5\t    The base of all container artists defined in this module.\n     6\t\n     7\t`AnchoredOffsetbox`, `AnchoredText`\n     8\t    Anchor and align an arbitrary `.Artist` or a text relative to the parent\n     9\t    axes or a specific anchor point.\n    10\t\n    11\t`DrawingArea`\n    12\t    A container with fixed width and height. Children have a fixed position\n    13\t    inside the container and may be clipped.\n    14\t\n    15\t`HPacker`, `VPacker`\n    16\t    Containers for layouting their children vertically or horizontally.\n    17\t\n    18\t`PaddedBox`\n    19\t    A container to add a padding around an `.Artist`.\n    20\t\n    21\t`TextArea`\n    22\t    Contains a single `.Text` instance.\n    23\t\"\"\"\n    24\t\n    25\timport numpy as np\n    26\t\n    27\timport matplotlib as mpl\n    28\tfrom matplotlib import _api, _docstring\n    29\timport matplotlib.artist as martist\n    30\timport matplotlib.path as mpath\n    31\timport matplotlib.text as mtext\n    32\timport matplotlib.transforms as mtransforms\n    33\tfrom matplotlib.font_manager import FontProperties\n    34\tfrom matplotlib.image import BboxImage\n    35\tfrom matplotlib.patches import (\n    36\t    FancyBboxPatch, FancyArrowPatch, bbox_artist as mbbox_artist)\n    37\tfrom matplotlib.transforms import Bbox, BboxBase, TransformedBbox\n    38\t\n    39\t\n    40\tDEBUG = False\n    41\t\n    42\t\n    43\t# for debugging use\n    44\tdef bbox_artist(*args, **kwargs):\n    45\t    if DEBUG:\n    46\t        mbbox_artist(*args, **kwargs)\n    47\t\n    48\t\n    49\tdef _get_packed_offsets(widths, total, sep, mode=\"fixed\"):\n    50\t    r\"\"\"\n    51\t    Pack boxes specified by their *widths*.\n    52\t\n    53\t    For simplicity of the description, the terminology used here assumes a\n    54\t    horizontal layout, but the function works equally for a vertical layout.\n    55\t\n    56\t    There are three packing *mode*\\s:\n    57\t\n    58\t    - 'fixed': The elements are packed tight to the left with a spacing of\n    59\t      *sep* in between. If *total* is *None* the returned total will be the\n    60\t      right edge of the last box. A non-*None* total will be passed unchecked\n    61\t      to the output. In particular this means that right edge of the last\n    62\t      box may be further to the right than the returned total.\n    63\t\n    64\t    - 'expand': Distribute the boxes with equal spacing so that the left edge\n    65\t      of the first box is at 0, and the right edge of the last box is at\n    66\t      *total*. The parameter *sep* is ignored in this mode. A total of *None*\n    67\t      is accepted and considered equal to 1. The total is returned unchanged\n    68\t      (except for the conversion *None* to 1). If the total is smaller than\n    69\t      the sum of the widths, the laid out boxes will overlap.\n    70\t\n    71\t    - 'equal': If *total* is given, the total space is divided in N equal\n    72\t      ranges and each box is left-aligned within its subspace.\n    73\t      Otherwise (*total* is *None*), *sep* must be provided and each box is\n    74\t      left-aligned in its subspace of width ``(max(widths) + sep)``. The\n    75\t      total width is then calculated to be ``N * (max(widths) + sep)``.\n    76\t\n    77\t    Parameters\n    78\t    ----------\n    79\t    widths : list of float\n    80\t        Widths of boxes to be packed.\n    81\t    total : float or None\n    82\t        Intended total length. *None* if not used.\n    83\t    sep : float\n    84\t        Spacing between boxes.\n    85\t    mode : {'fixed', 'expand', 'equal'}\n    86\t        The packing mode.\n    87\t\n    88\t    Returns\n    89\t    -------\n    90\t    total : float\n    91\t        The total width needed to accommodate the laid out boxes.\n    92\t    offsets : array of float\n    93\t        The left offsets of the boxes.\n    94\t    \"\"\"\n    95\t    _api.check_in_list([\"fixed\", \"expand\", \"equal\"], mode=mode)\n    96\t\n    97\t    if mode == \"fixed\":\n    98\t        offsets_ = np.cumsum([0] + [w + sep for w in widths])\n    99\t        offsets = offsets_[:-1]\n   100\t        if total is None:\n   101\t            total = offsets_[-1] - sep\n   102\t        return total, offsets\n   103\t\n   104\t    elif mode == \"expand\":\n   105\t        # This is a bit of a hack to avoid a TypeError when *total*\n   106\t        # is None and used in conjugation with tight layout.\n   107\t        if total is None:\n   108\t            total = 1\n   109\t        if len(widths) > 1:\n   110\t            sep = (total - sum(widths)) / (len(widths) - 1)\n   111\t        else:\n   112\t            sep = 0\n   113\t        offsets_ = np.cumsum([0] + [w + sep for w in widths])\n   114\t        offsets = offsets_[:-1]\n   115\t        return total, offsets\n   116\t\n   117\t    elif mode == \"equal\":\n   118\t        maxh = max(widths)\n   119\t        if total is None:\n   120\t            if sep is None:\n   121\t                raise ValueError(\"total and sep cannot both be None when \"\n   122\t                                 \"using layout mode 'equal'\")\n   123\t            total = (maxh + sep) * len(widths)\n   124\t        else:\n   125\t            sep = total / len(widths) - maxh\n   126\t        offsets = (maxh + sep) * np.arange(len(widths))\n   127\t        return total, offsets\n   128\t\n   129\t\n   130\tdef _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n   131\t    \"\"\"\n   132\t    Align boxes each specified by their ``(height, descent)`` pair.\n   133\t\n   134\t    For simplicity of the description, the terminology used here assumes a\n   135\t    horizontal layout (i.e., vertical alignment), but the function works\n   136\t    equally for a vertical layout.\n   137\t\n   138\t    Parameters\n   139\t    ----------\n   140\t    hd_list\n   141\t        List of (height, xdescent) of boxes to be aligned.\n   142\t    height : float or None\n   143\t        Intended total height. If None, the maximum of the heights in *hd_list*\n   144\t        is used.\n   145\t    align : {'baseline', 'left', 'top', 'right', 'bottom', 'center'}\n   146\t        The alignment anchor of the boxes.\n   147\t\n   148\t    Returns\n   149\t    -------\n   150\t    height\n   151\t        The total height of the packing (if a value was originally passed in,\n   152\t        it is returned without checking that it is actually large enough).\n   153\t    descent\n   154\t        The descent of the packing.\n   155\t    offsets\n   156\t        The bottom offsets of the boxes.\n   157\t    \"\"\"\n   158\t\n   159\t    if height is None:\n   160\t        height = max(h for h, d in hd_list)\n   161\t    _api.check_in_list(\n   162\t        [\"baseline\", \"left\", \"top\", \"right\", \"bottom\", \"center\"], align=align)\n   163\t\n   164\t    if align == \"baseline\":\n   165\t        height_descent = max(h - d for h, d in hd_list)\n   166\t        descent = max(d for h, d in hd_list)\n   167\t        height = height_descent + descent\n   168\t        offsets = [0. for h, d in hd_list]\n   169\t    elif align in [\"left\", \"top\"]:\n   170\t        descent = 0.\n   171\t        offsets = [d for h, d in hd_list]\n   172\t    elif align in [\"right\", \"bottom\"]:\n   173\t        descent = 0.\n   174\t        offsets = [height - h + d for h, d in hd_list]\n   175\t    elif align == \"center\":\n   176\t        descent = 0.\n   177\t        offsets = [(height - h) * .5 + d for h, d in hd_list]\n   178\t\n   179\t    return height, descent, offsets\n   180\t\n   181\t\n   182\tclass OffsetBox(martist.Artist):\n   183\t    \"\"\"\n   184\t    The OffsetBox is a simple container artist.\n   185\t\n   186\t    The child artists are meant to be drawn at a relative position to its\n   187\t    parent.\n   188\t\n   189\t    Being an artist itself, all parameters are passed on to `.Artist`.\n   190\t    \"\"\"\n   191\t    def __init__(self, *args, **kwargs):\n   192\t        super().__init__(*args)\n   193\t        self._internal_update(kwargs)\n   194\t        # Clipping has not been implemented in the OffsetBox family, so\n   195\t        # disable the clip flag for consistency. It can always be turned back\n   196\t        # on to zero effect.\n   197\t        self.set_clip_on(False)\n   198\t        self._children = []\n   199\t        self._offset = (0, 0)\n   200\t\n   201\t    def set_figure(self, fig):\n   202\t        \"\"\"\n   203\t        Set the `.Figure` for the `.OffsetBox` and all its children.\n   204\t\n   205\t        Parameters\n   206\t        ----------\n   207\t        fig : `~matplotlib.figure.Figure`\n   208\t        \"\"\"\n   209\t        super().set_figure(fig)\n   210\t        for c in self.get_children():\n   211\t            c.set_figure(fig)\n   212\t\n   213\t    @martist.Artist.axes.setter\n   214\t    def axes(self, ax):\n   215\t        # TODO deal with this better\n   216\t        martist.Artist.axes.fset(self, ax)\n   217\t        for c in self.get_children():\n   218\t            if c is not None:\n   219\t                c.axes = ax\n   220\t\n   221\t    def contains(self, mouseevent):\n   222\t        \"\"\"\n   223\t        Delegate the mouse event contains-check to the children.\n   224\t\n   225\t        As a container, the `.OffsetBox` does not respond itself to\n   226\t        mouseevents.\n   227\t\n   228\t        Parameters\n   229\t        ----------\n   230\t        mouseevent : `matplotlib.backend_bases.MouseEvent`\n   231\t\n   232\t        Returns\n   233\t        -------\n   234\t        contains : bool\n   235\t            Whether any values are within the radius.\n   236\t        details : dict\n   237\t            An artist-specific dictionary of details of the event context,\n   238\t            such as which points are contained in the pick radius. See the\n   239\t            individual Artist subclasses for details.\n   240\t\n   241\t        S<response clipped><NOTE>Due to the max output limit, only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE>renderer)\n   242\t                           for child in self.get_children()])\n   243\t\n   244\t    def get_tightbbox(self, renderer=None):\n   245\t        # docstring inherited\n   246\t        return Bbox.union([child.get_tightbbox(renderer)\n   247\t                           for child in self.get_children()])\n   248\t\n   249\t    def update_positions(self, renderer):\n   250\t        \"\"\"\n   251\t        Update pixel positions for the annotated point, the text and the arrow.\n   252\t        \"\"\"\n   253\t\n   254\t        x, y = self.xybox\n   255\t        if isinstance(self.boxcoords, tuple):\n   256\t            xcoord, ycoord = self.boxcoords\n   257\t            x1, y1 = self._get_xy(renderer, x, y, xcoord)\n   258\t            x2, y2 = self._get_xy(renderer, x, y, ycoord)\n   259\t            ox0, oy0 = x1, y2\n   260\t        else:\n   261\t            ox0, oy0 = self._get_xy(renderer, x, y, self.boxcoords)\n   262\t\n   263\t        w, h, xd, yd = self.offsetbox.get_extent(renderer)\n   264\t        fw, fh = self._box_alignment\n   265\t        self.offsetbox.set_offset((ox0 - fw * w + xd, oy0 - fh * h + yd))\n   266\t\n   267\t        bbox = self.offsetbox.get_window_extent(renderer)\n   268\t        self.patch.set_bounds(bbox.bounds)\n   269\t\n   270\t        mutation_scale = renderer.points_to_pixels(self.get_fontsize())\n   271\t        self.patch.set_mutation_scale(mutation_scale)\n   272\t\n   273\t        if self.arrowprops:\n   274\t            # Use FancyArrowPatch if self.arrowprops has \"arrowstyle\" key.\n   275\t\n   276\t            # Adjust the starting point of the arrow relative to the textbox.\n   277\t            # TODO: Rotation needs to be accounted.\n   278\t            arrow_begin = bbox.p0 + bbox.size * self._arrow_relpos\n   279\t            arrow_end = self._get_position_xy(renderer)\n   280\t            # The arrow (from arrow_begin to arrow_end) will be first clipped\n   281\t            # by patchA and patchB, then shrunk by shrinkA and shrinkB (in\n   282\t            # points).  If patch A is not set, self.bbox_patch is used.\n   283\t            self.arrow_patch.set_positions(arrow_begin, arrow_end)\n   284\t\n   285\t            if \"mutation_scale\" in self.arrowprops:\n   286\t                mutation_scale = renderer.points_to_pixels(\n   287\t                    self.arrowprops[\"mutation_scale\"])\n   288\t                # Else, use fontsize-based mutation_scale defined above.\n   289\t            self.arrow_patch.set_mutation_scale(mutation_scale)\n   290\t\n   291\t            patchA = self.arrowprops.get(\"patchA\", self.patch)\n   292\t            self.arrow_patch.set_patchA(patchA)\n   293\t\n   294\t    def draw(self, renderer):\n   295\t        # docstring inherited\n   296\t        if renderer is not None:\n   297\t            self._renderer = renderer\n   298\t        if not self.get_visible() or not self._check_xy(renderer):\n   299\t            return\n   300\t        self.update_positions(renderer)\n   301\t        if self.arrow_patch is not None:\n   302\t            if self.arrow_patch.figure is None and self.figure is not None:\n   303\t                self.arrow_patch.figure = self.figure\n   304\t            self.arrow_patch.draw(renderer)\n   305\t        self.patch.draw(renderer)\n   306\t        self.offsetbox.draw(renderer)\n   307\t        self.stale = False\n   308\t\n   309\t\n   310\tclass DraggableBase:\n   311\t    \"\"\"\n   312\t    Helper base class for a draggable artist (legend, offsetbox).\n   313\t\n   314\t    Derived classes must override the following methods::\n   315\t\n   316\t        def save_offset(self):\n   317\t            '''\n   318\t            Called when the object is picked for dragging; should save the\n   319\t            reference position of the artist.\n   320\t            '''\n   321\t\n   322\t        def update_offset(self, dx, dy):\n   323\t            '''\n   324\t            Called during the dragging; (*dx*, *dy*) is the pixel offset from\n   325\t            the point where the mouse drag started.\n   326\t            '''\n   327\t\n   328\t    Optionally, you may override the following method::\n   329\t\n   330\t        def finalize_offset(self):\n   331\t            '''Called when the mouse is released.'''\n   332\t\n   333\t    In the current implementation of `.DraggableLegend` and\n   334\t    `DraggableAnnotation`, `update_offset` places the artists in display\n   335\t    coordinates, and `finalize_offset` recalculates their position in axes\n   336\t    coordinate and set a relevant attribute.\n   337\t    \"\"\"\n   338\t\n   339\t    def __init__(self, ref_artist, use_blit=False):\n   340\t        self.ref_artist = ref_artist\n   341\t        if not ref_artist.pickable():\n   342\t            ref_artist.set_picker(True)\n   343\t        self.got_artist = False\n   344\t        self.canvas = self.ref_artist.figure.canvas\n   345\t        self._use_blit = use_blit and self.canvas.supports_blit\n   346\t        self.cids = [\n   347\t            self.canvas.callbacks._connect_picklable(\n   348\t                'pick_event', self.on_pick),\n   349\t            self.canvas.callbacks._connect_picklable(\n   350\t                'button_release_event', self.on_release),\n   351\t        ]\n   352\t\n   353\t    def on_motion(self, evt):\n   354\t        if self._check_still_parented() and self.got_artist:\n   355\t            dx = evt.x - self.mouse_x\n   356\t            dy = evt.y - self.mouse_y\n   357\t            self.update_offset(dx, dy)\n   358\t            if self._use_blit:\n   359\t                self.canvas.restore_region(self.background)\n   360\t                self.ref_artist.draw(\n   361\t                    self.ref_artist.figure._get_renderer())\n   362\t                self.canvas.blit()\n   363\t            else:\n   364\t                self.canvas.draw()\n   365\t\n   366\t    def on_pick(self, evt):\n   367\t        if self._check_still_parented() and evt.artist == self.ref_artist:\n   368\t            self.mouse_x = evt.mouseevent.x\n   369\t            self.mouse_y = evt.mouseevent.y\n   370\t            self.got_artist = True\n   371\t            if self._use_blit:\n   372\t                self.ref_artist.set_animated(True)\n   373\t                self.canvas.draw()\n   374\t                self.background = \\\n   375\t                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n   376\t                self.ref_artist.draw(\n   377\t                    self.ref_artist.figure._get_renderer())\n   378\t                self.canvas.blit()\n   379\t            self._c1 = self.canvas.callbacks._connect_picklable(\n   380\t                \"motion_notify_event\", self.on_motion)\n   381\t            self.save_offset()\n   382\t\n   383\t    def on_release(self, event):\n   384\t        if self._check_still_parented() and self.got_artist:\n   385\t            self.finalize_offset()\n   386\t            self.got_artist = False\n   387\t            self.canvas.mpl_disconnect(self._c1)\n   388\t\n   389\t            if self._use_blit:\n   390\t                self.ref_artist.set_animated(False)\n   391\t\n   392\t    def _check_still_parented(self):\n   393\t        if self.ref_artist.figure is None:\n   394\t            self.disconnect()\n   395\t            return False\n   396\t        else:\n   397\t            return True\n   398\t\n   399\t    def disconnect(self):\n   400\t        \"\"\"Disconnect the callbacks.\"\"\"\n   401\t        for cid in self.cids:\n   402\t            self.canvas.mpl_disconnect(cid)\n   403\t        try:\n   404\t            c1 = self._c1\n   405\t        except AttributeError:\n   406\t            pass\n   407\t        else:\n   408\t            self.canvas.mpl_disconnect(c1)\n   409\t\n   410\t    def save_offset(self):\n   411\t        pass\n   412\t\n   413\t    def update_offset(self, dx, dy):\n   414\t        pass\n   415\t\n   416\t    def finalize_offset(self):\n   417\t        pass\n   418\t\n   419\t\n   420\tclass DraggableOffsetBox(DraggableBase):\n   421\t    def __init__(self, ref_artist, offsetbox, use_blit=False):\n   422\t        super().__init__(ref_artist, use_blit=use_blit)\n   423\t        self.offsetbox = offsetbox\n   424\t\n   425\t    def save_offset(self):\n   426\t        offsetbox = self.offsetbox\n   427\t        renderer = offsetbox.figure._get_renderer()\n   428\t        w, h, xd, yd = offsetbox.get_extent(renderer)\n   429\t        offset = offsetbox.get_offset(w, h, xd, yd, renderer)\n   430\t        self.offsetbox_x, self.offsetbox_y = offset\n   431\t        self.offsetbox.set_offset(offset)\n   432\t\n   433\t    def update_offset(self, dx, dy):\n   434\t        loc_in_canvas = self.offsetbox_x + dx, self.offsetbox_y + dy\n   435\t        self.offsetbox.set_offset(loc_in_canvas)\n   436\t\n   437\t    def get_loc_in_canvas(self):\n   438\t        offsetbox = self.offsetbox\n   439\t        renderer = offsetbox.figure._get_renderer()\n   440\t        w, h, xd, yd = offsetbox.get_extent(renderer)\n   441\t        ox, oy = offsetbox._offset\n   442\t        loc_in_canvas = (ox - xd, oy - yd)\n   443\t        return loc_in_canvas\n   444\t\n   445\t\n   446\tclass DraggableAnnotation(DraggableBase):\n   447\t    def __init__(self, annotation, use_blit=False):\n   448\t        super().__init__(annotation, use_blit=use_blit)\n   449\t        self.annotation = annotation\n   450\t\n   451\t    def save_offset(self):\n   452\t        ann = self.annotation\n   453\t        self.ox, self.oy = ann.get_transform().transform(ann.xyann)\n   454\t\n   455\t    def update_offset(self, dx, dy):\n   456\t        ann = self.annotation\n   457\t        ann.xyann = ann.get_transform().inverted().transform(\n   458\t            (self.ox + dx, self.oy + dy))\n   459\t\n", "path": "/tmp/tmpenvpl8sw/matplotlib/lib/matplotlib/offsetbox.py", "prev_exist": true}, "action_id": "c1063610-7c78-4e78-8ab4-eda3fe1a05cf"}