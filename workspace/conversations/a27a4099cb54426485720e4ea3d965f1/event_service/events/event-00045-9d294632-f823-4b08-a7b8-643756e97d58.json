{"kind": "ObservationEvent", "id": "9d294632-f823-4b08-a7b8-643756e97d58", "timestamp": "2025-09-26T01:29:27.355384", "source": "environment", "tool_name": "str_replace_editor", "tool_call_id": "toolu_012mYjXFJa9v47pmgMPwVQSf", "observation": {"kind": "StrReplaceEditorObservation", "command": "view", "output": "Here's the result of running `cat -n` on /tmp/tmpenvpl8sw/matplotlib/lib/matplotlib/tests/test_offsetbox.py:\n     1\tfrom collections import namedtuple\n     2\timport io\n     3\t\n     4\timport numpy as np\n     5\tfrom numpy.testing import assert_allclose\n     6\timport pytest\n     7\t\n     8\tfrom matplotlib.testing.decorators import image_comparison\n     9\timport matplotlib.pyplot as plt\n    10\timport matplotlib.patches as mpatches\n    11\timport matplotlib.lines as mlines\n    12\tfrom matplotlib.backend_bases import MouseButton, MouseEvent\n    13\t\n    14\tfrom matplotlib.offsetbox import (\n    15\t    AnchoredOffsetbox, AnnotationBbox, AnchoredText, DrawingArea, OffsetBox,\n    16\t    OffsetImage, TextArea, _get_packed_offsets)\n    17\t\n    18\t\n    19\t@image_comparison(['offsetbox_clipping'], remove_text=True)\n    20\tdef test_offsetbox_clipping():\n    21\t    # - create a plot\n    22\t    # - put an AnchoredOffsetbox with a child DrawingArea\n    23\t    #   at the center of the axes\n    24\t    # - give the DrawingArea a gray background\n    25\t    # - put a black line across the bounds of the DrawingArea\n    26\t    # - see that the black line is clipped to the edges of\n    27\t    #   the DrawingArea.\n    28\t    fig, ax = plt.subplots()\n    29\t    size = 100\n    30\t    da = DrawingArea(size, size, clip=True)\n    31\t    bg = mpatches.Rectangle((0, 0), size, size,\n    32\t                            facecolor='#CCCCCC',\n    33\t                            edgecolor='None',\n    34\t                            linewidth=0)\n    35\t    line = mlines.Line2D([-size*.5, size*1.5], [size/2, size/2],\n    36\t                         color='black',\n    37\t                         linewidth=10)\n    38\t    anchored_box = AnchoredOffsetbox(\n    39\t        loc='center',\n    40\t        child=da,\n    41\t        pad=0.,\n    42\t        frameon=False,\n    43\t        bbox_to_anchor=(.5, .5),\n    44\t        bbox_transform=ax.transAxes,\n    45\t        borderpad=0.)\n    46\t\n    47\t    da.add_artist(bg)\n    48\t    da.add_artist(line)\n    49\t    ax.add_artist(anchored_box)\n    50\t    ax.set_xlim((0, 1))\n    51\t    ax.set_ylim((0, 1))\n    52\t\n    53\t\n    54\tdef test_offsetbox_clip_children():\n    55\t    # - create a plot\n    56\t    # - put an AnchoredOffsetbox with a child DrawingArea\n    57\t    #   at the center of the axes\n    58\t    # - give the DrawingArea a gray background\n    59\t    # - put a black line across the bounds of the DrawingArea\n    60\t    # - see that the black line is clipped to the edges of\n    61\t    #   the DrawingArea.\n    62\t    fig, ax = plt.subplots()\n    63\t    size = 100\n    64\t    da = DrawingArea(size, size, clip=True)\n    65\t    bg = mpatches.Rectangle((0, 0), size, size,\n    66\t                            facecolor='#CCCCCC',\n    67\t                            edgecolor='None',\n    68\t                            linewidth=0)\n    69\t    line = mlines.Line2D([-size*.5, size*1.5], [size/2, size/2],\n    70\t                         color='black',\n    71\t                         linewidth=10)\n    72\t    anchored_box = AnchoredOffsetbox(\n    73\t        loc='center',\n    74\t        child=da,\n    75\t        pad=0.,\n    76\t        frameon=False,\n    77\t        bbox_to_anchor=(.5, .5),\n    78\t        bbox_transform=ax.transAxes,\n    79\t        borderpad=0.)\n    80\t\n    81\t    da.add_artist(bg)\n    82\t    da.add_artist(line)\n    83\t    ax.add_artist(anchored_box)\n    84\t\n    85\t    fig.canvas.draw()\n    86\t    assert not fig.stale\n    87\t    da.clip_children = True\n    88\t    assert fig.stale\n    89\t\n    90\t\n    91\tdef test_offsetbox_loc_codes():\n    92\t    # Check that valid string location codes all work with an AnchoredOffsetbox\n    93\t    codes = {'upper right': 1,\n    94\t             'upper left': 2,\n    95\t             'lower left': 3,\n    96\t             'lower right': 4,\n    97\t             'right': 5,\n    98\t             'center left': 6,\n    99\t             'center right': 7,\n   100\t             'lower center': 8,\n   101\t             'upper center': 9,\n   102\t             'center': 10,\n   103\t             }\n   104\t    fig, ax = plt.subplots()\n   105\t    da = DrawingArea(100, 100)\n   106\t    for code in codes:\n   107\t        anchored_box = AnchoredOffsetbox(loc=code, child=da)\n   108\t        ax.add_artist(anchored_box)\n   109\t    fig.canvas.draw()\n   110\t\n   111\t\n   112\tdef test_expand_with_tight_layout():\n   113\t    # Check issue reported in #10476, and updated due to #10784\n   114\t    fig, ax = plt.subplots()\n   115\t\n   116\t    d1 = [1, 2]\n   117\t    d2 = [2, 1]\n   118\t    ax.plot(d1, label='series 1')\n   119\t    ax.plot(d2, label='series 2')\n   120\t    ax.legend(ncols=2, mode='expand')\n   121\t\n   122\t    fig.tight_layout()  # where the crash used to happen\n   123\t\n   124\t\n   125\t@pytest.mark.parametrize('widths',\n   126\t                         ([150], [150, 150, 150], [0.1], [0.1, 0.1]))\n   127\t@pytest.mark.parametrize('total', (250, 100, 0, -1, None))\n   128\t@pytest.mark.parametrize('sep', (250, 1, 0, -1))\n   129\t@pytest.mark.parametrize('mode', (\"expand\", \"fixed\", \"equal\"))\n   130\tdef test_get_packed_offsets(widths, total, sep, mode):\n   131\t    # Check a (rather arbitrary) set of parameters due to successive similar\n   132\t    # issue tickets (at least #10476 and #10784) related to corner cases\n   133\t    # triggered inside this function when calling higher-level functions\n   134\t    # (e.g. `Axes.legend`).\n   135\t    # These are just some additional smoke tests. The output is untested.\n   136\t    _get_packed_offsets(widths, total, sep, mode=mode)\n   137\t\n   138\t\n   139\t_Params = namedtuple('_params', 'wd_list, total, sep, expected')\n   140\t\n   141\t\n   142\t@pytest.mark.parametrize('widths, total, sep, expected', [\n   143\t    _Params(  # total=None\n   144\t        [3, 1, 2], total=None, sep=1, expected=(8, [0, 4, 6])),\n   145\t    _Params(  # total larger than required\n   146\t        [3, 1, 2], total=10, sep=1, expected=(10, [0, 4, 6])),\n   147\t    _Params(  # total smaller than required\n   148\t        [3, 1, 2], total=5, sep=1, expected=(5, [0, 4, 6])),\n   149\t])\n   150\tdef test_get_packed_offsets_fixed(widths, total, sep, expected):\n   151\t    result = _get_packed_offsets(widths, total, sep, mode='fixed')\n   152\t    assert result[0] == expected[0]\n   153\t    assert_allclose(result[1], expected[1])\n   154\t\n   155\t\n   156\t@pytest.mark.parametrize('widths, total, sep, expected', [\n   157\t    _Params(  # total=None (implicit 1)\n   158\t        [.1, .1, .1], total=None, sep=None, expected=(1, [0, .45, .9])),\n   159\t    _Params(  # total larger than sum of widths\n   160\t        [3, 1, 2], total=10, sep=1, expected=(10, [0, 5, 8])),\n   161\t    _Params(  # total smaller sum of widths: overlapping boxes\n   162\t        [3, 1, 2], total=5, sep=1, expected=(5, [0, 2.5, 3])),\n   163\t])\n   164\tdef test_get_packed_offsets_expand(widths, total, sep, expected):\n   165\t    result = _get_packed_offsets(widths, total, sep, mode='expand')\n   166\t    assert result[0] == expected[0]\n   167\t    assert_allclose(result[1], expected[1])\n   168\t\n   169\t\n   170\t@pytest.mark.parametrize('widths, total, sep, expected', [\n   171\t    _Params(  # total larger than required\n   172\t        [3, 2, 1], total=6, sep=None, expected=(6, [0, 2, 4])),\n   173\t    _Params(  # total smaller sum of widths: overlapping boxes\n   174\t        [3, 2, 1, .5], total=2, sep=None, expected=(2, [0, 0.5, 1, 1.5])),\n   175\t    _Params(  # total larger than required\n   176\t        [.5, 1, .2], total=None, sep=1, expected=(6, [0, 2, 4])),\n   177\t    # the case total=None, sep=None is tested separately below\n   178\t])\n   179\tdef test_get_packed_offsets_equal(widths, total, sep, expected):\n   180\t    result = _get_packed_offsets(widths, total, sep, mode='equal')\n   181\t    assert result[0] == expected[0]\n   182\t    assert_allclose(result[1], expected[1])\n   183\t\n   184\t\n   185\tdef test_get_packed_offsets_equal_total_none_sep_none():\n   186\t    with pytest.raises(ValueError):\n   187\t        _get_packed_offsets([1, 1, 1], total=None, sep=None, mode='equal')\n   188\t\n   189\t\n   190\t@pytest.mark.parametrize('child_type', ['draw', 'image', 'text'])\n   191\t@pytest.mark.parametrize('boxcoords',\n   192\t                         ['axes fraction', 'axes pixels', 'axes points',\n   193\t                          'data'])\n   194\tdef test_picking(child_type, boxcoords):\n   195\t    # These all take up approximately the same area.\n   196\t    if child_type == 'draw':\n   197\t        picking_child = DrawingArea(5, 5)\n   198\t        picking_child.add_artist(mpatches.Rectangle((0, 0), 5, 5, linewidth=0))\n   199\t    elif child_type == 'image':\n   200\t        im = np.ones((5, 5))\n   201\t        im[2, 2] = 0\n   202\t        picking_child = OffsetImage(im)\n   203\t    elif child_type == 'text':\n   204\t        picking_child = TextArea('\\N{Black Square}', textprops={'fontsize': 5})\n   205\t    else:\n   206\t        assert False, f'Unknown picking child type {child_type}'\n   207\t\n   208\t    fig, ax = plt.subplots()\n   209\t    ab = AnnotationBbox(picking_child, (0.5, 0.5), boxcoords=boxcoords)\n   210\t    ab.set_picker(True)\n   211\t    ax.add_artist(ab)\n   212\t\n   213\t    calls = []\n   214\t    fig.canvas.mpl_connect('pick_event', lambda event: calls.append(event))\n   215\t\n   216\t    # Annotation should be picked by an event occurring at its center.\n   217\t    if boxcoords == 'axes points':\n   218\t        x, y = ax.transAxes.transform_point((0, 0))\n   219\t        x += 0.5 * fig.dpi / 72\n   220\t        y += 0.5 * fig.dpi / 72\n   221\t    elif boxcoords == 'axes pixels':\n   222\t        x, y = ax.transAxes.transform_point((0, 0))\n   223\t        x += 0.5\n   224\t        y += 0.5\n   225\t    else:\n   226\t        x, y = ax.transAxes.transform_point((0.5, 0.5))\n   227\t    fig.canvas.draw()\n   228\t    calls.clear()\n   229\t    MouseEvent(\n   230\t        \"button_press_event\", fig.canvas, x, y, MouseButton.LEFT)._process()\n   231\t    assert len(calls) == 1 and calls[0].artist == ab\n   232\t\n   233\t    # Annotation should *not* be picked by an event at its original center\n   234\t    # point when the limits have changed enough to hide the *xy* point.\n   235\t    ax.set_xlim(-1, 0)\n   236\t    ax.set_ylim(-1, 0)\n   237\t    fig.canvas.draw()\n   238\t    calls.clear()\n   239\t    MouseEvent(\n   240\t        \"button_press_event\", fig.canvas, x, y, MouseButton.LEFT)._process()\n   241\t    assert len(calls) == 0\n   242\t\n   243\t\n   244\t@image_comparison(['anchoredtext_align.png'], remove_text=True, style='mpl20')\n   245\tdef test_anchoredtext_horizontal_alignment():\n   246\t    fig, ax = plt.subplots()\n   247\t\n   248\t    text0 = AnchoredText(\"test\\ntest long text\", loc=\"center left\",\n   249\t                         pad=0.2, prop={\"ha\": \"left\"})\n   250\t    ax.add_artist(text0)\n   251\t    text1 = AnchoredText(\"test\\ntest long text\", loc=\"center\",\n   252\t                         pad=0.2, prop={\"ha\": \"center\"})\n   253\t    ax.add_artist(text1)\n   254\t    text2 = AnchoredText(\"test\\ntest long text\", loc=\"center right\",\n   255\t                         pad=0.2, prop={\"ha\": \"right\"})\n   256\t    ax.add_artist(text2)\n   257\t\n   258\t\n   259\tdef test_annotationbbox_extents():\n   260\t    plt.rcParams.update(plt.rcParamsDefault)\n   261\t    fig, ax = plt.subplots(figsize=(4, 3), dpi=100)\n   262\t\n   263\t    ax.axis([0, 1, 0, 1])\n   264\t\n   265\t    an1 = ax.annotate(\"Annotation\", xy=(.9, .9), xytext=(1.1, 1.1),\n   266\t                      arrowprops=dict(arrowstyle=\"->\"), clip_on=False,\n   267\t                      va=\"baseline\", ha=\"left\")\n   268\t\n   269\t    da = DrawingArea(20, 20, 0, 0, clip=True)\n   270\t    p = mpatches.Circle((-10, 30), 32)\n   271\t    da.add_artist(p)\n   272\t\n   273\t    ab3 = AnnotationBbox(da, [.5, .5], xybox=(-0.2, 0.5), xycoords='data',\n   274\t                         boxcoords=\"axes fraction\", box_alignment=(0., .5),\n   275\t                         arrowprops=dict(arrowstyle=\"->\"))\n   276\t    ax.add_artist(ab3)\n   277\t\n   278\t    im = OffsetImage(np.random.rand(10, 10), zoom=3)\n   279\t    im.image.axes = ax\n   280\t    ab6 = AnnotationBbox(im, (0.5, -.3), xybox=(0, 75),\n   281\t                         xycoords='axes fraction',\n   282\t                         boxcoords=\"offset points\", pad=0.3,\n   283\t                         arrowprops=dict(arrowstyle=\"->\"))\n   284\t    ax.add_artist(ab6)\n   285\t\n   286\t    fig.canvas.draw()\n   287\t    renderer = fig.canvas.get_renderer()\n   288\t\n   289\t    # Test Annotation\n   290\t    bb1w = an1.get_window_extent(renderer)\n   291\t    bb1e = an1.get_tightbbox(renderer)\n   292\t\n   293\t    target1 = [332.9, 242.8, 467.0, 298.9]\n   294\t    assert_allclose(bb1w.extents, target1, atol=2)\n   295\t    assert_allclose(bb1e.extents, target1, atol=2)\n   296\t\n   297\t    # Test AnnotationBbox\n   298\t    bb3w = ab3.get_window_extent(renderer)\n   299\t    bb3e = ab3.get_tightbbox(renderer)\n   300\t\n   301\t    target3 = [-17.6, 129.0, 200.7, 167.9]\n   302\t    assert_allclose(bb3w.extents, target3, atol=2)\n   303\t    assert_allclose(bb3e.extents, target3, atol=2)\n   304\t\n   305\t    bb6w = ab6.get_window_extent(renderer)\n   306\t    bb6e = ab6.get_tightbbox(renderer)\n   307\t\n   308\t    target6 = [180.0, -32.0, 230.0, 92.9]\n   309\t    assert_allclose(bb6w.extents, target6, atol=2)\n   310\t    assert_allclose(bb6e.extents, target6, atol=2)\n   311\t\n   312\t    # Test bbox_inches='tight'\n   313\t    buf = io.BytesIO()\n   314\t    fig.savefig(buf, bbox_inches='tight')\n   315\t    buf.seek(0)\n   316\t    shape = plt.imread(buf).shape\n   317\t    targetshape = (350, 504, 4)\n   318\t    assert_allclose(shape, targetshape, atol=2)\n   319\t\n   320\t    # Simple smoke test for tight_layout, to make sure it does not error out.\n   321\t    fig.canvas.draw()\n   322\t    fig.tight_layout()\n   323\t    fig.canvas.draw()\n   324\t\n   325\t\n   326\tdef test_zorder():\n   327\t    assert OffsetBox(zorder=42).zorder == 42\n   328\t\n   329\t\n   330\tdef test_arrowprops_copied():\n   331\t    da = DrawingArea(20, 20, 0, 0, clip=True)\n   332\t    arrowprops = {\"arrowstyle\": \"->\", \"relpos\": (.3, .7)}\n   333\t    ab = AnnotationBbox(da, [.5, .5], xybox=(-0.2, 0.5), xycoords='data',\n   334\t                        boxcoords=\"axes fraction\", box_alignment=(0., .5),\n   335\t                        arrowprops=arrowprops)\n   336\t    assert ab.arrowprops is not ab\n   337\t    assert arrowprops[\"relpos\"] == (.3, .7)\n   338\t\n", "path": "/tmp/tmpenvpl8sw/matplotlib/lib/matplotlib/tests/test_offsetbox.py", "prev_exist": true}, "action_id": "1abe0edc-2d00-4a79-8dd8-63864cbe45d3"}